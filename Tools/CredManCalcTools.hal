external inner function val GetCredManRate(Integer,string,val,Date);
external inner function LongInt DateDiff(Date,Date);
external inner function roundmode SetRoundModeD(Integer);
external inner function LongInt MonthDiff(Date,Date);
external procedure GetCredManOverdueInvoices(record CredManVc,record CredManSetBlock,Date,Date,var Integer,var val,var array string,Boolean,Boolean,var Date);
external inner function val AbsoluteVal(val);
external procedure BuildCredManInfoMatrix(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,var record SMVc);
forward procedure BuildCredManPayPlanCust(record CredManVc,var record CredManPayPlanVc,record CredManSetBlock,Boolean,Boolean);
external function Integer GetInterestPaymentType(record CredManVc);
external function Boolean PartiaBuyoutShortensPeriod();
external function Boolean HasMoneyTransferDate();

enum begin
  kEventTypeNone = 0,
  kEventTypeCalcInstalment = 1,
  kEventTypeCalcInterest = 2,
  kEventTypeCalcDeposit = 3,
  kEventTypeCalcFees = 4,
  kEventTypeIssueInstalment = 5,
  kEventTypeIssueInterest = 6,
  kEventTypeIssueDeposit = 7,
  kEventTypeIssueFees = 8,
  kEventTypeIssueLateFees = 9,
  kEventTypePaidInterest = 13,
  kEventTypePaidInstalment = 14,
  kEventTypePaidDeposit = 15,
  kEventTypePaidFees = 16,
  kEventTypeSoldAgreement = 17,
  kEventTypePayout = 18,
  kEventTypePartialBuyout = 19,
end;

enum begin
  kPlannedFeesMonthly = 0,
  kPlannedFeesOneTime = 1
end;

//This is used to get correct amounts (fees and interest) for first and last months (as they need to be different)
enum begin
  kMonthTypeFirst = 0,
  kMonthTypeRegular = 1,
  kMonthTypeLast = 2
end;

procedure CalcCredManCurrentPeriod(record CredManVc CredManr,record CMInvoicingBlock CIb,Integer paymentnr,Date payoutdate,var Date sdp,var Date edp,var Date int_sdp,var Date int_edp,var Date invd,var Date int_invdat)
begin
  record PDVc PDr;
  Date bd,nint_sdp;

  if (paymentnr==-1) then begin
    sdp = CredManr.startDate;
    edp = CredManr.FirstInvDate;
    invd = CredManr.FirstInvDate;
  end else begin
    sdp = AddMonth(CredManr.startDate,paymentnr);
    if (nonblankdate(CredManr.FirstInvDate)) then begin
      sdp = AddMonth(CredManr.FirstInvDate,paymentnr); //  - 1
    end;
    sdp.Day = CredManr.MonthlyPaymentDay;
    edp = AddMonth(sdp,1);
    invd = AddMonth(sdp,1);
    if (DaysInMonth(sdp.Year,sdp.Month)<sdp.Day) then begin 
      sdp.Day = DaysInMonth(sdp.Year,sdp.Month);
    end;
    sdp = AddDay(sdp,1);
  end;
  if (CIb.InvoiceDay==1) then begin
    PDr.Code = CredManr.PayDeal;
    if (ReadFirstMain(PDr,1,true)) then begin
      invd = AddDay(invd,-PDr.pdays);
    end;
  end;

  int_sdp = sdp;
  int_edp = edp;
  //if (paymentnr==-1) then begin
    if (nonblank(CredManr.FirstIntDate)) then begin
      nint_sdp = CredManr.FirstIntDate;
    end;
    if (HasMoneyTransferDate) then begin
      if (CredManr.MoneyTransferDate>int_sdp) then begin
        nint_sdp = CredManr.MoneyTransferDate;
      end;
    end;
    if (nonblank(payoutdate) and paymentnr==-1) then begin
      nint_sdp = payoutdate;
    end;
  //end;
  if (nint_sdp>int_sdp) then begin
    int_sdp = nint_sdp;
    sdp = int_sdp;
  end;
  int_invdat = invd;
  if (CIb.InterestIVType>=2) then begin
    int_invdat.Day = CIb.InterestIVDay;
    if (CIb.InterestIVType==3) then begin
      int_invdat = AddMonth(int_invdat,1);
    end;
  end;
  if (nonblank(CredManr.CancelDate)) then begin
    if (invd>CredManr.CancelDate) then begin
      invd = CredManr.CancelDate;
    end;
    if (edp>CredManr.CancelDate) then begin
      edp = CredManr.CancelDate;
    end;
    if (int_edp>CredManr.CancelDate) then begin
      int_edp = CredManr.CancelDate;
    end;
  end;
  

  return;
end;

global
function val GetAgreementAmount(record CredManVc CredManr)
begin
  val res;

  res = CredManr.InvSum4 - CredManr.DepositSum;
  if (nonblank(CredManr.ExtraDepositMonths)) then begin
    res = res - CredManr.ExtraDepositSum;
  end; 
  
  GetAgreementAmount = res;
  return;
end;

function Integer GetDaysInYear(record CMApplicationSetBlock CMb,record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  Integer res;

  res = -1;
  CMTr.Code = CredManr.Type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if (CMTr.DaysInYear>0) then begin
      res = CMTr.DaysInYear;
    end;
  end;

  if (res==-1) then begin
    res = CMb.DaysInYear;
  end;

  GetDaysInYear = res;
  return;
end;

function Integer GetDaysInMonth(record CMApplicationSetBlock CMb,record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  Integer res;
  record CMInterfaceSetBlock ISb;

  res = -1;
  if (ISb.UseCredManDaysInMonth==1) then begin
    if (CredManr.DaysInMonth>0) then begin
      res = CredManr.DaysInMonth-1;
    end;
  end;
  if (res==-1) then begin
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      if (CMTr.DaysInMonth>0) then begin
        res = CMTr.DaysInMonth-1;
      end;
    end;
  end;

  if (res==-1) then begin
    res = CMb.DaysInMonth;
  end;

  GetDaysInMonth = res;
  return;
end;

global
function val GetRateAmount(record CredManVc CredManr,val trate,Integer monthtypef,Date frdate,Date todate,val calcbal,Boolean ignoref,Boolean fixeddaysf)
begin
  record CMApplicationSetBlock CMb;
  record CMInvoicingBlock CIb;
  val days,res;
  Integer months;
  val rate;


  rate = trate;
  if (CredManr.AnnualRate==1 and ignoref==false) then begin
    rate = rate/12;
  end;
  days = DateDiff(todate,frdate)+1;
  BlockLoad(CMb);
  BlockLoad(CIb);
  switch (monthtypef) begin
    case kMonthTypeFirst:
/*
      months = MonthDiff(frdate,todate);
      if (frdate.Day!=todate.Day) then begin
        months = months - 1;//MonthDiff returns +1 if there are extra days
      end;
      if (months>0 and (fixeddaysf or GetDaysInMonth(CMb,CredManr)==0)) then begin
        days = DateDiff(todate,AddMonth(frdate,months))+1;
        res = GetAgreementAmount(CredManr)*(rate/100)*months;
        res = res + (GetAgreementAmount(CredManr)*rate/100*12/GetDaysInYear(CMb,CredManr)*days);
      end else begin
        res = GetAgreementAmount(CredManr)*rate/100*12/GetDaysInYear(CMb,CredManr)*days;
      end;
*/
        if (CIb.InterestFirstDay==0) then begin
          days = days - 1;
        end;
        if(CMb.FirstPeriodIsFullMonth==1)then begin
          if (frdate!=todate and frdate.Day==todate.day) then begin
            months = MonthDiff(frdate,todate);
            res = calcbal*months*(rate/100);
          end else begin
            res = calcbal*rate/100*12/GetDaysInYear(CMb,CredManr)*days;//GetAgreementAmount(CredManr)
          end;
        end else begin
          res = calcbal*rate/100*12/GetDaysInYear(CMb,CredManr)*days;//GetAgreementAmount(CredManr)
        end;
    case kMonthTypeRegular:
      if (fixeddaysf or GetDaysInMonth(CMb,CredManr)==0) then begin
        res = GetAgreementAmount(CredManr)*rate/100;
      end else begin
        res = GetAgreementAmount(CredManr)*rate/100*12/GetDaysInYear(CMb,CredManr)*days;
      end;   
    case kMonthTypeLast:
      if (fixeddaysf or GetDaysInMonth(CMb,CredManr)==0) then begin
        res = calcbal*rate/100;    
      end else begin
        res = calcbal*rate/100*12/GetDaysInYear(CMb,CredManr)*days;
      end;
  end;
    
  GetRateAmount = res;
  return;
end;

function Boolean MonthlyChargeType(Integer chargetype)
begin
  Boolean res;

  if (chargetype==1 or chargetype==3) then begin
    res = true;
  end;
  
  MonthlyChargeType = res;
  return;
end;

function Boolean CalculatedChargeType(Integer chargetype)
begin
  Boolean res;

  if (chargetype==2 or chargetype==3) then begin
    res = true;
  end;
  
  CalculatedChargeType = res;
  return;
end;

global
function Boolean TypeAffectsBalance(Integer type)
begin
  Boolean res;

  switch (type) begin
    case kEventTypeCalcInstalment:  res = true;
    case kEventTypeIssueInstalment: res = true;
    case kEventTypeIssueDeposit:    res = true;
    case kEventTypeCalcDeposit:     res = true;
    case kEventTypePartialBuyout:   res = true;
    case 11:                        res = true;//old partial buyout?
  end;
  
  TypeAffectsBalance = res;
  return;
end;

function Boolean TypeAffectsInterest(Integer type)
begin
  Boolean res;

  switch (type) begin
    case kEventTypeCalcInterest:  res = true;
    case kEventTypeIssueInterest: res = true;
  end;
  
  TypeAffectsInterest = res;
  return;
end;

procedure AddCredPayPlanLine2(record CredManPayPlanVc CredManPayPlanr,Date transdate,string item,string itemname,Integer type,val sum,val reb,var val acumint,var val calcbal,Date frdate,Date todate,Longint histnr,Longint factinv,val openamount,Integer invtype)
begin
  row CredManPayPlanVc CredManPayPlanrw,CredManPayPlan2rw;
  val v;
  Integer num,i;
  boolean skip;
  record CMBuyOutBlock CMBuyOutb;
  
  blockload(CMBuyOutb);
  
  skip = true;
  
  if(CMBuyOutb.UseRedesignedByuOut==1)then begin
    if(histnr>-1)then begin// Edit ************************** BPI Ukraine - KramarAlexandr - 03, 29 12 2021 y. at 4:13:14 PM
      for(i=0;i<matrowcnt(CredManPayPlanr);i=i+1)begin
        matrowget(CredManPayPlanr,i,CredManPayPlan2rw);
        if(CredManPayPlan2rw.PlanType==type and CredManPayPlan2rw.IssuedNr==histnr)then begin
          skip = false;
          logtext(0,"AddCredPayPlanLine2 skip");
        end;
      end;
    end;
  end;
  
  if(skip)then begin
    v = Round(sum,SetRoundModeD(2));//round(sum,SetRoundModeD(rounding));//CredManr.DepositSum,CredManSetb.DepositRoundOff
    if (v!=0) then begin
      CredManPayPlanrw.ArtCode = item;
      CredManPayPlanrw.Spec = itemname;
      CredManPayPlanrw.TransDate = transdate;
      CredManPayPlanrw.PlanType = type;
      CredManPayPlanrw.Sum = v;
      CredManPayPlanrw.Reb = reb;
      CredManPayPlanrw.FromDate = frdate;
      CredManPayPlanrw.ToDate = todate;
      CredManPayPlanrw.IssuedNr = histnr;
      CredManPayPlanrw.FactoringInvoice = factinv;
      CredManPayPlanrw.InvType = invtype;
      num = 99-type;
      CredManPayPlanrw.SortString = DateToString(transdate,"YYYYMMDD") & left("00",2-len(num)) & num;
      if (TypeAffectsInterest(type)) then begin
        CredManPayPlanrw.AcumulatedInt = acumint + v;
      end else begin
        CredManPayPlanrw.AcumulatedInt = acumint;
      end;
      if (TypeAffectsBalance(type)) then begin
        CredManPayPlanrw.Bal = calcbal - v;
      end else begin
        CredManPayPlanrw.Bal = calcbal;
      end;
      CredManPayPlanrw.OpenAmount = openamount;
      MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
      acumint = CredManPayPlanrw.AcumulatedInt;
      calcbal = CredManPayPlanrw.Bal;
    end;
  end;

  return;
end;

procedure AddCredPayPlanLine(record CredManPayPlanVc CredManPayPlanr,Date transdate,string item,string itemname,Integer type,val sum,val reb,var val acumint,var val calcbal,Date frdate,Date todate,Longint histnr,Longint factinv,val openamount)
begin
  
  AddCredPayPlanLine2(CredManPayPlanr,transdate,item,itemname,type,sum,reb,acumint,calcbal,frdate,todate,histnr,factinv,openamount,1);

  return;
end;

global
procedure AddInterest(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Longint factinv,Boolean overridef)
begin
  Integer sendmonthtypef;
  
  if (nonblank(frdate) and frdate<=todate) then begin
    sendmonthtypef = monthtypef;
    if ((CredManr.ChargeMethod==1) and overridef==false and sendmonthtypef!=kMonthTypeFirst) then begin
      sendmonthtypef = kMonthTypeLast;
    end;
    if (nonblank(CredManr.CancelDate) and invdate==CredManr.CancelDate) then begin
      sendmonthtypef = kMonthTypeFirst;
    end;
    AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.RateItem,"",kEventTypeCalcInterest,GetRateAmount(CredManr,CredManr.IntRate,sendmonthtypef,frdate,todate,calcbal,false,false),0,acumint,calcbal,frdate,todate,-1,factinv,0);
  end;

  return;
end;

global
procedure AddInterestBO(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Longint factinv,Boolean overridef)
begin
  Integer sendmonthtypef;
  
  sendmonthtypef = monthtypef;
  if ((CredManr.ChargeMethod==1) and overridef==false and sendmonthtypef!=kMonthTypeFirst) then begin
    sendmonthtypef = kMonthTypeLast;
  end;
  if (nonblank(CredManr.CancelDate) and invdate==CredManr.CancelDate) then begin
    sendmonthtypef = kMonthTypeFirst;
  end;
  AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.RateItem,"",kEventTypeCalcInterest,calcbal,0,acumint,calcbal,frdate,todate,-1,factinv,0);

  return;
end;

global
procedure AddExtraInterest(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Longint factinv,Boolean overridef,Integer int_type)
begin
  Integer sendmonthtypef;
  record CredHistVc CredHistr;
  Boolean TrHs;
  
  if (nonblank(frdate) and int_type==2 and calcbal>0) then begin
    sendmonthtypef = kMonthTypeFirst;
    CredHistr.TransDate = frdate;
    TrHs = true;
    while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,TrHs)) begin
      if (CredHistr.TransDate>todate) then begin
        TrHs = false;
      end else begin
        if (CredHistr.RecordType==5) then begin
          AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.RateItem,"",kEventTypeCalcInterest,GetRateAmount(CredManr,CredManr.IntRate,0,CredHistr.TransDate,todate,CredHistr.Sum,false,false),0,acumint,calcbal,frdate,todate,-1,factinv,0);
          if (CredManr.BuyoutFeePrc>0 and (CredManr.LoanType==7 or CredManr.LoanType==8)) then begin
           AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.RateItem,"",kEventTypeCalcInterest,GetRateAmount(CredManr,CredManr.BuyoutFeePrc,0,frdate,CredHistr.TransDate,CredHistr.Sum,false,false),0,acumint,calcbal,frdate,todate,-1,factinv,0);
          end;
        end;
      end;
    end;
  end;

  return;
end;

global
procedure AddUnusedInterest(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Longint factinv,Boolean overridef)
begin
  Integer sendmonthtypef;
  record CredHistVc CredHistr;
  Boolean TrHs;
  
  if (nonblank(frdate)) then begin
    sendmonthtypef = monthtypef;
    if ((CredManr.ChargeMethod==1) and overridef==false and sendmonthtypef!=kMonthTypeFirst) then begin
      sendmonthtypef = kMonthTypeLast;
    end;
    AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.RateItem,"",kEventTypeCalcInterest,GetRateAmount(CredManr,CredManr.BuyoutFeePrc,sendmonthtypef,frdate,todate,GetAgreementAmount(CredManr)-calcbal,false,false),0,acumint,calcbal,frdate,todate,-1,factinv,0);
  end;

  return;
end;


global
procedure AddInterestDelay(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Longint factinv)
begin
  Integer sendmonthtypef;

  sendmonthtypef = monthtypef;
  if (CredManr.ChargeMethod==1 and monthtypef!=kMonthTypeFirst) then begin
    sendmonthtypef = kMonthTypeLast;
  end;
  AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.RateItem,"",kEventTypeCalcInterest,GetRateAmount(CredManr,CredManr.PrincipleDelayInterest,sendmonthtypef,frdate,todate,calcbal,false,false),0,acumint,calcbal,frdate,todate,-1,factinv,0);

  return;
end;

global
function val AdjustFees(val sum,val minsum,val maxsum)
begin
  val res;

  res = sum;
  if (minsum>0 and res<minsum) then begin
    res = minsum;
  end;
  if (maxsum>0 and res>maxsum) then begin
    res = maxsum;
  end;

  AdjustFees = res;
  return;
end;

global
procedure AddPlannedFees(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer type,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Longint factinv,Boolean ContractFeef)
begin
  Integer i,rwcnt;
  row CredManVc CredManrw;
  val sum;
  Date td;
  Integer invtype;
  Boolean testf;

  rwcnt = MatRowCnt(CredManr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManr,i,CredManrw);
    testf = true;
    if (type==kPlannedFeesMonthly and MonthlyChargeType(CredManrw.ChargeType)==false) then begin
      testf = false;
    end;
    if (type==kPlannedFeesOneTime and MonthlyChargeType(CredManrw.ChargeType)) then begin
      testf = false;
    end else begin
      if (blank(frdate) and CredManrw.InvDate>CredManr.FirstInvDate) then begin
        testf = false;
      end;
    end;
    
    if (nonblank(frdate) and nonblank(CredManrw.InvDate) and DateInRange(CredManrw.InvDate,frdate,todate) and CredManrw.InvDate>=CredManr.FirstInvDate) then begin
      testf = true;
    end;
    if (testf) then begin
      td = invdate;
      invtype = 1;
      if (nonblank(CredManrw.InvDate)) then begin
        td = CredManrw.InvDate;
      end;
      if (ContractFeef) then begin
        invtype = 0;
      end;
      if (CalculatedChargeType(CredManrw.ChargeType)) then begin
        sum = AdjustFees(GetRateAmount(CredManr,CredManrw.vRebate,monthtypef,frdate,todate,calcbal,true,true),CredManrw.MinSum,CredManrw.MaxSum);
        AddCredPayPlanLine2(CredManPayPlanr,td,CredManrw.ArtCode,"",kEventTypeCalcFees,sum,0,acumint,calcbal,frdate,todate,-1,factinv,0,invtype);
      end else begin
        sum = AdjustFees(CredManrw.Price,CredManrw.MinSum,CredManrw.MaxSum);
        AddCredPayPlanLine2(CredManPayPlanr,td,CredManrw.ArtCode,"",kEventTypeCalcFees,sum,CredManrw.vRebate,acumint,calcbal,frdate,todate,-1,factinv,0,invtype);
      end;
    end;
  end;
  
  return;
end;

procedure AddDeposit(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  
  AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.DepositItem,"",kEventTypeCalcInstalment,CredManr.DepositSum,0,acumint,calcbal,frdate,todate,-1,-1,0);//kEventTypeCalcDeposit>>kEventTypeCalcInstalment

  return;
end;

function Integer GetMonthCount(string tstr,var Integer lastmonth)
begin
  Integer res;
  Longint pos;
  string 255 tmp;
  
  while (GetNextSubstring(tstr,pos,",",tmp)) begin
    res = res + 1;
    lastmonth = StringToInt(tmp);
  end;

  GetMonthCount = res;
  return;
end;

procedure AddExtraDeposit(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Integer month)
begin
  val extradep;
  Integer totmonths,lastmonth;
  
  if (CredManr.ExtraDepositSum>0) then begin
    if (nonblank(CredManr.ExtraDepositMonths) and SetInSet(month,CredManr.ExtraDepositMonths)) then begin
      totmonths = GetMonthCount(CredManr.ExtraDepositMonths,lastmonth);
      extradep = Round(CredManr.ExtraDepositSum/totmonths,SetRoundModeD(2));
      if (month==lastmonth) then begin
        extradep = extradep + (CredManr.ExtraDepositSum-(extradep*totmonths));
      end;

      AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.DepositItem,"",kEventTypeCalcInstalment,extradep,0,acumint,calcbal,frdate,todate,-1,-1,0);//kEventTypeCalcDeposit>>kEventTypeCalcInstalment
    end;
  end;
  return;
end;


global
function val FIN_PMT(val monthly_rate, integer payments, val total_sum)
begin
  val t, t2;
  if (monthly_rate==0) then begin
    t = total_sum/payments;
  end else begin
    t = monthly_rate * (total_sum * power(1 + monthly_rate, payments)) / (power(1 + monthly_rate, payments) - 1);
  end;
  //logtext(0,"FIN_PMT total_sum " & total_sum);
  FIN_PMT = t;
  return;
end;

function val FIN_PPMT(val monthly_rate, integer payments, val total_sum, integer payment_nr)
begin
  val res, t, c;
  
  if (monthly_rate==0) then begin
    res = -(total_sum/payments);
  end else begin
    c = Round(-FIN_PMT(monthly_rate, payments, total_sum),SetRoundModeD(2));//monthly payment. 
    res = c + (c * (power(1 + monthly_rate, payment_nr-1) - 1) / monthly_rate + total_sum * power(1 + monthly_rate, payment_nr-1)) * monthly_rate;
  end;
  FIN_PPMT = -res;
  return;
end;

function val GetCurrentMonthPayment(record CredManPayPlanVc CredManPayPlanr,Date invdate,val sum)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  val res;
  
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=rwcnt-1;i>0;i=i-1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.TransDate==invdate) then begin
      res = res + CredManPayPlanrw.Sum;
    end else begin
      i = -1;
    end;
  end;
  res = res + sum;

  GetCurrentMonthPayment = res;
  return;
end;

function Boolean LinearInstalment(Integer type)
begin
  Boolean res;

  switch (type) begin
    case 1: res = true;
    case 2: res = true;
    case 6: res = true;
  end;

  LinearInstalment = res;
  return;
end;

function val CalculateAnnuityDiff(record CredManVc CredManr,val diff,Integer usemonths)
begin
  val res;
  val rate,ndiff,mdiff,tdiff;
  Integer i;

  res = 0;
  rate = CredManr.IntRate;
  if (CredManr.AnnualRate==1) then begin
    rate = rate/12;
  end;
  rate = rate/100;
  mdiff = diff/(usemonths);
  ndiff = mdiff - (mdiff/(1+rate));
  tdiff = ndiff;
  for (i=0;i<usemonths;i=i+1) begin
    tdiff = tdiff + ((i+1)*ndiff);
  end;
  //rate = 0.00001;
  res = rate * (diff * power(1 + rate, usemonths)) / (power(1 + rate, usemonths) - 1);
/*
  for (i=0;i<usemonths;i=i+1) begin
    res = res - FIN_PPMT(rate, usemonths, diff, i+1);
  end;
*/
  //res = diff - tdiff;//(diff*0.31855);//(ndiff*usemonths);//(diff*0.31855);// - (diff*0.1);// - (diff*0.1);//0.42

  CalculateAnnuityDiff = res;
  return;
end;

procedure FixupInstalmentAmount(var val sum,val calcbal)
begin
  
  if (sum>calcbal) then begin
    sum = calcbal;
  end;

  return;
end;

function val GetActualDaysRate(record CMApplicationSetBlock CMAb,record CredManVc CredManr,val rate,Date frdate,Date todate)
begin
  val res,tmp;
  Integer days;

  days = DateDiff(todate,frdate);
  res = rate*12/GetDaysInYear(CMAb,CredManr)*days;
  
  GetActualDaysRate = res;
  return;
end;

function val GetCurMonthInterest(record CredManPayPlanVc CredManPayPlanr,Date invdate)
begin
  Integer cnt;
  row CredManPayPlanVc CredManPayPlanrw;
  val tint;
  Boolean testf;

  tint = 0;
  cnt = 1;
  if (MatRowCnt(CredManPayPlanr)-cnt>=0) then begin
    MatRowGet(CredManPayPlanr,MatRowCnt(CredManPayPlanr)-cnt,CredManPayPlanrw);
    testf = (CredManPayPlanrw.TransDate==invdate and CredManPayPlanrw.PlanType==kEventTypeCalcInterest);
    while (testf) begin
      tint = tint + CredManPayPlanrw.Sum;
      cnt = cnt + 1;
      if (MatRowCnt(CredManPayPlanr)-cnt>=0) then begin
        MatRowGet(CredManPayPlanr,MatRowCnt(CredManPayPlanr)-cnt,CredManPayPlanrw);
        testf = (CredManPayPlanrw.TransDate==invdate and CredManPayPlanrw.PlanType==kEventTypeCalcInterest);
      end else begin
        testf = false;
      end;
    end;
  end;
  GetCurMonthInterest = tint;
  return;
end;

function val GetAnnuityDiffLimit(Integer usemonths)
begin
  val res,tmpval;

  if (usemonths>100) then begin
    tmpval = usemonths;
    tmpval = tmpval/100;
    res = Power(tmpval,2);
    if (usemonths>200) then begin
      res = 2;
    end;
  end else begin
    res = 1;
  end;
  
  GetAnnuityDiffLimit = res;
  return;
end;

procedure AddInstalment(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer type,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Integer month,val usesum,Integer usemonths,var val extra_diff)
begin
  val sum,curpayment,rate,tusesum;
  Integer months,tusemonths;
  record CMApplicationSetBlock CMAb;
  row CredManPayPlanVc CredManPayPlanrw;
  val tsum,tint,nint;
  
  
  
  switch (type) begin
    case 0:
      AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,calcbal,0,acumint,calcbal,frdate,todate,-1,-1,0);
    case 1:
      if (monthtypef==kMonthTypeLast) then begin
        AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,calcbal,0,acumint,calcbal,frdate,todate,-1,-1,0);
      end else begin
        //for max monthly payments we need to check the instalment amount. 
        sum = usesum/usemonths;
        if (LinearInstalment(CredManr.InstalmentType) and CredManr.MaxMonthlyPayment>0) then begin
          //get current month payment
          curpayment = GetCurrentMonthPayment(CredManPayPlanr,invdate,sum);
          if (CredManr.MaxMonthlyPayment<curpayment) then begin
            sum = CredManr.MaxMonthlyPayment-(curpayment-sum);
          end;
        end;

        if (CredManr.LastMonthPrinc>0 and CredManr.MaxMonthlyPayment==0) then begin
          sum = usesum-CredManr.LastMonthPrinc;
          if (CredManr.LastPrincipleWithExtraMonth==1) then begin
            sum = sum/(usemonths);
          end else begin
            sum = sum/(usemonths-1);
          end;
          if (calcbal-sum<(CredManr.LastMonthPrinc+(usemonths*0.01))) then begin//0.01 is the possible diff that can be
            sum = calcbal - CredManr.LastMonthPrinc;
          end;
        end;
        FixupInstalmentAmount(sum,calcbal);
        AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,sum,0,acumint,calcbal,frdate,todate,-1,-1,0);
      end;
    case 2:
      if (monthtypef==kMonthTypeLast) then begin
        AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,calcbal,0,acumint,calcbal,frdate,todate,-1,-1,0);
      end else begin
        rate = CredManr.IntRate;
        if (CredManr.AnnualRate==1) then begin
          rate = rate/12;
        end;
        rate = rate/100;

        tusemonths = usemonths;
        tusesum = usesum;
        if (CredManr.LastMonthPrinc>0 and CredManr.MaxMonthlyPayment==0) then begin
          if (CredManr.LastPrincipleWithExtraMonth==1) then begin
            tusemonths = tusemonths;
          end else begin
            tusemonths = tusemonths - 1;
          end;

          tusesum = usesum - CredManr.LastMonthPrinc;
        end;
        sum = FIN_PPMT(rate, tusemonths, tusesum, month+1);
        BlockLoad(CMAb);
        
        if (GetDaysInMonth(CMAb,CredManr)==1) then begin
          //get monthly sum
          //substract interest
          tsum = FIN_PMT(rate, tusemonths, tusesum);
          if (extra_diff!=0) then begin
            //logtext(0,"dd " & extra_diff & ":" & (extra_diff/(tusemonths)));
            tsum = tsum - (extra_diff/(tusemonths));
          end;
          tint = GetCurMonthInterest(CredManPayPlanr,invdate);
          if (CredManr.LastMonthPrinc>0 and CredManr.MaxMonthlyPayment==0) then begin
            //get interest from 1000 eur 
            //nint/tusemonths
            nint = GetRateAmount(CredManr,CredManr.IntRate,2,frdate,todate,CredManr.LastMonthPrinc,false,true);
            tint = tint - nint;
          end;
          sum = tsum - tint;
        end else begin
          if (month==1 and extra_diff==0) then begin
            tsum = FIN_PMT(rate, tusemonths, tusesum);
            tint = GetCurMonthInterest(CredManPayPlanr,invdate);
            tsum = tsum - tint;
            extra_diff = CalculateAnnuityDiff(CredManr,tsum-sum,tusemonths);
            sum = tsum;
            //extra_diff = 0;
            if (AbsoluteVal(extra_diff)>GetAnnuityDiffLimit(usemonths)) then begin
              sum = tsum - (extra_diff/(tusemonths/5));
            end else begin
              extra_diff = 0;
            end;
          end else begin
            if (extra_diff!=0) then begin
              tint = GetCurMonthInterest(CredManPayPlanr,invdate);
              sum = FIN_PMT(rate, tusemonths, tusesum);
              sum = sum - (extra_diff/(tusemonths/5)) - tint;
            end else begin
              tsum = FIN_PMT(rate, tusemonths, tusesum);
              tint = GetCurMonthInterest(CredManPayPlanr,invdate);
              sum = tsum - tint;
            end;
          end;
        end;

        if (CredManr.MaxMonthlyPrinciple>0) then begin
          if (sum>CredManr.MaxMonthlyPrinciple) then begin
            sum = CredManr.MaxMonthlyPrinciple;
          end;
        end;
        if (CredManr.MaxMonthlyPayment>0) then begin
          curpayment = GetCurrentMonthPayment(CredManPayPlanr,invdate,sum);
          if (CredManr.MaxMonthlyPayment<curpayment) then begin
            sum = CredManr.MaxMonthlyPayment-(curpayment-sum);
          end;
          extra_diff = 0;
        end;
        if (CredManr.LastMonthPrinc>0 and CredManr.MaxMonthlyPayment==0 and month==(tusemonths-1)) then begin
          if (calcbal-sum!=CredManr.LastMonthPrinc) then begin
            sum = calcbal - CredManr.LastMonthPrinc;
          end;
        end;
        if (sum<0) then begin
          sum = 0;
        end;
        
        FixupInstalmentAmount(sum,calcbal);
        AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,sum,0,acumint,calcbal,frdate,todate,-1,-1,0);
      end;
  end;
 return;
end;

global
procedure AddInstalmentFixed(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,val amount,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,val issuedinsbal)
begin
  val newcalcbal;
  record CMInvoicingBlock CMIb;
  record CMBuyOutBlock CMBOb;
  
  if(issuedinsbal>0)then begin
    blockload(CMIb);
    blockload(CMBOb);
    if(nonblank(CMBOb.PremTermPrincpl))then begin
      newcalcbal = amount - issuedinsbal;
      if(issuedinsbal>0)then begin
        AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,issuedinsbal,0,acumint,calcbal,frdate,todate,-1,-1,0);
      end;  
      if(newcalcbal>0)then begin
        AddCredPayPlanLine(CredManPayPlanr,invdate,CMBOb.PremTermPrincpl,"",kEventTypeCalcInstalment,newcalcbal,0,acumint,calcbal,frdate,todate,-1,-1,0);
      end;
    end else begin
      AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,amount,0,acumint,calcbal,frdate,todate,-1,-1,0);
    end;
  end else begin
    AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,amount,0,acumint,calcbal,frdate,todate,-1,-1,0);
  end;
  
  return;
end;

global
procedure AddInstalmentFixedBO(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,val amount,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  val newcalcbal;
  record CMInvoicingBlock CMIb;
  record CMBuyOutBlock CMBOb;
  
  if(amount>0)then begin
    blockload(CMIb);
    blockload(CMBOb);
    if(nonblank(CMBOb.PremTermPrincpl))then begin
      AddCredPayPlanLine(CredManPayPlanr,invdate,CMBOb.PremTermPrincpl,"",kEventTypeCalcInstalment,amount,0,acumint,calcbal,frdate,todate,-1,-1,0);
    end;
  end;
  
  return;
end;


function Boolean GetPreviousMonthPayment(record CredManPayPlanVc CredManPayPlanr,record CredManVc CredManr,Date frdate,var val tval)
begin
  Integer rwcnt,i;
  row CredManPayPlanVc CredManPayPlanrw;
  Boolean res;
  Date lastdate;
  
  tval = 0;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=rwcnt-1;i>=0;i=i-1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.FromDate<frdate) then begin
      if (lastdate!=CredManPayPlanrw.FromDate and nonblank(lastdate)) then begin
        goto LGetPreviousMonthPayment;
      end;
      if ((CredManPayPlanrw.PlanType==1 or CredManPayPlanrw.PlanType==2 or CredManPayPlanrw.PlanType==4 or CredManPayPlanrw.PlanType==5 or CredManPayPlanrw.PlanType==6 or CredManPayPlanrw.PlanType==8) and (CredManPayPlanrw.TransDate>CredManr.FirstInvDate)) then begin
        tval = tval + CredManPayPlanrw.Sum;
        res = true;
        lastdate = CredManPayPlanrw.FromDate;
      end;
    end;

  end;

LGetPreviousMonthPayment:;
  GetPreviousMonthPayment = res;
  return;
end;

function val GetMaxMonthlyPaymentForPartialBuyout(record CredManPayPlanVc CredManPayPlanr,record CredManVc CredManr,val buyoutval,Date frdate,Integer usemonths,val prevusesum,var Integer reducemonths,Integer curmonth)
begin
  val rate,res,payval,monthlypayment;

  rate = CredManr.IntRate;
  if (CredManr.AnnualRate==1) then begin
    rate = rate/12;
  end;
  rate = rate/100;
  monthlypayment = (CredManr.InvSum4-CredManr.DepositSum)/(CredManr.InstalmentMonths-CredManr.PrincipleDelayMonths);
  reducemonths = buyoutval/monthlypayment+1;

  if (curmonth>CredManr.PrincipleDelayMonths and GetPreviousMonthPayment(CredManPayPlanr,CredManr,frdate,payval)) then begin
    res = payval;  
  end else begin
    if (CredManr.InstalmentType==1) then begin
      res = monthlypayment;
    end else begin
      res = FIN_PMT(rate, usemonths, prevusesum); 
    end;
  end;    

  GetMaxMonthlyPaymentForPartialBuyout = res;
  return;
end;

function Integer GetCredHistType(string artcode,Integer type,Boolean paidflag)
begin
  record CredManSetBlock CMSb;
  Integer res;

  if (type>0) then begin
    res = type;
    goto LGetCredHistType;
  end;

  res = 0;
  BlockLoad(CMSb);
  if (artcode==CMSb.InstalmentItem) then begin
    if (paidflag) then begin
      res = kEventTypePaidInstalment;
    end else begin
      res = kEventTypeIssueInstalment;
    end;
  end else begin
    if (artcode==CMSb.RateItem) then begin
      if (paidflag) then begin
        res = kEventTypePaidInterest;
      end else begin
        res = kEventTypeIssueInterest;
      end;
    end else begin
      if (artcode==CMSb.DepositItem) then begin
        if (paidflag) then begin
          res = kEventTypePaidDeposit;
        end else begin
          res = kEventTypeIssueDeposit;
        end;
      end else begin
        if (paidflag) then begin
          res = kEventTypePaidFees;
        end else begin
          res = kEventTypeIssueFees;
        end;
      end;
    end;
  end;

LGetCredHistType:;
  GetCredHistType = res;
  return;
end;

function Boolean IsInitialInvoice(record CredManVc CredManr,Date transdate,Longint lastrecnr,Boolean firstinvf)
begin
  Boolean res;

  if (CredManr.startDate==transdate or CredManr.FirstInvDate>transdate) then begin
    if (lastrecnr==-1 or firstinvf) then begin
      res = true;
    end;
  end;
  
  IsInitialInvoice = res;
  return;
end;

global
function val GetCredHistOpenAmount(record CredHistVc CredHistr,Integer checktype)
begin
  val res,paid;
  Boolean TrHs;
  Integer type;
  record CredHistVc CredHist2r;

  type = GetCredHistType(CredHistr.ArtCode,-1,false); 
  if (type==checktype) then begin
    TrHs = true;
    CredHist2r.PreviousNr = CredHistr.SerNr;
    while (LoopKey("PreviousNr",CredHist2r,1,TrHs)) begin
      if (CredHist2r.PreviousNr!=CredHistr.SerNr) then begin
        TrHs = false;
      end else begin
        paid = paid + CredHist2r.Sum;
      end;
    end;

    res = CredHistr.Sum - paid;
  end;

  GetCredHistOpenAmount = res;
  return;
end;

global
function Date GetLastInvDate(record CredManVc CredManr)
begin
  Date res;
  Boolean TrHs;
  record CredHistVc CredHistr;
  Date td;
  
  TrHs = true;
  CredHistr.CredManNr = CredManr.SerNr;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if (CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      if (CredHistr.RecordType==0 and (CredHistr.ChargeType==kEventTypeIssueInstalment or CredHistr.ChargeType==kEventTypeIssueInterest)) then begin
        td = CredHistr.CredToDate;
        if (blank(td)) then begin
          td = CredHistr.TransDate;
        end;
        if (td>res) then begin
          res = td;
        end;
      end;
    end;
  end;

  GetLastInvDate = res;
  return;
end;

global
function Boolean IsPartialBuyoutType(Integer type)
begin
  Boolean res;
  
  if (type==kEventTypePartialBuyout or type==11) then begin
    res = true;
  end;

  IsPartialBuyoutType = res;
  return;
end;

procedure AddActualsToPlan(record CredManVc CredManr,var record CredmanPayPlanVc CredManPayPlanr,var Integer calculatedmonths,var val acumint,var val calcbal,var Boolean firstinvf,record CredManSetBlock CredManSetb,var Integer months,var val buyoutamount,var val pausebal,var val prolongbal,Integer int_type,var val usesum,var Integer usemonths,Boolean planf)
begin
  record CredHistVc CredHistr,PrevCredHistr;
  Boolean TrHs,skip;
  Integer type;
  Longint lastrecnr;
  vector Boolean vFirstInv;
  val monthlypayment,openamount;
  Integer reducemonths;
  Date lastinvdate;
  val prevusesum;
  record CMBuyOutBlock CMBuyOutb;
    
  blockload(CMBuyOutb);

  firstinvf = false;
  lastinvdate = GetLastInvDate(CredManr);
  calculatedmonths = 0;
  TrHs = true;
  prevusesum = usesum;
  CredHistr.CredManNr = CredManr.SerNr;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if (CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
 //     if (CredHistr.RecordType==0) then begin
      if (CredHistr.ChargeType!=14 and CredHistr.RecordType!=5 and CredHistr.ChargeType!=17) then begin
        openamount = 0;
        switch (CredHistr.RecordType) begin
          case 0: 
            type = GetCredHistType(CredHistr.ArtCode,CredHistr.ChargeType,false); 
            openamount = GetCredHistOpenAmount(CredHistr,kEventTypeIssueInstalment);
          case 4: 
            type = GetCredHistType(CredHistr.ArtCode,CredHistr.ChargeType,false); 
          otherwise
            PrevCredHistr.SerNr = CredHistr.PreviousNr;
            ReadFirstMain(PrevCredHistr,1,true);
            type = GetCredHistType(PrevCredHistr.ArtCode,-1,true);          
        end;
        if (IsPartialBuyoutType(CredHistr.ChargeType) and ((CredHistr.TransDate>lastinvdate or blank(lastinvdate)) and planf)) then begin
          goto LAddActualsToPlan_Next;
        end;
        AddCredPayPlanLine(CredManPayPlanr,CredHistr.TransDate,CredHistr.ArtCode,"",type,CredHistr.Sum,0,acumint,calcbal,CredHistr.CredFromDate,CredHistr.CredToDate,CredHistr.SerNr,-1,openamount);
        if (IsPartialBuyoutType(CredHistr.ChargeType)) then begin
          prevusesum = usesum;
          usesum = calcbal;
        end;
        if (IsPartialBuyoutType(CredHistr.ChargeType)) then begin
          buyoutamount = buyoutamount + CredHistr.Sum;
        end;
        if (CredHistr.RecordType==0 and IsPartialBuyoutType(CredHistr.ChargeType)==false and CredHistr.ChargeType!=kEventTypeIssueLateFees) then begin
          if (IsInitialInvoice(CredManr,CredHistr.TransDate,lastrecnr,vFirstInv[CredHistr.RecordNr])) then begin
            firstinvf = true;
            vFirstInv[CredHistr.RecordNr] = true;//we can have multiple records for single invoice. so we need to store that this invoice is the initial invoice
          end else begin
            if (CredHistr.ChargeType==kEventTypeIssueInstalment or CredHistr.ChargeType==kEventTypeIssueInterest) then begin//invoice
              if (CredHistr.PayDate>=CredManr.FirstInvDate) then begin//trans date is not correct, but pay date is not ideal as well
                skip = false;
                if(CMBuyOutb.UseRedesignedByuOut==1)then begin
                  if(getmonth(CredHistr.TransDate)==getmonth(CredHistr.CredFromDate) and getmonth(CredHistr.TransDate)==getmonth(CredHistr.CredToDate))then begin
                    //skip = true;
                  end;
                end;
                if(!skip)then begin
                  calculatedmonths = MonthDiff(CredManr.FirstInvDate,CredHistr.TransDate)+1;
                end;
              end;
            end;
          end;
          lastrecnr = CredHistr.RecordNr;
        end;
      end;
      if (CredHistr.RecordType==5 and ((CredHistr.TransDate<=lastinvdate and nonblank(lastinvdate)) or planf==false)) then begin
        calcbal = calcbal + CredHistr.Sum;
        AddCredPayPlanLine(CredManPayPlanr,CredHistr.TransDate,"","",kEventTypePayout,CredHistr.Sum,0,acumint,calcbal,"","",CredHistr.SerNr,-1,openamount);
        prevusesum = usesum;
        usesum = calcbal;
      end;
    end;
LAddActualsToPlan_Next:;
  end;
  if (buyoutamount>0) then begin
    //if (CredManr.InstalmentType==2 or CredManr.InstalmentType==6 or CredManr.InstalmentType==7) then begin
      if (calculatedmonths>CredManr.PrincipleDelayMonths) then begin
        usemonths = months - calculatedmonths;
      end;
      if (PartiaBuyoutShortensPeriod) then begin
        CredManr.MaxMonthlyPrinciple = GetMaxMonthlyPaymentForPartialBuyout(CredManPayPlanr,CredManr,CredHistr.Sum,CredHistr.TransDate,usemonths,prevusesum,reducemonths,calculatedmonths);
        usemonths = months - calculatedmonths - reducemonths;
      end;

    //end;
  end;

  return;
end;

procedure AddInitialInvoice(record CredManVc CredManr,var record CredmanPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  
  AddPlannedFees(CredManr,CredManPayPlanr,CMb,kPlannedFeesOneTime,kMonthTypeRegular,CredManr.startDate,acumint,calcbal,frdate,todate,-1,true);
  AddDeposit(CredManr,CredManPayPlanr,CMb,CredManr.startDate,acumint,calcbal,frdate,todate);

  return;
end;

function Integer GetMonthType(Integer month,Integer totmonths)
begin
  Integer res;

  res = kMonthTypeRegular;
  if (month==0) then begin
    res = kMonthTypeFirst;
  end;
  if (month==totmonths-1) then begin
    res = kMonthTypeLast;
  end;

  GetMonthType = res;
  return;
end;

procedure AddFactoringInvoices(record CredManVc inCredManr,var record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  val tcalcbal;
  record CredManFactInvoiceVc CMIr;
  Boolean TrHs;
  
  TrHs = true;
  CMIr.CustPaidFlag = 1;
  CMIr.FeeGenFlag = 0;
  while (LoopKey("CustPaidFlag:" & inCredManr.SerNr,CMIr,2,TrHs)) begin
    if (CMIr.CustPaidFlag!=1 or CMIr.FeeGenFlag!=0) then begin
      TrHs = false;
    end else begin
      tcalcbal = CMIr.TotalSum*inCredManr.LoanToValue/100;
      AddInterest(inCredManr,CredManPayPlanr,CredManSetb,kMonthTypeLast,invdate,acumint,tcalcbal,CMIr.InvDate,CMIr.PaymentDate,CMIr.SerNr,false);  
      tcalcbal = CMIr.TotalSum*inCredManr.LoanToValue/100;
      AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesOneTime,kMonthTypeLast,invdate,acumint,tcalcbal,CMIr.InvDate,CMIr.PaymentDate,CMIr.SerNr,false);//kPlannedFeesOneTime or kPlannedFeesMonthly?
    end;
  end;

  return;
end;

procedure AddLateFees(record CredManVc CredManr,var record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,record CMInvoicingBlock CIb,Date invdat,Date frdate,Date todate,var val acumint,var val calcbal)
begin
  Integer latedays;
  val lateamount;
  Date invdat2;
  Date sd,ed;
  array string 255 lateformula;
  Boolean addf;
  record CredManTypeVc CMTr;
  string 255 item;
  Date calcsd;
  
  if (CIb.OverdueIVType==2) then begin
    sd = AddMonth(frdate,-1);
    ed = AddDay(AddMonth(sd,1),-1);
    invdat2 = invdat;
    invdat2.Day = CIb.OverdueIVDay;
    GetCredManOverdueInvoices(CredManr,CredManSetb,ed,sd,latedays,lateamount,lateformula,false,false,calcsd);
    addf = true;
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      if (CMTr.MinOverdueFee>0 and lateamount<CMTr.MinOverdueFee) then begin
        addf = false;
      end;
    end;
    if (addf) then begin
      item = CredManSetb.LateRateItem;
      if (CredManr.UseCompensationInvoices==1) then begin
        item = CIb.CompensationItem;
      end;
      AddCredPayPlanLine(CredManPayPlanr,invdat2,item,"",kEventTypeIssueLateFees,lateamount,0,acumint,calcbal,frdate,todate,-1,-1,0);
    end;
  end;

  return;
end;

procedure AddRefFees(record CredManVc CredManr,var record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,record CMInvoicingBlock CIb,Date invdat,Date frdate,Date todate,var val acumint,var val calcbal,val feesval)
begin
  Integer latedays;
  val lateamount;
  Date invdat2;
  Date sd,ed;
  array string 255 lateformula;
  Boolean addf;
  record CredManTypeVc CMTr;
  string 255 item;
  Date calcsd;
  record CMBuyOutBlock CMBuyOutb;
  
  if(feesval>0)then begin
  
    blockload(CMBuyOutb);

    item = CMBuyOutb.FutFeeItem;
    if(nonblank(item))then begin
      AddCredPayPlanLine(CredManPayPlanr,invdat,item,"",kEventTypeCalcFees,feesval,0,acumint,calcbal,frdate,todate,-1,-1,0);
    end;
  end;

  return;
end;

function val GetBalanceOnDate(record CredManPayPlanVc CredManPayPlanr,Date invdat)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  val res;
  Boolean testf;

  SortRows(CredManPayPlanr,"SortString",true);
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.TransDate<=invdat) then begin
      testf = true;
      if (CredManPayPlanrw.Bal<res and CredManPayPlanrw.PlanType==kEventTypePayout) then begin
        testf = false;
      end;
      if (TypeAffectsBalance(CredManPayPlanrw.PlanType)==false and CredManPayPlanrw.PlanType!=kEventTypePayout) then begin
        testf = false;
      end;
      if (testf) then begin
        res = CredManPayPlanrw.Bal;//This is fallback balance 
      end;
    end;
    if (CredManPayPlanrw.TransDate>invdat) then begin
      i = rwcnt;
    end;
  end;

  GetBalanceOnDate = res;
  return;
end;

procedure LoadAgreementChangesToDate(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,Integer calculatedmonths,var Boolean prolongf,var Integer prolongstartmonths,var val prolongbal,var Integer months,var Integer usemonths,var val usesum,var Integer pausestartmonths,var Boolean waspausedf,var Date pausefrom,var Date pauseuntil,var Integer pausemonths,var val refinfees,var integer futfeesmonths,var boolean foundf,var date chdate)
begin
  Date sd,ed;
  record CredManChangeVc Changer;
  Boolean TrHs;
  record CredManTypeVc CMTr;
    
  sd = CredManr.startDate;
  ed = AddMonth(CredManr.FirstInvDate,calculatedmonths-1);

  Changer.CredManNr = CredManr.SerNr;
  Changer.TransDate = sd;
  TrHs = true;
  
  while (LoopKey("CredManDate",Changer,2,TrHs)) begin
    if (CredManr.SerNr!=Changer.CredManNr or Changer.TransDate>ed) then begin
      TrHs = false;
    end else begin
      if (Changer.OKFlag==1) then begin
        if(nonblank(Changer.NewType))then begin// Edit ************************** BPI Ukraine - KramarAlexandr - 03, 08 12 2021 y. at 10:46:12 AM
          CredManr.Type = Changer.NewType;
          CMTr.Code = CredManr.Type;
          if(readfirstmain(CMTr,1,true))then begin
            CredManr.InstalmentType = CMTr.InstalmentType;
          end;
        end;
        if (nonblank(Changer.IntRate)) then begin
          CredManr.IntRate = Changer.IntRate;
          CredManr.PrincipleDelayInterest = Changer.IntRate;
          CredManr.AnnualRate = Changer.AnnualRate;
        end;
        if (Changer.OverduePercentage!=0) then begin
          CredManr.OverduePercentage = Changer.OverduePercentage;
        end;
        if (Changer.MonthlyPaymentDay>0) then begin
          CredManr.MonthlyPaymentDay = Changer.MonthlyPaymentDay;
        end;
        if (Changer.ProlongMonths>0) then begin
          prolongstartmonths = MonthDiff(CredManr.FirstInvDate,Changer.TransDate);
          if (GetDay(Changer.TransDate)!=GetDay(CredManr.FirstInvDate)) then begin
            prolongstartmonths = prolongstartmonths + 1;
          end;
          months = months + Changer.ProlongMonths;
          usemonths = months - prolongstartmonths;
          usesum = GetBalanceOnDate(CredManPayPlanr,Changer.TransDate);
          prolongf = true;
        end;
        
        
        refinfees = Changer.FutureFees;
        futfeesmonths = Changer.AddedFeesMonths;
        if(Changer.IntRate!=blankval or Changer.AddValue!=0)then begin
          foundf = true;
          chdate = Changer.TransDate;
        end;
        
        if (Changer.PauseMonths>0) then begin
          pausestartmonths = MonthDiff(CredManr.FirstInvDate,Changer.TransDate);
          if (GetDay(Changer.TransDate)!=GetDay(CredManr.FirstInvDate)) then begin
            pausestartmonths = prolongstartmonths + 1;
          end;
          pausemonths = Changer.PauseMonths;
          pausefrom = Changer.TransDate;
          waspausedf = true;
          pauseuntil = AddMonth(Changer.TransDate,Changer.PauseMonths-1);
          usemonths = months - pausestartmonths - pausemonths;
          usesum = GetBalanceOnDate(CredManPayPlanr,Changer.TransDate);
        end;
      end;
    end;
  end;

  return;
end;

function Boolean TotalsDifferTooMuch(val v1,val v2,var val diff,record CredManVc CredManr,Integer usemonths)
begin
  Boolean res;
  val origdiff,limit,tmpval;
  origdiff = diff;

  diff = v1-v2;//2nd last - 
  limit = GetAnnuityDiffLimit(usemonths);
  if (AbsoluteVal(diff)>limit) then begin
    res = true;
    diff = CalculateAnnuityDiff(CredManr,diff,usemonths);
  end else begin
    diff = 0;
  end;
  diff = origdiff + diff;
  
  TotalsDifferTooMuch = res;
  return;
end;

function Boolean ShouldRecalculateAnnuitySchedule(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,Integer usemonths,var val diff)
begin
  record CredManSetBlock CredManSetb;
  record SMVc SMr;
  row SMVc lastSMrw,lastSM2rw;
  Boolean res;
  Integer rwcnt,tmonthdiff;
  record CMApplicationSetBlock CMb;
  
  BlockLoad(CMb);

  if (true) then begin//GetDaysInMonth(CMb,CredManr)==1
    BlockLoad(CredManSetb);
    BuildCredManInfoMatrix(CredManr,CredManPayPlanr,CredManSetb,SMr);
    rwcnt = MatRowCnt(SMr);
    if (CredManr.LastMonthPrinc>0 and CredManr.MaxMonthlyPayment==0) then begin
      MatRowGet(SMr,rwcnt-2,lastSMrw);
      MatRowGet(SMr,rwcnt-3,lastSM2rw);
      tmonthdiff = 1;
    end else begin  
      MatRowGet(SMr,rwcnt-1,lastSMrw);
      MatRowGet(SMr,rwcnt-2,lastSM2rw);
    end;
    if (blank(lastSM2rw.ExtraComment)) then begin
      if (TotalsDifferTooMuch(lastSM2rw.ToRateB2,lastSMrw.ToRateB2,diff,CredManr,usemonths-tmonthdiff)) then begin//funny name :)
        res = true;
      end;
    end;
  end;
  ShouldRecalculateAnnuitySchedule = res;
  return;
end;

procedure LoadAgreementChangesMonthly(record CredManVc CredManr,Date invdat,var val refinfees,var integer futfeesmonths,var boolean foundf,var date chdate)
begin
  Date sd,ed;
  record CredManChangeVc Changer;
  Boolean TrHs;
  record CredManTypeVc CMTr;
    
  sd = AddMonth(invdat,-1);
  ed = invdat;
    
  Changer.CredManNr = CredManr.SerNr;
  Changer.TransDate = sd;
  TrHs = true;
  
  while (LoopKey("CredManDate",Changer,2,TrHs)) begin
    if (CredManr.SerNr!=Changer.CredManNr or Changer.TransDate>ed) then begin
      TrHs = false;
    end else begin
      if (Changer.OKFlag==1) then begin
        if(nonblank(Changer.NewType))then begin// Edit ************************** BPI Ukraine - KramarAlexandr - 03, 08 12 2021 y. at 10:46:12 AM
          CredManr.Type = Changer.NewType;
          CMTr.Code = CredManr.Type;
          if(readfirstmain(CMTr,1,true))then begin
            CredManr.InstalmentType = CMTr.InstalmentType;
          end;
        end;
        
        if (nonblank(Changer.IntRate)) then begin
          CredManr.IntRate = Changer.IntRate;
          CredManr.PrincipleDelayInterest = Changer.IntRate;
          CredManr.AnnualRate = Changer.AnnualRate;
        end;
        if (Changer.OverduePercentage!=0) then begin
          CredManr.OverduePercentage = Changer.OverduePercentage;
        end;
        if (Changer.MonthlyPaymentDay>0) then begin
          CredManr.MonthlyPaymentDay = Changer.MonthlyPaymentDay;
        end;
        
        refinfees = Changer.FutureFees;
        futfeesmonths = Changer.AddedFeesMonths;
        if(Changer.IntRate!=blankval or Changer.AddValue!=0)then begin
          foundf = true;
          chdate = Changer.TransDate;
        end;
      end;
    end;
  end;  
  
  return;
end;

function Boolean StartProlong(record CredManVc CredManr,Date frdate,Date todate,var Integer months,var Integer usemonths)
begin
  record CredManChangeVc Changer;
  Boolean TrHs;
  Boolean res;
  Integer prolongstartmonths;

  Changer.CredManNr = CredManr.SerNr;
  Changer.TransDate = frdate;
  TrHs = true;
  while (LoopKey("CredManDate",Changer,2,TrHs)) begin
    if (CredManr.SerNr!=Changer.CredManNr or Changer.TransDate>todate) then begin
      TrHs = false;
    end else begin
      if (Changer.OKFlag==1) then begin
        if (Changer.ProlongMonths>0) then begin
          prolongstartmonths = MonthDiff(CredManr.FirstInvDate,Changer.TransDate);
          months = months + Changer.ProlongMonths;
          usemonths = months - prolongstartmonths;
          res = true;
        end;
      end;
    end;
  end;


  StartProlong = res;
  return;
end;

function Boolean StartPause(record CredManVc CredManr,Date invdat,var Integer usemonths,var Date pausefrom,var Date pauseuntil,var Integer pausemonths)
begin
  Date sd,ed;
  record CredManChangeVc Changer;
  Boolean TrHs;
  Boolean res;
  Integer pausestartmonths;

  sd = AddDay(AddMonth(invdat,-1),1);
  ed = invdat;
  
  Changer.CredManNr = CredManr.SerNr;
  Changer.TransDate = sd;
  TrHs = true;
  while (LoopKey("CredManDate",Changer,2,TrHs)) begin
    if (CredManr.SerNr!=Changer.CredManNr or Changer.TransDate>ed) then begin
      TrHs = false;
    end else begin
      if (Changer.OKFlag==1) then begin
        if (Changer.PauseMonths>0) then begin
          pausestartmonths = MonthDiff(CredManr.FirstInvDate,Changer.TransDate);
          pausemonths = Changer.PauseMonths;
          pausefrom = Changer.TransDate;
          pauseuntil = AddMonth(Changer.TransDate,Changer.PauseMonths-1);
          res = true;
        end;
      end;
    end;
  end;

  StartPause = res;
  return;
end;

function val GetBalloonInterest(record CredManVc CredManr,record CredManSetBlock CredManSetb,Integer int_type)
begin
  record CredManPayPlanVc CredManPayPlanr;
  row CredManPayPlanVc CredManPayPlanrw;
  val res;
  record CredManVc inCredManr;
  Integer i,rwcnt;

  RecordCopy(inCredManr,CredManr);
  //inCredManr.SerNr = -1;
  inCredManr.InstalmentType = 1;
  if (int_type==2) then begin
    inCredManr.InstalmentType = 3;
  end;
  BuildCredManPayPlanCust(inCredManr,CredManPayPlanr,CredManSetb,true,true);
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.PlanType==kEventTypeCalcInterest) then begin
      res = res + CredManPayPlanrw.Sum;
    end;
  end;

  GetBalloonInterest = res;
  return;
end;


procedure UpdateAgreementBalance(var record CredManPayPlanVc CredManPayPlanr,var record CredManVc CredManr,var val calcbal,var val acumint,Date frdate,Date todate,var val usesum,var Integer usemonths,var Integer months,Integer int_type,var val addbal,var Date payoutdate,Integer curmonth)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  val monthlypayment;
  Integer reducemonths;
  val prevusesum,payval;
  
  prevusesum = usesum;

  addbal = 0;
//  if (int_type==2) then begin
    TrHs = true;
    CredHistr.TransDate = frdate;
    while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,TrHs)) begin
      if (CredHistr.TransDate>todate) then begin
        TrHs = false;
      end else begin
        if (CredHistr.RecordType==5) then begin//payment
          calcbal = calcbal + CredHistr.Sum;
          AddCredPayPlanLine(CredManPayPlanr,CredHistr.TransDate,"","",kEventTypePayout,CredHistr.Sum,0,acumint,calcbal,"","",CredHistr.SerNr,-1,0);
          usesum = calcbal;
          addbal = addbal + CredHistr.Sum;
          if (blank(payoutdate) and CredHistr.TransDate<CredManr.FirstInvDate) then begin
            payoutdate = CredHistr.TransDate;
          end;
          if (curmonth>CredManr.PrincipleDelayMonths) then begin
            usemonths = months - curmonth;
          end;

        end;
      end;
    end;
//  end;
  
//Add partial buyouts in period
  ResetLoop(CredHistr);
  RecordClear(CredHistr);
  TrHs = true;
  CredHistr.TransDate = frdate;
  while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,TrHs)) begin
    if (CredHistr.TransDate>todate) then begin
      TrHs = false;
    end else begin
      if (IsPartialBuyoutType(CredHistr.ChargeType)) then begin//partial buyout
        AddCredPayPlanLine(CredManPayPlanr,CredHistr.TransDate,"","",kEventTypePartialBuyout,CredHistr.Sum,0,acumint,calcbal,"","",CredHistr.SerNr,-1,0);
        usesum = calcbal;
        if (PartiaBuyoutShortensPeriod) then begin
          CredManr.MaxMonthlyPrinciple = GetMaxMonthlyPaymentForPartialBuyout(CredManPayPlanr,CredManr,CredHistr.Sum,frdate,usemonths, prevusesum,reducemonths,curmonth);
          if (curmonth<CredManr.PrincipleDelayMonths) then begin
            usemonths = months - CredManr.PrincipleDelayMonths - reducemonths;
          end else begin
            usemonths = months - curmonth - reducemonths;
          end;
        end;
      end;
    end;
  end;

  return;
end;


global
procedure BuildCredManPayPlanCust2(record CredManVc inCredManr,var record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,Boolean withactuals,Boolean recalculatef,Boolean planf)
begin
  Integer calculatedmonths,months;
  val acumint,calcbal;
  Integer i,monthtype,monthtype2,monthtype3,delaymonths;
  Date invdat,frdat,todat,int_frdat,int_todat,int_invdat;
  Boolean firstinvf,setdelf;
  Integer usemonths,curmonth,prolongstartmonths,basemonths,pausestartmonths,pausemonths,sendcurmonth,substractmonths;
  val usesum,buyoutamount,pausebal,prolongbal;
  Boolean prolongf,pausef;
  record CMInvoicingBlock CIb;
  Boolean waspausedf,ispausedf,foundf;
  Date pausefrom,pauseuntil;
  val annuity_diff,vblank;
  Integer tries,int_type,futfeesmonths;
  record CredManVc tCredManr;
  val totint,addbal,int_calcbal;
  Date payoutdate,chdate;
  val futfees,oneperfees,lastdelta;
  record CMBuyOutBlock CMBuyOutb;
  
  blockload(CMBuyOutb);
  

/*should we calculate VAT here?
  if CredManr.VATSum > 0 and nonblank(CredManr.VATAddMonths) then begin
    GetMonthlyVatVector(CredManr.VATSum, CredManr.VATAddMonths, vatPayments);
  end;
*/
logtext(0,"BuildCredManPayPlanCust start");
  RecordCopy(tCredManr,inCredManr);
  BlockLoad(CIb);
LCalcSchedule:;
  RecordCopy(inCredManr,tCredManr);
  months = inCredManr.InstalmentMonths;
  acumint = 0;
  int_type = GetInterestPaymentType(inCredManr);
  if (int_type==2) then begin
    calcbal = 0;
  end else begin
    calcbal = inCredManr.InvSum4;
    usesum = GetAgreementAmount(inCredManr);
  end;
  buyoutamount = 0;
  pausebal = 0;
  waspausedf = false; pausefrom = ""; pauseuntil = ""; pausemonths = 0; pausestartmonths = 0;
  prolongf = false; prolongstartmonths = 0;prolongbal = 0;
  calculatedmonths = 0;
  usemonths = 0;
  delaymonths = inCredManr.PrincipleDelayMonths;

  if (withactuals) then begin
    AddActualsToPlan(inCredManr,CredManPayPlanr,calculatedmonths,acumint,calcbal,firstinvf,CredManSetb,months,buyoutamount,pausebal,prolongbal,int_type,usesum,usemonths,planf);
  end;
  if (tCredManr.Status==5 or planf==false) then begin//if cancelled or we just want to get the actuals
    goto LBuildCredManPayPlanCust;
  end;
  if (usemonths==0) then begin
    usemonths = months;
    usemonths = usemonths - delaymonths;
  end;
  if (buyoutamount>0) then begin
    //usesum = usesum - buyoutamount;
  end;

  basemonths = usemonths;
  substractmonths = delaymonths;
  LoadAgreementChangesToDate(inCredManr,CredManPayPlanr,calculatedmonths,prolongf,prolongstartmonths,prolongbal,months,usemonths,usesum,pausestartmonths,waspausedf,pausefrom,pauseuntil,pausemonths,futfees,futfeesmonths,foundf,chdate);
  for(i=calculatedmonths;i<months;i=i+1) begin
    if (calcbal>0 or int_type==2) then begin
      
      CalcCredManCurrentPeriod(inCredManr,CIb,i-1,payoutdate,frdat,todat,int_frdat,int_todat,invdat,int_invdat); //sets dates, frdat, todat and invdat
      
      LoadAgreementChangesMonthly(inCredManr,invdat,futfees,futfeesmonths,foundf,chdate);
lStepBack:;

      if(CMBuyOutb.UseRedesignedByuOut==1)then begin
        if(futfees!=0)then begin
          oneperfees = round(futfees/futfeesmonths,defaultcurroundoff);
          lastdelta = futfees - oneperfees * futfeesmonths;          
          futfees = blankval;
        end;
        if(oneperfees!=0 and lastdelta!=0 and i==months-1)then begin
          oneperfees = oneperfees + lastdelta;
        end;

        if(foundf)then begin
          //frdat = chdate;
          //int_frdat = chdate;
        end;
      end;
      
      UpdateAgreementBalance(CredManPayPlanr,inCredManr,calcbal,acumint,frdat,todat,usesum,usemonths,months,int_type,addbal,payoutdate,i);
      if (nonblank(payoutdate)) then begin
        frdat = payoutdate;
        int_todat = payoutdate;
      end;
      int_calcbal = calcbal - addbal;
      if (GetDay(invdat)!=inCredManr.MonthlyPaymentDay) then begin
        CalcCredManCurrentPeriod(inCredManr,CIb,i-1,payoutdate,frdat,todat,int_frdat,int_todat,invdat,int_invdat); //sets dates,   frdat, todat and invdat
      end;
      
      /*if(CMBuyOutb.UseRedesignedByuOut==1)then begin
        if(foundf)then begin
          frdat = chdate;
          int_frdat = chdate;
          foundf = false;
        end;
      end;*/


      if (i==0 and firstinvf==false and inCredManr.InstalmentType!=4) then begin//Not for factoring
        AddInitialInvoice(inCredManr,CredManPayPlanr,CredManSetb,acumint,calcbal,"","");
      end;
//      logtext(0,"l1 " & invdat & ":" & i & ":" & curmonth & ":" & usemonths & ":" & months & ":" & usesum & ":" & prolongstartmonths);
      if (StartProlong(InCredManr,frdat,todat,months,usemonths)) then begin
        prolongstartmonths = i;
        usesum = calcbal;
        prolongf = true;
        substractmonths = prolongstartmonths;
      end;
//      logtext(0,"l2 " & i & ":" & curmonth & ":" & usemonths & ":" & months & ":" & usesum & ":" & prolongstartmonths);
      if (StartPause(InCredManr,invdat,usemonths,pausefrom,pauseuntil,pausemonths)) then begin
        pausestartmonths = i;        
        usemonths = months - i - pausemonths;
        waspausedf = true;
        usesum = calcbal;
        substractmonths = pausestartmonths;
      end;
      if (waspausedf) then begin
        ispausedf = DateInRange(invdat,pausefrom,pauseuntil);
      end;
      curmonth = i;
      sendcurmonth = curmonth;
      //if (prolongf) then begin
        sendcurmonth = sendcurmonth - substractmonths; 
      //end;
//      logtext(0,"l3 " & i & ":" & curmonth &  ":" & sendcurmonth & ":" & usemonths & ":" & months & ":" & usesum & ":" & prolongstartmonths & ":" & pausestartmonths & ":" & ispausedf & ":" & invdat);
      if (waspausedf and ispausedf==false) then begin
        sendcurmonth = sendcurmonth - pausemonths;
      end;
      monthtype = GetMonthType(i,months);
//      logtext(0,"l4 " & i & ":" & curmonth &  ":" & sendcurmonth  & ":" & usemonths & ":" & months & ":" & usesum & ":" & monthtype);
      switch (inCredManr.InstalmentType) begin
        case 0://annuity
          monthtype2 = monthtype;
          monthtype3 = monthtype;
          if (monthtype2==kMonthTypeLast) then begin
            monthtype2 = kMonthTypeRegular;
          end;
          if (monthtype3!=kMonthTypeFirst) then begin
            monthtype3 = kMonthTypeLast;
          end;
          AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype2,invdat,acumint,calcbal,frdat,todat,-1,false);
          if (curmonth>=inCredManr.PrincipleDelayMonths and ispausedf==false) then begin
            AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,int_calcbal,int_frdat,int_todat,-1,false);
            AddExtraInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,addbal,int_frdat,int_todat,-1,false,int_type);
            AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,2,monthtype,invdat,acumint,calcbal,frdat,todat,sendcurmonth,usesum,usemonths,annuity_diff);
          end else begin
            if (ispausedf) then begin
              AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,int_calcbal,int_frdat,int_todat,-1,false);
           end else begin
              AddInterestDelay(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,int_calcbal,int_frdat,int_todat,-1);
            end;
            AddExtraInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat, acumint,addbal,int_frdat,int_todat,-1,false,int_type);
          end;
          AddLateFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal);
          if(CMBuyOutb.UseRedesignedByuOut==1)then begin
            AddRefFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal,oneperfees);
          end;
        case 1://linear with delay
          monthtype2 = monthtype;
          if (monthtype2==kMonthTypeLast) then begin
            monthtype2 = kMonthTypeRegular;
          end;
          AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype2,invdat,acumint,calcbal,frdat,todat,-1,false);
          if (curmonth>=inCredManr.PrincipleDelayMonths and ispausedf==false) then begin
            AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype2,int_invdat,acumint,int_calcbal,int_frdat,int_todat,-1,false);
            AddExtraInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,addbal,int_frdat,int_todat,-1,false,int_type);
            AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,1,monthtype,invdat,acumint,calcbal,frdat,todat,sendcurmonth,usesum,usemonths,vblank);
          end else begin
            if (ispausedf) then begin
              AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype2,int_invdat,acumint,int_calcbal,int_frdat,int_todat,-1,false);
            end else begin
              AddInterestDelay(inCredManr,CredManPayPlanr,CredManSetb,monthtype2,int_invdat,acumint,int_calcbal,int_frdat,int_todat,-1);
            end;
            AddExtraInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,addbal,int_frdat,int_todat,-1,false,int_type);
          end;
          AddLateFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal);
          if(CMBuyOutb.UseRedesignedByuOut==1)then begin
            AddRefFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal,oneperfees);
          end;
        case 3://Bullet
          AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype,invdat,acumint,calcbal,frdat,todat,-1,false);
          AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype,int_invdat,acumint,int_calcbal,int_frdat,int_todat,-1,false);
          AddExtraInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,addbal,int_frdat,int_todat,-1,false,int_type);
          if (int_type==2) then begin
            AddUnusedInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,int_calcbal,int_frdat,int_todat,-1,false);
          end;
          if (i==months-1) then begin
            AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,0,monthtype,invdat,acumint,calcbal,frdat,todat,curmonth,usesum,usemonths,vblank)
          end;
          AddLateFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal);
          if(CMBuyOutb.UseRedesignedByuOut==1)then begin  
            AddRefFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal,oneperfees);
          end;
        case 4://Factoring
          AddFactoringInvoices(inCredManr,CredManPayPlanr,CredManSetb,CurrentDate,acumint,calcbal,frdat,todat)
        case 5://Payment guarantee

        case 6://Balloon
          AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype,invdat,acumint,calcbal,frdat,todat,-1,false);
          if (i==months-1) then begin
            totint = GetBalloonInterest(inCredManr,CredManSetb,int_type);
            AddCredPayPlanLine(CredManPayPlanr,invdat,CredManSetb.RateItem,"",kEventTypeCalcInterest,totint,0,acumint,calcbal,frdat,todat,-1,-1,0);
            AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,1,monthtype,invdat,acumint,calcbal,frdat,todat,curmonth,usesum,usemonths,vblank);
          end;
          AddLateFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal);
          if(CMBuyOutb.UseRedesignedByuOut==1)then begin  
            AddRefFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal,oneperfees);
          end;
      end;
      
      AddExtraDeposit(inCredManr,CredManPayPlanr,CredManSetb,invdat,acumint,calcbal,frdat,todat,i+1);
      if (nonblank(inCredManr.CancelDate) and invdat==inCredManr.CancelDate) then begin
        goto LBuildCredManPayPlanCust;
      end;
      if(CMBuyOutb.UseRedesignedByuOut==1)then begin
        if(foundf)then begin
          foundf = false;
          //i=i+1;
          //goto lStepBack;
        end;
      end;
      
      //if (i==0) then begin
      //  AddDeposit(inCredManr,CredManPayPlanr,CredManSetb,invdat,acumint,calcbal,frdat,todat);
      //end;
    end;
  end;

logtext(0,"BuildCredManPayPlanCust end1 retry=" & tries);
  if (recalculatef) then begin
    if (inCredManr.InstalmentType==0 and tries<25 and inCredManr.MaxMonthlyPayment==0) then begin//annuity
      if (ShouldRecalculateAnnuitySchedule(inCredManr,CredManPayPlanr,usemonths,annuity_diff)) then begin
        RecordClear(CredManPayPlanr);
        tries = tries + 1;
        goto LCalcSchedule;
      end;
    end;
  end;

logtext(0,"BuildCredManPayPlanCust end2");

LBuildCredManPayPlanCust:;
  SortRows(CredManPayPlanr,"SortString",true);
  RecordCopy(inCredManr,tCredManr);
  return;
end;

global
procedure BuildCredManPayPlanCust(record CredManVc inCredManr,var record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,Boolean withactuals,Boolean recalculatef)
begin

  BuildCredManPayPlanCust2(inCredManr,CredManPayPlanr,CredManSetb,withactuals,recalculatef,true);

  return;
end;

global
function val GetMonthlyPaymentAmount(record CredManVc inCredManr,Integer type)
begin
  record CredManSetBlock CredManSetb;
  record CredManPayPlanVc CredManPayPlanr;
  row CredManPayPlanVc CredManPayPlanrw;
  val acumint,res,bal,tmp;
  Date td;
  Integer i,rwcnt;
  val diff;

  BlockLoad(CredManSetb);
  td = inCredManr.startDate;

  if (BitAnd(type,2)) then begin
    bal = inCredManr.InvSum4-inCredManr.DepositSum;
    if (nonblank(inCredManr.PrincipleDelayMonths)) then begin
      AddInterestDelay(inCredManr,CredManPayPlanr,CredManSetb,kMonthTypeRegular,td,acumint,bal,"","",-1);
    end else begin
      AddInterest(inCredManr,CredManPayPlanr,CredManSetb,kMonthTypeRegular,td,acumint,bal,"","",-1,false);
    end;
  end;
  if (BitAnd(type,4)) then begin
    bal = inCredManr.InvSum4-inCredManr.DepositSum;
    AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,kMonthTypeRegular,td,acumint,bal,"","",-1,false);
  end;
  if (BitAnd(type,8)) then begin
    bal = inCredManr.InvSum4-inCredManr.DepositSum;
    AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,1,kMonthTypeRegular,td,acumint,bal,"","",1,inCredManr.InvSum4-inCredManr.DepositSum,inCredManr.InstalmentMonths,diff);//first month
    if (inCredManr.MaxMonthlyPayment>0) then begin
      tmp = GetMonthlyPaymentAmount(inCredManr,6);
      MatRowGet(CredManPayPlanr,MatRowCnt(CredManPayPlanr)-1,CredManPayPlanrw);
      CredManPayPlanrw.Sum = inCredManr.MaxMonthlyPayment - tmp;
      MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr)-1,CredManPayPlanrw);
    end;
  end;

  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    res = res + CredManPayPlanrw.Sum;
  end;

  GetMonthlyPaymentAmount = res;
  return;
end;

global
function string 255 GetPlanTypeTextCust(Integer plantype)
begin
  string 255 res;
  
  switch (plantype) begin
    case 0: res = "Should not happen";
    case 1: res = "Suggested Instalment";
    case 2: res = "Suggested Interest";
    case 3: res = "Suggested Deposit";
    case 4: res = "Suggested Fee";
    case 5: res = "Invoiced Instalment";
    case 6: res = "Invoiced Interest";
    case 7: res = "Invoiced Deposit";
    case 8: res = "Invoiced Fee";
    case 9: res = "Invoiced Late Fees";
    case 10: res = "Paid Instalment";
    case 11: res = "Paid Interest";
    case 12: res = "Paid Deposit";
    case 13: res = "Paid Fee";
  end;
  GetPlanTypeTextCust = res;
  return;
end;
