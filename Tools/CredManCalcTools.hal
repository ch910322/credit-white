external inner function val GetCredManRate(Integer,string,val,Date);
external inner function LongInt DateDiff(Date,Date);
external inner function roundmode SetRoundModeD(Integer);
external inner function LongInt MonthDiff(Date,Date);
external procedure GetCredManOverdueInvoices(record CredManVc,record CredManSetBlock,Date,Date,var Integer,var val,var array string,Boolean);

enum begin
  kEventTypeNone = 0,
  kEventTypeCalcInstalment = 1,
  kEventTypeCalcInterest = 2,
  kEventTypeCalcDeposit = 3,
  kEventTypeCalcFees = 4,
  kEventTypeIssueInstalment = 5,
  kEventTypeIssueInterest = 6,
  kEventTypeIssueDeposit = 7,
  kEventTypeIssueFees = 8,
  kEventTypeIssueLateFees = 9,
  kEventTypePaidInterest = 13,
  kEventTypePaidInstalment = 14,
  kEventTypePaidDeposit = 15,
  kEventTypePaidFees = 16,
  kEventTypePartialBuyout = 17,
end;

enum begin
  kPlannedFeesMonthly = 0,
  kPlannedFeesOneTime = 1
end;

//This is used to get correct amounts (fees and interest) for first and last months (as they need to be different)
enum begin
  kMonthTypeFirst = 0,
  kMonthTypeRegular = 1,
  kMonthTypeLast = 2
end;

procedure CalcCredManCurrentPeriod(record CredManVc CredManr,record CMInvoicingBlock CIb,Integer paymentnr,var Date sdp,var Date edp,var Date int_sdp,var Date int_edp,var Date invd,var Date int_invdat)
begin
  record PDVc PDr;
  Date bd;

  if (paymentnr==-1) then begin
    sdp = CredManr.startDate;
    edp = CredManr.FirstInvDate;
    invd = CredManr.FirstInvDate;
  end else begin
    sdp = AddMonth(CredManr.startDate,paymentnr);
    if (nonblankdate(CredManr.FirstInvDate)) then begin
      sdp = AddMonth(CredManr.FirstInvDate,paymentnr); //  - 1
    end;
    sdp.Day = CredManr.MonthlyPaymentDay;
    edp = AddMonth(sdp,1);
    invd = AddMonth(sdp,1);
    if (DaysInMonth(sdp.Year,sdp.Month)<sdp.Day) then begin 
      sdp.Day = DaysInMonth(sdp.Year,sdp.Month);
    end;
    sdp = AddDay(sdp,1);
  end;
  if (CIb.InvoiceDay==1) then begin
    PDr.Code = CredManr.PayDeal;
    if (ReadFirstMain(PDr,1,true)) then begin
      invd = AddDay(invd,-PDr.pdays);
    end;
  end;

  int_sdp = sdp;
  int_edp = edp;
  if (paymentnr==-1) then begin
    if (nonblank(CredManr.FirstIntDate)) then begin
      int_sdp = CredManr.FirstIntDate;
    end;
    if (CredManr.MoneyTransferDate>int_sdp) then begin
      int_sdp = CredManr.MoneyTransferDate;
    end;
  end;
  int_invdat = invd;
  if (CIb.InterestIVType>=2) then begin
    int_invdat.Day = CIb.InterestIVDay;
    if (CIb.InterestIVType==3) then begin
      int_invdat = AddMonth(int_invdat,1);
    end;
  end;

  return;
end;

function val GetAmount(record CredManVc CredManr)
begin
  val res;

  res = CredManr.InvSum4 - CredManr.DepositSum - CredManr.ExtraDepositSum;
  
  GetAmount = res;
  return;
end;

function Integer GetDaysInYear(record CMApplicationSetBlock CMb,record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  Integer res;

  res = -1;
  CMTr.Code = CredManr.Type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if (CMTr.DaysInYear>0) then begin
      res = CMTr.DaysInYear;
    end;
  end;

  if (res==-1) then begin
    res = CMb.DaysInYear;
  end;

  GetDaysInYear = res;
  return;
end;

function Integer GetDaysInMonth(record CMApplicationSetBlock CMb,record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  Integer res;

  res = -1;
  CMTr.Code = CredManr.Type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if (CMTr.DaysInMonth>0) then begin
      res = CMTr.DaysInMonth-1;
    end;
  end;

  if (res==-1) then begin
    res = CMb.DaysInMonth;
  end;

  GetDaysInMonth = res;
  return;
end;

global
function val GetRateAmount(record CredManVc CredManr,val trate,Integer monthtypef,Date frdate,Date todate,val calcbal,Boolean ignoref,Boolean fixeddaysf)
begin
  record CMApplicationSetBlock CMb;
  val days,res;
  Integer months;
  val rate;

  rate = trate;
  if (CredManr.AnnualRate==1 and ignoref==false) then begin
    rate = rate/12;
  end;
  days = DateDiff(todate,frdate);
  BlockLoad(CMb);
  switch (monthtypef) begin
    case kMonthTypeFirst:
      months = MonthDiff(frdate,todate);
      if (frdate.Day!=todate.Day) then begin
        months = months - 1;//MonthDiff returns +1 if there are extra days
      end;
      if (months>0 and (fixeddaysf or GetDaysInMonth(CMb,CredManr)==0)) then begin
        days = DateDiff(todate,AddMonth(frdate,months));
        res = GetAmount(CredManr)*(rate/100)*months;
        res = res + (GetAmount(CredManr)*(rate/100)*12/GetDaysInYear(CMb,CredManr)*days);
      end else begin
        res = GetAmount(CredManr)*(rate/100)*12/GetDaysInYear(CMb,CredManr)*days;
      end;
    case kMonthTypeRegular:
      if (fixeddaysf or GetDaysInMonth(CMb,CredManr)==0) then begin
        res = GetAmount(CredManr)*(rate/100);
      end else begin
        res = GetAmount(CredManr)*(rate/100)*12/GetDaysInYear(CMb,CredManr)*days;
      end;   
    case kMonthTypeLast:
      if (fixeddaysf or GetDaysInMonth(CMb,CredManr)==0) then begin
        res = calcbal*(rate/100);    
      end else begin
        res = calcbal*(rate/100)*12/GetDaysInYear(CMb,CredManr)*days;
      end;
  end;

  GetRateAmount = res;
  return;
end;

function Boolean MonthlyChargeType(Integer chargetype)
begin
  Boolean res;

  if (chargetype==1 or chargetype==3) then begin
    res = true;
  end;
  
  MonthlyChargeType = res;
  return;
end;

function Boolean CalculatedChargeType(Integer chargetype)
begin
  Boolean res;

  if (chargetype==2 or chargetype==3) then begin
    res = true;
  end;
  
  CalculatedChargeType = res;
  return;
end;

function Boolean TypeAffectsBalance(Integer type)
begin
  Boolean res;

  switch (type) begin
    case kEventTypeCalcInstalment:  res = true;
    case kEventTypeIssueInstalment: res = true;
    case kEventTypeIssueDeposit:    res = true;
    case kEventTypeCalcDeposit:     res = true;
    case kEventTypePartialBuyout:   res = true;
  end;
  
  TypeAffectsBalance = res;
  return;
end;

function Boolean TypeAffectsInterest(Integer type)
begin
  Boolean res;

  switch (type) begin
    case kEventTypeCalcInterest:  res = true;
    case kEventTypeIssueInterest: res = true;
  end;
  
  TypeAffectsInterest = res;
  return;
end;

procedure AddCredPayPlanLine(record CredManPayPlanVc CredManPayPlanr,Date transdate,string item,string itemname,Integer type,val sum,val reb,var val acumint,var val calcbal,Date frdate,Date todate,Longint histnr,Longint factinv,val openamount)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  val v;
  
  v = Round(sum,SetRoundModeD(2));//round(sum,SetRoundModeD(rounding));//CredManr.DepositSum,CredManSetb.DepositRoundOff
  if (v!=0) then begin
    CredManPayPlanrw.ArtCode = item;
    CredManPayPlanrw.Spec = itemname;
    CredManPayPlanrw.TransDate = transdate;
    CredManPayPlanrw.PlanType = type;
    CredManPayPlanrw.Sum = v;
    CredManPayPlanrw.Reb = reb;
    CredManPayPlanrw.FromDate = frdate;
    CredManPayPlanrw.ToDate = todate;
    CredManPayPlanrw.IssuedNr = histnr;
    CredManPayPlanrw.FactoringInvoice = factinv;
    if (TypeAffectsInterest(type)) then begin
      CredManPayPlanrw.AcumulatedInt = acumint + v;
    end else begin
      CredManPayPlanrw.AcumulatedInt = acumint;
    end;
    if (TypeAffectsBalance(type)) then begin
      CredManPayPlanrw.Bal = calcbal - v;
    end else begin
      CredManPayPlanrw.Bal = calcbal;
    end;
    CredManPayPlanrw.OpenAmount = openamount;
    MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr),CredManPayPlanrw);
    acumint = CredManPayPlanrw.AcumulatedInt;
    calcbal = CredManPayPlanrw.Bal;
  end;

  return;
end;

global
procedure AddInterest(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Longint factinv,Boolean overridef)
begin
  Integer sendmonthtypef;
  
  if (nonblank(frdate)) then begin
    sendmonthtypef = monthtypef;
    if (CredManr.ChargeMethod==1 and overridef==false) then begin
      sendmonthtypef = kMonthTypeLast;
    end;
    AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.RateItem,"",kEventTypeCalcInterest,GetRateAmount(CredManr,CredManr.IntRate,sendmonthtypef,frdate,todate,calcbal,false,false),0,acumint,calcbal,frdate,todate,-1,factinv,0);
  end;

  return;
end;

global
procedure AddInterestDelay(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Longint factinv)
begin
  Integer sendmonthtypef;

  sendmonthtypef = monthtypef;
  if (CredManr.ChargeMethod==1 and monthtypef!=kMonthTypeFirst) then begin
    sendmonthtypef = kMonthTypeLast;
  end;
  AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.RateItem,"",kEventTypeCalcInterest,GetRateAmount(CredManr,CredManr.PrincipleDelayInterest,sendmonthtypef,frdate,todate,calcbal,false,false),0,acumint,calcbal,frdate,todate,-1,factinv,0);

  return;
end;

function val AdjustFees(val sum,val minsum,val maxsum)
begin
  val res;

  res = sum;
  if (minsum>0 and res<minsum) then begin
    res = minsum;
  end;
  if (maxsum>0 and res>maxsum) then begin
    res = maxsum;
  end;

  AdjustFees = res;
  return;
end;

global
procedure AddPlannedFees(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer type,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Longint factinv)
begin
  Integer i,rwcnt;
  row CredManVc CredManrw;
  val sum;

  rwcnt = MatRowCnt(CredManr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManr,i,CredManrw);
    if ((type==kPlannedFeesMonthly and MonthlyChargeType(CredManrw.ChargeType)) or 
        (type==kPlannedFeesOneTime and MonthlyChargeType(CredManrw.ChargeType)==false)) then begin
      if (CalculatedChargeType(CredManrw.ChargeType)) then begin
        sum = AdjustFees(GetRateAmount(CredManr,CredManrw.vRebate,monthtypef,frdate,todate,calcbal,true,true),CredManrw.MinSum,CredManrw.MaxSum);
        AddCredPayPlanLine(CredManPayPlanr,invdate,CredManrw.ArtCode,"",kEventTypeCalcFees,sum,0,acumint,calcbal,frdate,todate,-1,factinv,0);
      end else begin
        sum = AdjustFees(CredManrw.Price,CredManrw.MinSum,CredManrw.MaxSum);
        AddCredPayPlanLine(CredManPayPlanr,invdate,CredManrw.ArtCode,"",kEventTypeCalcFees,sum,CredManrw.vRebate,acumint,calcbal,frdate,todate,-1,factinv,0);
      end;
    end;
  end;
  
  return;
end;

procedure AddDeposit(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  
  AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.DepositItem,"",kEventTypeCalcInstalment,CredManr.DepositSum,0,acumint,calcbal,frdate,todate,-1,-1,0);//kEventTypeCalcDeposit>>kEventTypeCalcInstalment

  return;
end;

function Integer GetMonthCount(string tstr)
begin
  Integer res;
  Longint pos;
  string 255 tmp;
  
  while (GetNextSubstring(tstr,pos,",",tmp)) begin
    res = res + 1;
  end;

  GetMonthCount = res;
  return;
end;

procedure AddExtraDeposit(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Integer month)
begin
  val extradep;
  Integer totmonths;
  
  if (CredManr.ExtraDepositSum>0) then begin
    if (nonblank(CredManr.ExtraDepositMonths) and SetInSet(month,CredManr.ExtraDepositMonths)) then begin
      totmonths = GetMonthCount(CredManr.ExtraDepositMonths);
      extradep = CredManr.ExtraDepositSum/totmonths;
      AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.DepositItem,"",kEventTypeCalcInstalment,extradep,0,acumint,calcbal,frdate,todate,-1,-1,0);//kEventTypeCalcDeposit>>kEventTypeCalcInstalment
    end;
  end;
  return;
end;


global
function val FIN_PMT(val monthly_rate, integer payments, val total_sum)
begin
  val t, t2;
  t = monthly_rate * (total_sum * power(1 + monthly_rate, payments)) / (power(1 + monthly_rate, payments) - 1);

  FIN_PMT = t;
  return;
end;

function val FIN_PPMT(val monthly_rate, integer payments, val total_sum, integer payment_nr)
begin
  val res, t, c;

  c = Round(-FIN_PMT(monthly_rate, payments, total_sum),SetRoundModeD(2));//monthly payment. 
  res = c + (c * (power(1 + monthly_rate, payment_nr-1) - 1) / monthly_rate + total_sum * power(1 + monthly_rate, payment_nr-1)) * monthly_rate;

  FIN_PPMT = -res;
  return;
end;

function val GetCurrentMonthPayment(record CredManPayPlanVc CredManPayPlanr,Date invdate,val sum)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  val res;
  
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=rwcnt-1;i>0;i=i-1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.TransDate==invdate) then begin
      res = res + CredManPayPlanrw.Sum;
    end else begin
      i = -1;
    end;
  end;
  res = res + sum;

  GetCurrentMonthPayment = res;
  return;
end;

function Boolean LinearInstalment(Integer type)
begin
  Boolean res;

  switch (type) begin
    case 1: res = true;
    case 2: res = true;
    case 6: res = true;
  end;

  LinearInstalment = res;
  return;
end;

procedure FixupInstalmentAmount(var val sum,val calcbal)
begin
  
  if (sum>calcbal) then begin
    sum = calcbal;
  end;

  return;
end;

function val GetActualDaysRate(record CMApplicationSetBlock CMAb,record CredManVc CredManr,val rate,Date frdate,Date todate)
begin
  val res,tmp;
  Integer days;

  days = DateDiff(todate,frdate);
  res = rate*12/GetDaysInYear(CMAb,CredManr)*days;
//  logtext(0,"GetActualDaysRate " & res & ":" & frdate & ":" & todate & ":" & days);
  
  GetActualDaysRate = res;
  return;
end;

procedure AddInstalment(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,Integer type,Integer monthtypef,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate,Integer month,val usesum,Integer usemonths)
begin
  val sum,curpayment,rate;
  Integer months;
  record CMApplicationSetBlock CMAb;
  
  switch (type) begin
    case 0:
      AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,CredManr.InvSum4,0,acumint,calcbal,frdate,todate,-1,-1,0);
    case 1:
      if (monthtypef==kMonthTypeLast) then begin
        AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,calcbal,0,acumint,calcbal,frdate,todate,-1,-1,0);
      end else begin
        //for max monthly payments we need to check the instalment amount. 
        sum = usesum/usemonths;
        if (LinearInstalment(CredManr.InstalmentType) and CredManr.MaxMonthlyPayment>0) then begin
          //get current month payment
          curpayment = GetCurrentMonthPayment(CredManPayPlanr,invdate,sum);
          if (CredManr.MaxMonthlyPayment<curpayment) then begin
            sum = CredManr.MaxMonthlyPayment-(curpayment-sum);
          end;
        end;
        FixupInstalmentAmount(sum,calcbal);
        AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,sum,0,acumint,calcbal,frdate,todate,-1,-1,0);
      end;
    case 2:
      if (monthtypef==kMonthTypeLast) then begin
        AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,calcbal,0,acumint,calcbal,frdate,todate,-1,-1,0);
      end else begin
//        logtext(0,"dd " & usemonths & ":" & usesum & ":" & (month));
        rate = CredManr.IntRate;
        if (CredManr.AnnualRate==1) then begin
          rate = rate/12;
        end;
        rate = rate/100;
        /*
        BlockLoad(CMAb);
        if (GetDaysInMonth(CMAb,CredManr)==1) then begin
          rate = GetActualDaysRate(CMAb,CredManr,rate,frdate,todate);
        end;
        */
        sum = FIN_PPMT(rate, usemonths, usesum, month+1);
        if (CredManr.MaxMonthlyPayment>0) then begin
          curpayment = GetCurrentMonthPayment(CredManPayPlanr,invdate,sum);
          if (CredManr.MaxMonthlyPayment<curpayment) then begin
            sum = CredManr.MaxMonthlyPayment-(curpayment-sum);
          end;
        end;
        FixupInstalmentAmount(sum,calcbal);
        AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,sum,0,acumint,calcbal,frdate,todate,-1,-1,0);
      end;
  end;
 return;
end;

global
procedure AddInstalmentFixed(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,val amount,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  
  AddCredPayPlanLine(CredManPayPlanr,invdate,CMb.InstalmentItem,"",kEventTypeCalcInstalment,amount,0,acumint,calcbal,frdate,todate,-1,-1,0);

  return;
end;

function Integer GetCredHistType(string artcode,Boolean paidflag)
begin
  record CredManSetBlock CMSb;
  Integer res;

  res = 0;
  BlockLoad(CMSb);
  if (artcode==CMSb.InstalmentItem) then begin
    if (paidflag) then begin
      res = kEventTypePaidInstalment;
    end else begin
      res = kEventTypeIssueInstalment;
    end;
  end else begin
    if (artcode==CMSb.RateItem) then begin
      if (paidflag) then begin
        res = kEventTypePaidInterest;
      end else begin
        res = kEventTypeIssueInterest;
      end;
    end else begin
      if (artcode==CMSb.DepositItem) then begin
        if (paidflag) then begin
          res = kEventTypePaidDeposit;
        end else begin
          res = kEventTypeIssueDeposit;
        end;
      end else begin
        if (paidflag) then begin
          res = kEventTypePaidFees;
        end else begin
          res = kEventTypeIssueFees;
        end;
      end;
    end;
  end;

  GetCredHistType = res;
  return;
end;

function Boolean IsInitialInvoice(record CredManVc CredManr,Date transdate,Longint lastrecnr,Boolean firstinvf)
begin
  Boolean res;

  if (CredManr.startDate==transdate or CredManr.FirstInvDate>transdate) then begin
    if (lastrecnr==-1 or firstinvf) then begin
      res = true;
    end;
  end;
  
  IsInitialInvoice = res;
  return;
end;

function val GetCredHistOpenAmount(record CredHistVc CredHistr)
begin
  val res,paid;
  Boolean TrHs;
  Integer type;
  record CredHistVc CredHist2r;

  type = GetCredHistType(CredHistr.ArtCode,false); 
  if (type==kEventTypeIssueInstalment) then begin
    TrHs = true;
    CredHist2r.PreviousNr = CredHistr.SerNr;
    while (LoopKey("PreviousNr",CredHist2r,1,TrHs)) begin
      if (CredHist2r.PreviousNr!=CredHistr.SerNr) then begin
        TrHs = false;
      end else begin
        paid = paid + CredHist2r.Sum;
      end;
    end;

    res = CredHistr.Sum - paid;
  end;

  GetCredHistOpenAmount = res;
  return;
end;

procedure AddActualsToPlan(record CredManVc CredManr,var record CredmanPayPlanVc CredManPayPlanr,var Integer calculatedmonths,var val acumint,var val calcbal,var Boolean firstinvf,record CredManSetBlock CredManSetb,var Integer months,var val buyoutamount,var val pausebal,var val prolongbal)
begin
  record CredHistVc CredHistr,PrevCredHistr;
  Boolean TrHs;
  Integer type;
  Longint lastrecnr;
  vector Boolean vFirstInv;
  val monthlypayment,openamount;
  Integer reducemonths;

  firstinvf = false;
  calculatedmonths = 0;
  TrHs = true;
  CredHistr.CredManNr = CredManr.SerNr;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if (CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
 //     if (CredHistr.RecordType==0) then begin
      if (CredHistr.ChargeType!=15 and CredHistr.ChargeType!=14) then begin
        openamount = 0;
        switch (CredHistr.RecordType) begin
          case 0: 
            type = GetCredHistType(CredHistr.ArtCode,false); 
            openamount = GetCredHistOpenAmount(CredHistr);
            if (CredManr.PauseDate==CredHistr.TransDate) then begin
              pausebal = calcbal;
            end;
            if (CredManr.ProlongDate==CredHistr.TransDate) then begin
              prolongbal = calcbal;
            end;
          case 4: 
            type = kEventTypePartialBuyout;
            buyoutamount = buyoutamount + CredHistr.Sum;
          otherwise
            PrevCredHistr.SerNr = CredHistr.PreviousNr;
            ReadFirstMain(PrevCredHistr,1,true);
            type = GetCredHistType(PrevCredHistr.ArtCode,true);          
        end;
        AddCredPayPlanLine(CredManPayPlanr,CredHistr.TransDate,CredHistr.ArtCode,"",type,CredHistr.Sum,0,acumint,calcbal,"","",CredHistr.SerNr,-1,openamount);
        if (CredHistr.RecordType==0) then begin
          if (IsInitialInvoice(CredManr,CredHistr.TransDate,lastrecnr,vFirstInv[CredHistr.RecordNr])) then begin
            firstinvf = true;
            vFirstInv[CredHistr.RecordNr] = true;//we can have multiple records for single invoice. so we need to store that this invoice is the initial invoice
          end else begin
            if (CredHistr.RecordType==0 and CredHistr.ArtCode!=CredManSetb.LateRateItem) then begin//invoice
              calculatedmonths = MonthDiff(CredManr.FirstInvDate,CredHistr.TransDate)+1;
            end;
          end;
          lastrecnr = CredHistr.RecordNr;
        end;
      end;
    end;
  end;

  if (buyoutamount>0) then begin
    //if (CredManr.InstalmentType==2 or CredManr.InstalmentType==6 or CredManr.InstalmentType==7) then begin
      monthlypayment = (CredManr.InvSum4-CredManr.DepositSum)/(CredManr.InstalmentMonths-CredManr.PrincipleDelayMonths);
      reducemonths = buyoutamount/monthlypayment;
      months = months - reducemonths;
    //end;
  end;

  return;
end;

procedure AddInitialInvoice(record CredManVc CredManr,var record CredmanPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  
  AddPlannedFees(CredManr,CredManPayPlanr,CMb,kPlannedFeesOneTime,kMonthTypeRegular,CredManr.startDate,acumint,calcbal,frdate,todate,-1);
  AddDeposit(CredManr,CredManPayPlanr,CMb,CredManr.startDate,acumint,calcbal,frdate,todate);

  return;
end;

function Boolean CredManIsPaused(record CredManVc CredManr,Date invdate)
begin
  Boolean res;
  Date pstart,pend;

  if (nonblank(CredManr.PauseDate)) then begin
    pstart = CredManr.PauseDate;
    pend = AddDay(AddMonth(pstart,CredManr.PauseMonths),-1);
    if (DateInRange(invdate,pstart,pend)) then begin
      res = true;
    end;
  end;

  CredManIsPaused = res;
  return;
end;

function Integer GetMonthType(Integer month,Integer totmonths)
begin
  Integer res;

  res = kMonthTypeRegular;
  if (month==0) then begin
    res = kMonthTypeFirst;
  end;
  if (month==totmonths-1) then begin
    res = kMonthTypeLast;
  end;

  GetMonthType = res;
  return;
end;

procedure AddFactoringInvoices(record CredManVc inCredManr,var record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,Date invdate,var val acumint,var val calcbal,Date frdate,Date todate)
begin
  val tcalcbal;
  record CredManFactInvoiceVc CMIr;
  Boolean TrHs;
  
  TrHs = true;
  CMIr.CustPaidFlag = 1;
  CMIr.FeeGenFlag = 0;
  while (LoopKey("CustPaidFlag:" & inCredManr.SerNr,CMIr,2,TrHs)) begin
    if (CMIr.CustPaidFlag!=1 or CMIr.FeeGenFlag!=0) then begin
      TrHs = false;
    end else begin
      tcalcbal = CMIr.TotalSum*inCredManr.LoanToValue/100;
      AddInterest(inCredManr,CredManPayPlanr,CredManSetb,kMonthTypeLast,invdate,acumint,tcalcbal,CMIr.InvDate,CMIr.PaymentDate,CMIr.SerNr,false);  
      tcalcbal = CMIr.TotalSum*inCredManr.LoanToValue/100;
      AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesOneTime,kMonthTypeLast,invdate,acumint,tcalcbal,CMIr.InvDate,CMIr.PaymentDate,CMIr.SerNr);//kPlannedFeesOneTime or kPlannedFeesMonthly?
    end;
  end;

  return;
end;

procedure AddLateFees(record CredManVc CredManr,var record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,record CMInvoicingBlock CIb,Date invdat,Date frdate,Date todate,var val acumint,var val calcbal)
begin
  Integer latedays;
  val lateamount;
  Date invdat2;
  Date sd,ed;
  array string 255 lateformula;
  Boolean addf;
  record CredManTypeVc CMTr;
  
  if (CIb.OverdueIVType==2) then begin
    sd = AddMonth(frdate,-1);
    ed = AddDay(AddMonth(sd,1),-1);
    invdat2 = invdat;
    invdat2.Day = CIb.OverdueIVDay;
    GetCredManOverdueInvoices(CredManr,CredManSetb,ed,sd,latedays,lateamount,lateformula,false);
    addf = true;
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      if (CMTr.MinOverdueFee>0 and lateamount<CMTr.MinOverdueFee) then begin
        addf = false;
      end;
    end;
    if (addf) then begin
      AddCredPayPlanLine(CredManPayPlanr,invdat2,CredManSetb.LateRateItem,"",kEventTypeIssueLateFees,lateamount,0,acumint,calcbal,frdate,todate,-1,-1,0);
    end;
  end;

  return;
end;

global
procedure BuildCredManPayPlanCust(record CredManVc inCredManr,var record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CredManSetb,Boolean withactuals,Boolean suggestedonsameday)
begin
  Integer calculatedmonths,months;
  val acumint,calcbal;
  Integer i,monthtype,monthtype2,monthtype3,delaymonths;
  Date invdat,frdat,todat,int_frdat,int_todat,int_invdat;
  Boolean firstinvf,setdelf;
  Integer usemonths,curmonth,prolongstartmonths,basemonths,pausestartmonths;
  val usesum,buyoutamount,pausebal,prolongbal;
  Boolean prolongf,pausef;
  record CMInvoicingBlock CIb;

/*should we calculate VAT here?
  if CredManr.VATSum > 0 and nonblank(CredManr.VATAddMonths) then begin
    GetMonthlyVatVector(CredManr.VATSum, CredManr.VATAddMonths, vatPayments);
  end;
*/
  BlockLoad(CIb);

  months = inCredManr.InstalmentMonths;
  acumint = 0;
  calcbal = inCredManr.InvSum4;
  usesum = inCredManr.InvSum4 - inCredManr.DepositSum;

  if (withactuals) then begin
    AddActualsToPlan(inCredManr,CredManPayPlanr,calculatedmonths,acumint,calcbal,firstinvf,CredManSetb,months,buyoutamount,pausebal,prolongbal);
  end;
  usemonths = months;
/*
  if (nonblank(inCredManr.PauseDate)) then begin
    months = months + inCredManr.PauseMonths;
  end;
*/
  if (buyoutamount>0) then begin
    usesum = usesum - buyoutamount;
  end;

  if (nonblank(InCredManr.ProlongDate) and InCredManr.ProlongMonths>0) then begin
    prolongstartmonths = MonthDiff(InCredManr.FirstInvDate,InCredManr.ProlongDate);
  end;  
  if (nonblank(InCredManr.PauseDate) and InCredManr.PauseMonths>0) then begin
    pausestartmonths = MonthDiff(InCredManr.FirstInvDate,InCredManr.PauseDate);
  end;  
  delaymonths = inCredManr.PrincipleDelayMonths;
  basemonths = usemonths - delaymonths;
//logtext(0,"start dev");
  for(i=calculatedmonths;i<months;i=i+1) begin
    if (calcbal>0) then begin
      CalcCredManCurrentPeriod(inCredManr,CIb,i-1,frdat,todat,int_frdat,int_todat,invdat,int_invdat); //sets dates, frdat, todat and invdat
      if (i==0 and firstinvf==false and inCredManr.InstalmentType!=4) then begin//Not for factoring
        AddInitialInvoice(inCredManr,CredManPayPlanr,CredManSetb,acumint,calcbal,"","");
      end;
      //logtext(0,"l1 " & invdat & ":" & i & ":" & curmonth & ":" & usemonths & ":" & months & ":" & usesum & ":" & prolongstartmonths);
      if (nonblank(InCredManr.ProlongDate) and InCredManr.ProlongMonths>0) then begin
        if (InCredManr.ProlongDate<=invdat and prolongf==false) then begin
          if (prolongbal>0) then begin
            usesum = prolongbal;
          end else begin
            usesum = calcbal;
          end;

          months = months + InCredManr.ProlongMonths;
          /*
          usemonths = basemonths + InCredManr.ProlongMonths - (prolongstartmonths-delaymonths);
          if (pausef) then begin
            usemonths = usemonths - InCredManr.PauseMonths;
          end;
          */
          usemonths = months - i;
          if (setdelf==false) then begin
            usemonths = usemonths + delaymonths;
          end; 

          prolongf = true;
        end;
      end;
//      logtext(0,"l2 " & i & ":" & curmonth & ":" & usemonths & ":" & months & ":" & usesum & ":" & prolongstartmonths);
      if (nonblank(InCredManr.PauseDate) and InCredManr.PauseMonths>0) then begin
        if (InCredManr.PauseDate<=invdat and pausef==false) then begin
          //if (pausebal>0) then begin
          //  usesum = pausebal;
          //end else begin
            usesum = calcbal;
          //end;
          //months = months;
          /*
          usemonths = basemonths - InCredManr.PauseMonths - (pausestartmonths-delaymonths);
          if (prolongf) then begin
            usemonths = usemonths + InCredManr.ProlongMonths;
          end;
          */
          usemonths = months - i;
          if (setdelf==false) then begin
            usemonths = usemonths + delaymonths;
          end; 
          if (i < pausestartmonths + InCredManr.PauseMonths) then begin
            usemonths = months - (pausestartmonths + InCredManr.PauseMonths);
          end;

          pausef = true;
        end;
      end;
      curmonth = i;
      if (prolongf) then begin
        curmonth = curmonth - prolongstartmonths; 
        if (setdelf) then begin
          curmonth = curmonth + delaymonths;
        end;       
      end;
//      logtext(0,"l3 " & i & ":" & curmonth & ":" & usemonths & ":" & months & ":" & usesum & ":" & prolongstartmonths & ":" & pausestartmonths);
      if (nonblank(inCredManr.PauseDate) and AddMonth(inCredManr.PauseDate,inCredManr.PauseMonths)<invdat) then begin
        curmonth = curmonth - inCredManr.PauseMonths;
      end;
      monthtype = GetMonthType(i,months);
//      logtext(0,"l4 " & i & ":" & curmonth & ":" & usemonths & ":" & months & ":" & usesum & ":" & monthtype);
      switch (inCredManr.InstalmentType) begin
/*
        case 0://Annuity
          monthtype2 = monthtype;
          monthtype3 = monthtype;
          if (monthtype2==kMonthTypeLast) then begin
            monthtype2 = kMonthTypeRegular;
          end;
          if (monthtype3!=kMonthTypeFirst) then begin
            monthtype3 = kMonthTypeLast;
          end;
          AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype2,invdat,acumint,calcbal,frdat,todat,-1);
          AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,calcbal,int_frdat,int_todat,-1);
          if (CredManIsPaused(inCredManr,invdat)==false) then begin
            AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,2,monthtype,invdat,acumint,calcbal,frdat,todat,curmonth,usesum,usemonths);
          end;
          AddLateFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,frdat,todat,acumint,calcbal);
        case 2://Linear with Service Fee - bullet with linear or just Same, Same
          monthtype2 = monthtype;
          if (monthtype2==kMonthTypeLast) then begin
            monthtype2 = kMonthTypeRegular;
          end;
          AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype2,invdat,acumint,calcbal,frdat,todat,-1);
          AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype2,int_invdat,acumint,calcbal,int_frdat,int_todat,-1);
          if (CredManIsPaused(inCredManr,invdat)==false) then begin
            AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,1,monthtype,invdat,acumint,calcbal,frdat,todat,curmonth,usesum,usemonths);
          end;
          AddLateFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal);
*/
        case 0://annuity
          if (setdelf==false and inCredManr.PrincipleDelayMonths>0) then begin
            usemonths = usemonths - delaymonths;
            if (prolongf) then begin
              curmonth = curmonth + delaymonths;
            end;
            setdelf = true;
          end;
          monthtype2 = monthtype;
          monthtype3 = monthtype;
          if (monthtype2==kMonthTypeLast) then begin
            monthtype2 = kMonthTypeRegular;
          end;
          if (monthtype3!=kMonthTypeFirst) then begin
            monthtype3 = kMonthTypeLast;
          end;
          if (curmonth>=inCredManr.PrincipleDelayMonths and CredManIsPaused(inCredManr,invdat)==false) then begin
            AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype2,invdat,acumint,calcbal,frdat,todat,-1);
            AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,calcbal,int_frdat,int_todat,-1,false);
            AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,2,monthtype,invdat,acumint,calcbal,frdat,todat,curmonth-delaymonths,usesum,usemonths);
          end else begin
            if (CredManIsPaused(inCredManr,invdat)) then begin
              AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype2,invdat,acumint,calcbal,frdat,todat,-1);
              AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,calcbal,int_frdat,int_todat,-1,false);
           end else begin
              AddInterestDelay(inCredManr,CredManPayPlanr,CredManSetb,monthtype3,int_invdat,acumint,calcbal,int_frdat,int_todat,-1);
            end;
          end;
          AddLateFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal);
        case 1://linear with delay
          if (setdelf==false and inCredManr.PrincipleDelayMonths>0) then begin
            usemonths = usemonths - delaymonths;
            if (prolongf) then begin
              curmonth = curmonth + delaymonths;
            end;
            setdelf = true;
          end;
          monthtype2 = monthtype;
          if (monthtype2==kMonthTypeLast) then begin
            monthtype2 = kMonthTypeRegular;
          end;
          if (curmonth>=inCredManr.PrincipleDelayMonths and CredManIsPaused(inCredManr,invdat)==false) then begin
            AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype2,invdat,acumint,  calcbal,frdat,todat,-1);
            AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype2,int_invdat,acumint,calcbal,int_frdat,int_todat,-1,false);
            AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,1,monthtype,invdat,acumint,calcbal,frdat,todat,curmonth-delaymonths,usesum,usemonths);
          end else begin
            if (CredManIsPaused(inCredManr,invdat)) then begin
              AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype2,invdat,acumint,calcbal,frdat,todat,-1);
              AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype2,int_invdat,acumint,calcbal,int_frdat,int_todat,-1,false);
            end else begin
              AddInterestDelay(inCredManr,CredManPayPlanr,CredManSetb,monthtype2,int_invdat,acumint,calcbal,int_frdat,int_todat,-1);
            end;
          end;
          AddLateFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal);
        case 3://Bullet
          AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,monthtype,invdat,acumint,calcbal,frdat,todat,-1);
          AddInterest(inCredManr,CredManPayPlanr,CredManSetb,monthtype,int_invdat,acumint,calcbal,int_frdat,int_todat,-1,false);
          if (i==months-1) then begin
            AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,0,monthtype,invdat,acumint,calcbal,frdat,todat,curmonth,usesum,usemonths)
          end;
          AddLateFees(inCredManr,CredManPayPlanr,CredManSetb,CIb,invdat,int_frdat,int_todat,acumint,calcbal);
        case 4://Factoring
          AddFactoringInvoices(inCredManr,CredManPayPlanr,CredManSetb,CurrentDate,acumint,calcbal,frdat,todat)
        case 5://Payment guarantee

      end;
      AddExtraDeposit(inCredManr,CredManPayPlanr,CredManSetb,invdat,acumint,calcbal,frdat,todat,i+1);
      //if (i==0) then begin
      //  AddDeposit(inCredManr,CredManPayPlanr,CredManSetb,invdat,acumint,calcbal,frdat,todat);
      //end;
    end;
  end;

  SortRows(CredManPayPlanr,"TransDate",true);

  return;
end;

global
function val GetMonthlyPaymentAmount(record CredManVc inCredManr,Integer type)
begin
  record CredManSetBlock CredManSetb;
  record CredManPayPlanVc CredManPayPlanr;
  row CredManPayPlanVc CredManPayPlanrw;
  val acumint,res,bal,tmp;
  Date td;
  Integer i,rwcnt;

  BlockLoad(CredManSetb);
  td = inCredManr.startDate;

  if (BitAnd(type,2)) then begin
    bal = inCredManr.InvSum4-inCredManr.DepositSum;
    if (nonblank(inCredManr.PrincipleDelayMonths)) then begin
      AddInterestDelay(inCredManr,CredManPayPlanr,CredManSetb,kMonthTypeRegular,td,acumint,bal,"","",-1);
    end else begin
      AddInterest(inCredManr,CredManPayPlanr,CredManSetb,kMonthTypeRegular,td,acumint,bal,"","",-1,false);
    end;
  end;
  if (BitAnd(type,4)) then begin
    bal = inCredManr.InvSum4-inCredManr.DepositSum;
    AddPlannedFees(inCredManr,CredManPayPlanr,CredManSetb,kPlannedFeesMonthly,kMonthTypeRegular,td,acumint,bal,"","",-1);
  end;
  if (BitAnd(type,8)) then begin
    bal = inCredManr.InvSum4-inCredManr.DepositSum;
    AddInstalment(inCredManr,CredManPayPlanr,CredManSetb,1,kMonthTypeRegular,td,acumint,bal,"","",1,inCredManr.InvSum4-inCredManr.DepositSum,inCredManr.InstalmentMonths);//first month
    if (inCredManr.MaxMonthlyPayment>0) then begin
      tmp = GetMonthlyPaymentAmount(inCredManr,6);
      MatRowGet(CredManPayPlanr,MatRowCnt(CredManPayPlanr)-1,CredManPayPlanrw);
      CredManPayPlanrw.Sum = inCredManr.MaxMonthlyPayment - tmp;
      MatRowPut(CredManPayPlanr,MatRowCnt(CredManPayPlanr)-1,CredManPayPlanrw);
    end;
  end;

  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    res = res + CredManPayPlanrw.Sum;
  end;

  GetMonthlyPaymentAmount = res;
  return;
end;

global
function string 255 GetPlanTypeTextCust(Integer plantype)
begin
  string 255 res;
  
  switch (plantype) begin
    case 0: res = "Should not happen";
    case 1: res = "Suggested Instalment";
    case 2: res = "Suggested Interest";
    case 3: res = "Suggested Deposit";
    case 4: res = "Suggested Fee";
    case 5: res = "Invoiced Instalment";
    case 6: res = "Invoiced Interest";
    case 7: res = "Invoiced Deposit";
    case 8: res = "Invoiced Fee";
    case 9: res = "Invoiced Late Fees";
    case 10: res = "Paid Instalment";
    case 11: res = "Paid Interest";
    case 12: res = "Paid Deposit";
    case 13: res = "Paid Fee";
  end;
  GetPlanTypeTextCust = res;
  return;
end;
