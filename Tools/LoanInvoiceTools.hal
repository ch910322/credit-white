external function val GetBalanceOnDate(record CredManPayPlanVc,Date);
external procedure BuildCredManPayPlanCust(record CredManVc,var record CredManPayPlanVc,record CredManSetBlock,Boolean,Boolean);
external procedure BuildCredManPayPlanCust2(record CredManVc,var record CredManPayPlanVc,record CredManSetBlock,Boolean,Boolean,Boolean);
external inner function Boolean PasteCust2InInv(var record IVVc,record LocalMachineBlock,string,Boolean,var string,var string,var string,var string,var string);
remote inner procedure IVVc_PastePayDeal(var record IVVc,string,string);
remote inner procedure IVVc_PasteSalesMan(var record IVVc,string);
external inner function Boolean IVVc_PasteArtCode(var record IVVc,Integer,var string,var string,Boolean,var Integer);
external inner procedure IVDchsum(var record IVVc,Integer);
external inner procedure IVVc_PastePrice(var record IVVc,record IVVc,Integer,var string);
external inner function LongInt DateDiff(Date,Date);
external procedure AddPlannedFees(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,Integer,Integer,Date,var val,var val,Date,Date,Longint,Boolean);
external procedure AddInterest(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,Integer,Date,var val,var val,Date,Date,Longint,Boolean);
external procedure AddInstalmentFixed(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,val,Date,var val,var val,Date,Date,val);
external procedure AddInstalmentFixedBO(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,val,Date,var val,var val,Date,Date);
forward procedure GetCredManEventList2(Longint,var record ORVc);
external inner procedure PasteARPayInIV(record IVVc,row IVVc,Integer);
external updating procedure FindUnpaidCredHist(record IPVc,row IPVc,var vector val,Integer);
external inner function Boolean IVVc_PasteSum(var record IVVc,Integer,var Boolean,Integer);
external function Date GetLastInvoiceDate(record CredManVc,Date);
external procedure BuildCredManInfoMatrix(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,var record SMVc);
external inner procedure SumNoDownPay(record IVVc,var val,var val,var val,var val,var val,var val);
external function string 255 GetCredManNr(Longint);
external procedure GetHiddenInvoiceValues(record IVVc,var val,var val);
external inner procedure InvVat(Integer,Integer,Integer,Integer,string,val,var val,var val,var val,var val,var val);
external procedure GenerateAgreementSchedule(record CredManVc,Boolean,Boolean);
external function Boolean BuildCredManInfoMatrixOnSchedule(record CredManVc,record CredManSetBlock,var record SMVc);
external function Boolean GetCredLegalNrLine(string,string,Date,string,string,var row CredLegalInvNrBlock,Integer);
external inner function string 50 NextLegalSerNr(string,LongInt,Date,string,string,string);
external function Boolean CanCreateSingleAgreementInvoice(record CredManVc,var Date);
external inner procedure IPSumup(var record IPVc);
external inner procedure IPVc_PasteRecVal(var record IPVc,Integer);
external inner function Boolean PasteInvIn2IPr(var record IPVc,Integer,Date,var val,Boolean,var Boolean);
external inner function Boolean IPVc_PasteCustCode(var record IPVc,Integer,var LongInt);
external function val FindInvoicePaidAmount_OP(LongInt,LongInt);
external inner procedure IPPastePayMode(var record IPVc);
external inner updating procedure CreateInvoicePdfFile(record IVVc);
external function Boolean CredManPMCodeMatches2(string,record CredManVc,Boolean);
remote procedure CheckBuyOutAgreementCallBack(record RcVc,Integer);
external function Boolean TypeAffectsBalance(Integer);
external function val GetAgreementAmount(record CredManVc);
external inner procedure IVVc_PastePayDeal2(var record IVVc,string,string,Boolean);
external function Boolean FindCredManAcc(record CredManVc,var record CredManAccVc);
external function Boolean IsPartialBuyoutType(Integer);
external function Boolean CredManCanInvoiceOverdues(record CredManVc);
external function val GetCredHistOpenAmount(record CredHistVc,Integer);
external inner function string 60 AddObjectToObjectList(string,string);
external inner function string 255 StrReplace(string,string,string);
external function val GetCredHistOpenValueOnDate(Longint,Date);
external updating procedure CreditAndOKInvoice(Longint,val,var val,var vector val,val,Boolean,Date,string,string,string);
external function val GetRateAmount(record CredManVc,val,Integer,Date,Date,val,Boolean,Boolean);
external inner function Boolean ItemInItemGroupOrClass(string,string,string);
external procedure CredManSchedRecalcBalance(var record CredManSchedVc);
external procedure SumupCredManSched(var record CredManSchedVc,Integer);
external inner function Boolean FindCustomerRelation(string,string,var record CUVc);
external inner function Integer CreateCreditNoteIV(record IVVc,Integer,var record IVVc,string,Boolean);
external inner procedure IVSumup(var record IVVc,Boolean);
external procedure AddInterestBO(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,Integer,Date,var val,var val,Date,Date,Longint,Boolean);
external inner function Boolean IVVc_PasteArtCode(var record IVVc,Integer,var string,var string,Boolean,var Integer);
external inner function Boolean IVVc_PasteQuantity(var record IVVc,Integer);
external function Boolean IsOmegaCustomer;
external procedure InsertCredHistInArray(record CredHistVc,array record ORVc,Integer,Date);
external function Integer GetItemPriority(Longint,string);
external inner function roundmode SetRoundModeD(Integer);
external updating procedure ReceiptEntryCreateReceipts(record SMVc,Boolean,var val);
forward updating procedure CheckCredManFinished(Longint,date);
external inner procedure FindFiscalYear(Date,var Date,var Date);
external procedure DistributeCredHistValues(var record IPVc,Integer);
external inner procedure IPSumup(var record IPVc);


enum begin
  kCredHistRecTypeInvoice = 0,
  kCredHistRecTypeReceipt = 1,
  kCredHistRecTypePrepayment = 2,
  kCredHistRecTypeCreditNote = 3
end;

enum begin
  kPlannedFeesMonthly = 0,
  kPlannedFeesOneTime = 1
end;

enum begin
  kEventTypeNone = 0,
  kEventTypeCalcInstalment = 1,
  kEventTypeCalcInterest = 2,
  kEventTypeCalcDeposit = 3,
  kEventTypeCalcFees = 4,
  kEventTypeIssueInstalment = 5,
  kEventTypeIssueInterest = 6,
  kEventTypeIssueDeposit = 7,
  kEventTypeIssueFees = 8,
  kEventTypeIssueLateFees = 9,
  kEventTypePaidInterest = 13,
  kEventTypePaidInstalment = 14,
  kEventTypePaidDeposit = 15,
  kEventTypePaidFees = 16,
  kEventTypeSoldAgreement = 17,
  kEventTypePayout = 18,
  kEventTypePartialBuyout = 19,
end;

enum begin
  kMonthTypeFirst = 0,
  kMonthTypeRegular = 1,
  kMonthTypeLast = 2
end;

procedure logforadmin(longint num, string str)
begin

  if(currentuser=="EBS" or fileexists("logforadmin"))then begin
    logtext(num,str);
  end;
  
return;
end;

global function boolean checkIfInvoiceFromAgreement(record IVVc IVr,var vector val vIVItemOpenAmmount)
begin
boolean res;
record CredHistVc CredHistr,CredHist2r;
boolean TrHs,TrHs2;
record INVc INr;
string 255 tstr;
val t,tt,tot1,tot2,tot3;
longint t2;
date blankd;

  res = false;
  CredHistr.RecordNr = IVr.SerNr;
  CredHistr.RecordType = 0;
  TrHs = true;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if ((CredHistr.RecordNr!=IVr.SerNr) or (CredHistr.RecordType!=0)) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      res = true;
      t = GetCredHistOpenValueOnDate(CredHistr.SerNr,blankd);
      vIVItemOpenAmmount[CredHistr.ArtCode] = t;
      //messagebox(0,CredHistr.ArtCode & "  " & t);
      EndFormat;
    end;
  end;

  checkIfInvoiceFromAgreement = res;
return;
end;

global function boolean getAdditionalLangCode(record CredManVc CredManr, string type, var string reslang)
begin
  boolean res;
  record CUVc CUr;
  record CredManAddLangVc CredManAddLangr; 
  row CredManAddLangVc CredManAddLangrw; 
  boolean foundf;
  integer i,rwcnt;
  record CredManTypeVc CredManTyper;
  
  CredManTyper.Code = CredManr.Type;
  if(readfirstmain(CredManTyper,1,true))then begin
    CUr.Code = CredManr.CustCode;
    CredManAddLangr.CredManTypeCode = CredManTyper.Code;
    if(readfirstmain(CredManAddLangr,1,true))then begin
      if(readfirstmain(CUr,1,true))then begin
        if(nonblank(CUr.LangCode))then begin
          rwcnt = matrowcnt(CredManAddLangr);
          for(i=0;i<rwcnt;i=i+1)begin
            matrowget(CredManAddLangr,i,CredManAddLangrw);
            if(nonblank(CredManAddLangrw.LangCode) and CredManAddLangrw.LangCode==CUr.LangCode)then begin
              foundf = true;
              i=rwcnt;
            end;
          end;
        
          reslang = "";
          if(foundf)then begin
            if(type=="IntLang")then begin
              if(nonblanK(CredManAddLangrw.IntLang))then begin
                res = true;
                reslang = CredManAddLangrw.IntLang;
              end;
            end;
            if(type=="LangCode2")then begin
              if(nonblanK(CredManAddLangrw.LangCode2))then begin
                res = true;
                reslang = CredManAddLangrw.LangCode2;
              end;
            end;
            if(type=="OverdueLangCode")then begin
              if(nonblanK(CredManAddLangrw.OverdueLangCode))then begin
                res = true;
                reslang = CredManAddLangrw.OverdueLangCode;
              end;
            end;
            if(type=="BuyOutLangCode")then begin
              if(nonblanK(CredManAddLangrw.BuyOutLangCode))then begin
                res = true;
                reslang = CredManAddLangrw.BuyOutLangCode;
              end;
            end;
            if(type=="InvOverdLangCode")then begin
              if(nonblanK(CredManAddLangrw.InvOverdLangCode))then begin
                res = true;
                reslang = CredManAddLangrw.InvOverdLangCode;
              end;
            end;
            if(type=="AgreChangeLangCode")then begin
              if(nonblanK(CredManAddLangrw.AgreChangeLangCode))then begin
                res = true;
                reslang = CredManAddLangrw.AgreChangeLangCode;
              end;
            end;
            
            if(type=="CompensLangCode")then begin
              if(nonblanK(CredManAddLangrw.CompensLangCode))then begin
                res = true;
                reslang = CredManAddLangrw.CompensLangCode;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
  
  getAdditionalLangCode = res;
return;
end;

global function string 20 getAdditionalCredManLangCode(record CredManVc CredManr)
begin
  string 20 res;
  record CUVc CUr;
  record CredManAddLangVc CredManAddLangr; 
  row CredManAddLangVc CredManAddLangrw; 
  boolean foundf;
  integer i,rwcnt;
  record CredManTypeVc CredManTyper;
  
  res = CredManr.LangCode;
  
  CredManTyper.Code = CredManr.Type;
  if(readfirstmain(CredManTyper,1,true))then begin
    CUr.Code = CredManr.CustCode;
    CredManAddLangr.CredManTypeCode = CredManTyper.Code;
    if(readfirstmain(CredManAddLangr,1,true))then begin
      if(readfirstmain(CUr,1,true))then begin
        if(nonblank(CUr.LangCode))then begin
          rwcnt = matrowcnt(CredManAddLangr);
          for(i=0;i<rwcnt;i=i+1)begin
            matrowget(CredManAddLangr,i,CredManAddLangrw);
            if(nonblank(CredManAddLangrw.LangCode) and CredManAddLangrw.LangCode==CUr.LangCode)then begin
              foundf = true;
              i=rwcnt;
            end;
          end;
        
          if(foundf)then begin
            if(nonblanK(CredManAddLangrw.IntLang))then begin
              res = CredManAddLangrw.IntLang;
            end;
          end;
        end;
      end;
    end;
  end;
  
  getAdditionalCredManLangCode = res;
return;
end;


function longint MAXLongint(longint a,longint b)
begin
  if (a>b) then begin
    MAXLongint = a;
  end else begin
    MAXLongint = b;
  end;
  return;
end;

global
function string 255 CM_SetCompanyLanguage()
begin
  record CYBlock CYb;
  string 255 oldlang,newlang;
  Integer langmode;

  BlockLoad(CYb);
  oldlang = CurrentLanguage;
  newlang = CYb.LangCode;

  if (oldlang!=newlang and nonblank(newlang)) then begin
    langmode = SetFromString(619,newlang);
    if (langmode>-1) then begin
      SetLangMode(langmode,newlang,0);
    end;
  end;

  CM_SetCompanyLanguage = oldlang;
  return;
end;

global
procedure CM_ResetCompanyLanguage(string oldlang)
begin
  Integer oldlangmode;

  if (nonblank(oldlang) and CurrentLanguage!=oldlang) then begin
    oldlangmode = SetFromString(619,oldlang);
    if (oldlangmode>-1) then begin
      SetLangMode(oldlangmode,oldlang,0);
    end;
  end;

  return;
end;

updating procedure LinkCredManAndInvoice(record IVVc IVr,record CredManVc CredManr)
begin
  
  CreateRecordLink(IVr,CurrentCompany,CredManr,CurrentCompany);

  return;
end;

function Boolean FindInvLegalNrLine(Date invdate,string serie,var row LegalInvNrBlock tLINrbrw)
begin
  record LegalInvNrBlock LINrb;
  row LegalInvNrBlock LINrbrw;
  Integer i,rwcnt;
  Boolean res;

  BlockLoad(LINrb);
  rwcnt = MatRowCnt(LINrb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LINrb,i,LINrbrw);
    if (DateInRange(invdate,LINrbrw.PurchDate,LINrbrw.EndDate) and LINrbrw.Serie==serie) then begin
      CopyRow(LINrb,LINrbrw,tLINrbrw);
      i = rwcnt;
      res = true;
    end;
  end;

  FindInvLegalNrLine = res;
  return;
end;

function string 255 GetCredManOfficialSerNr(record IVVc IVr,record CredManVc CredManr,Integer rectype)
begin
  row CredLegalInvNrBlock LegalInvNrrw;
  row LegalInvNrBlock LINrbrw;
  string 255 serie,res;
  
  if (nonblank(CredManr.OfficialSerNr)) then begin
    GetCredLegalNrLine("CredManVc",CredManr.SerNr,CredManr.startDate,CredManr.Type,CredManr.Classifications,LegalInvNrrw,-1);
    ;
    switch (rectype) begin
      case 0:serie = LegalInvNrrw.FirstInvSerie;
      case 1:serie = LegalInvNrrw.RegularInvSerie;
      case 2:
        if (CredManr.UseCompensationInvoices==1) then begin
          serie = LegalInvNrrw.CompensationInvSerie;
        end else begin
          serie = LegalInvNrrw.OverdueInvSerie;
        end;
    end;
    if (FindInvLegalNrLine(IVr.InvDate,serie,LINrbrw)) then begin
      res = NextLegalSerNr("IVVc",IVr.SerNr,IVr.InvDate,LINrbrw.Serie,LINrbrw.TSerStart,LINrbrw.TSerEnd);
    end;
  end;


  GetCredManOfficialSerNr = res;
  return;
end;

function Integer GetInvoiceType(record CredManVc CredManr,Date invdate)
begin
  Integer res;
  
  if (invdate==CredManr.startDate) then begin
    res = 0;
  end else begin
    res = 1;
  end;

  GetInvoiceType = res;
  return;
end;

function string 255 GetInvoicePeriodString(record CMInvoicingBlock CIb,date fromdate,Date todate)
begin
  string 255 del,res;

  del = ":";
  if (nonblank(CIb.PeriodDelimiter)) then begin
    del = CIb.PeriodDelimiter;
  end;

  res = CIb.InvoiceCommentStr & USetStr(200081) & fromdate & del & todate;

  GetInvoicePeriodString = res;
  return;
end;

global
procedure SetupLoanInvoice3(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Date invdate,Date fromdate,Date todate,Boolean sernrf,Boolean forcecustf,string ivno,Integer invtype,Boolean fullf,string paydeal,string salesman)
begin
  record LocalMachineBlock LMb;
  string 255 warning,errstr,prepstr,invdatewarn,transdatewarn;
  row IVVc IVrw;
  string 255 oldlang;
  record CMInvoicingBlock CIb;
  record CredManAccVc CMAr;
  string 255 del,reslang;
  boolean doforcepaydeal,periodflag;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  integer i,rwcnt; 
  date fromdaterow;
  
  
  fromdaterow = fromdate;
  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    rwcnt = MatRowCnt(CSr);
    for (i=0;i<rwcnt;i=i+1) begin
     MatRowGet(CSr,i,CSrw);
      if (CSrw.Invoiced==1 and nonblankdate(CSrw.FromDate)) then begin
        if(dateinrange(invdate,CSrw.FromDate,CSrw.ToDate))then begin
          fromdaterow = CSrw.FromDate;
        end else begin
          fromdaterow = addday(CSrw.ToDate,1);
        end;
      end;
    end;
  end;
  
  doforcepaydeal = true;
  BlockLoad(LMb);
  BlockLoad(CIb);
  if (fullf) then begin
    oldlang = CM_SetCompanyLanguage;
  end;

  RecordNew(IVr);
  IVr.CustCredManNr = CredManr.SerNr;
  IVr.TransDate = invdate;//or current date?
  IVr.InvDate = invdate;//from seting?
  IVr.CustCode = CredManr.CustCode;
  PasteCust2InInv(IVr,LMb,"",false,warning,errstr,prepstr,invdatewarn,transdatewarn);
  if (nonblank(paydeal)) then begin
    IVr.PayDeal = paydeal;
  end else begin
    IVr.PayDeal = CredManr.PayDeal;
  end;
  IVVc_PastePayDeal(IVr,"",LMb.DefReturnLocation);
  if (nonblank(salesman)) then begin
    IVr.SalesMan = salesman;
  end else begin
    IVr.SalesMan = CredManr.SalesMan;
  end;
  IVVc_PasteSalesMan(IVr,"");
  IVr.CredFromDate = fromdate;
  IVr.CredToDate = todate; 
  if (fullf) then begin
    if (nonblank(ivno)) then begin
      IVr.OfficialSerNr = ivno;
    end else begin
      IVr.OfficialSerNr = GetCredManOfficialSerNr(IVr,CredManr,invtype);
    end;
  end;
  if (sernrf) then begin
    IVr.SerNr = NextSerNr("IVVc",IVr.InvDate,-1,false,"");
  end;

  IVr.CredFromDate = fromdate;
  IVr.CredToDate = todate;
  if (invdate<CredManr.FirstInvDate and blank(fromdate)) then begin//First invoice language
    IVr.LangCode = CredManr.LangCode2;
    if(getAdditionalLangCode(CredManr,"LangCode2",reslang))then begin
      IVr.LangCode = reslang;
    end;
    if (nonblank(paydeal)) then begin
      IVr.PayDeal = paydeal;
      doforcepaydeal = false;
    end else begin
      if (nonblank(CIb.FirstInvPayDeal)) then begin
        IVr.PayDeal = CIb.FirstInvPayDeal;
        IVVc_PastePayDeal(IVr,"",LMb.DefReturnLocation);
        doforcepaydeal = false;
      end;
    end;
  end else begin
    IVr.LangCode = CredManr.LangCode;
    if(getAdditionalLangCode(CredManr,"IntLang",reslang))then begin
      IVr.LangCode = reslang;
    end;
  end;
   if (FindCredManAcc(CredManr,CMAr)) then begin
     IVr.Objects = AddObjectToObjectList(IVr.Objects,CMAr.Objects);
   end;
   IVr.Objects = AddObjectToObjectList(IVr.Objects,CredManr.Objects);
  //we should always have in the plan first row instalment or interest where we have start and end date
  if (CIb.DetailedInvoice==1) then begin
    ClearRow(IVr,IVrw,1);
    if (nonblank(CredManr.OfficialSerNr)) then begin
      IVrw.Spec = CIb.InvoiceCommentStr & USetStr(200080) & CredManr.OfficialSerNr;
    end else begin
      IVrw.Spec = CIb.InvoiceCommentStr & USetStr(200080) & CredManr.SerNr;
    end;
    MatRowPut(IVr,0,IVrw);
    periodflag = true;
    if(CIb.OverdueIVType!=0 and CIb.HidePeriodInSepOVD==1)then begin
      if(invtype==2)then begin
        periodflag = false;
      end;
    end;
    if(periodflag)then begin
      if (nonblank(fromdate)) then begin
        ClearRow(IVr,IVrw,1);
        if(invtype==2)then begin
          IVrw.Spec = GetInvoicePeriodString(CIb,fromdate,todate);// Edit ************************** BPI Ukraine - KramarAlexandr - 04, 23 09 2021 y. at 3:39:30 PM
        end else begin
          IVrw.Spec = GetInvoicePeriodString(CIb,fromdaterow,todate);// Edit ************************** BPI Ukraine - KramarAlexandr - 04, 23 09 2021 y. at 3:39:30 PM
        end;
        MatRowPut(IVr,1,IVrw);
      end else begin
        ClearRow(IVr,IVrw,1);
        IVrw.Spec = " ";
        MatRowPut(IVr,1,IVrw);      
      end;
    end;
    ClearRow(IVr,IVrw,1);
    IVrw.Spec = " ";
    MatRowPut(IVr,MatRowCnt(IVr),IVrw);
  end;
  if ((nonblank(CredManr.ForcePayDeal)) and (doforcepaydeal) and (blank(paydeal))) then begin
    IVr.PayDeal = CredManr.ForcePayDeal;
    IVVc_PastePayDeal(IVr,"",LMb.DefReturnLocation);
  end;
  CM_ResetCompanyLanguage(oldlang);

  return;
end;

global
procedure SetupLoanInvoice2(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Date invdate,Date fromdate,Date todate,Boolean sernrf,Boolean forcecustf,string ivno,Integer invtype,Boolean fullf,string paydeal)
begin
  SetupLoanInvoice3(CredManr,CMb,IVr,invdate,fromdate,todate,sernrf,forcecustf,ivno,invtype,fullf,"","");
  return;
end;

global
procedure SetupLoanInvoice(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Date invdate,Date fromdate,Date todate,Boolean sernrf,Boolean forcecustf,string ivno,Integer invtype,Boolean fullf)
begin
  SetupLoanInvoice3(CredManr,CMb,IVr,invdate,fromdate,todate,sernrf,forcecustf,ivno,invtype,fullf,"","");
  return;
end;

global
procedure SetupInvoiceRowAndAdd(record CredManVc CredManr,var record IVVc IVr,string item,string itemname,val quant,val price,val reb,Integer chargetype,Longint factinv)
begin
  row IVVc IVrw;
  string 255 inwarning,warning;
  Integer sernrf,rw;
  record IVVc IV2r;
  val bval;
  record CredManAccVc CMAr;
  row CredManAccVc CMArw;
  Integer i,rwcnt;  
  
  if (price>0 and nonblank(item)) then begin
    rw = MatRowCnt(IVr);
    ClearRow(IVr,IVrw,1);
    IVrw.ArtCode = item;
    IVrw.Quant = quant;
    IVrw.ChargeType = chargetype;
    IVrw.FactoringInvoice = factinv;
    MatRowPut(IVr,rw,IVrw);
    if (IVVc_PasteArtCode(IVr,rw,inwarning,warning,false,sernrf)) then begin    
      IVDchsum(IVr,rw);
    end;
    MatRowGet(IVr,rw,IVrw);
    IVrw.Price = price;
    if (reb>0) then begin
      IVrw.vRebate = reb;
    end else begin
      IVrw.vRebate = bval;//should it be like that? what about discount matrix?
    end;
    MatRowPut(IVr,rw,IVrw);
    IVVc_PastePrice(IVr,IV2r,rw,warning);
    if (nonblank(itemname)) then begin
      MatRowGet(IVr,rw,IVrw);
      IVrw.Spec = itemname;
      MatRowPut(IVr,rw,IVrw);
    end;

    if (chargetype!=17) then begin
      if (FindCredManAcc(CredManr,CMAr)) then begin
        rwcnt = MatRowCnt(CMAr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(CMAr,i,CMArw);
          if (CMArw.ArtCode==IVrw.ArtCode) then begin
            MatRowGet(IVr,rw,IVrw);
            IVrw.PeriodCode = CMArw.PeriodCode;
            MatRowPut(IVr,rw,IVrw);
            i = rwcnt;
          end;
        end;
      end;
    end;
  end;

  return;
end;

global
function Boolean InvoiceHasHiddenLine(record IVVc IVr)
begin
  Integer i,rwcnt;
  row IVVc IVrw;
  Boolean res;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVrw.stp==kInvoiceRowTypeHidden) then begin
      res = true;
      i = rwcnt;
    end;
  end;

  InvoiceHasHiddenLine = res;
  return;
end;

procedure AddOverdueComments(var record IVVc IVr,array string lateformula)
begin
  Integer i,rwcnt;
  Boolean hiddenf;
  row IVVc IVrw,hiddenIVrw;
  
  if (!InvoiceHasHiddenLine(IVr)) then begin
    ClearRow(IVr,hiddenIVrw,kInvoiceRowTypeHidden);
    MatRowPut(IVr,MatRowCnt(IVr),hiddenIVrw);
  end;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<lateformula.length;i=i+1) begin
    ClearRow(IVr,IVrw,1);
    IVrw.Spec = lateformula[i];
    MatRowPut(IVr,rwcnt,IVrw);
    rwcnt = rwcnt + 1;
  end;

  return;
end;

procedure SetOverdueLangCode(var record IVVc IVr, record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  row IVVc IVrw;
  integer i,rwcnt;
  boolean overflag,invwithovd,agrchanginv;
  record CredManSetBlock CMb;
  string 20 reslang;
  record CMInvoicingBlock CIb;
  
  blockload(CMb);
  blockload(CIb);
    
  rwcnt = matrowcnt(IVr);
  for(i=0;i<rwcnt;i=i+1)begin
    matrowget(IVr,i,IVrw);
    if(IVrw.ArtCode==CMb.LateFeeItem)then begin
      overflag = true;
    end;
    if(nonblank(IVrw.ArtCode) and IVrw.ArtCode!=CMb.LateFeeItem and IVrw.stp==1 and IVrw.Sum>0)then begin
      invwithovd = true;
    end;
    if(nonblank(IVrw.ArtCode) and IVrw.ArtCode==CIb.ProlongItem)then begin
      agrchanginv = true;
    end;
  end;
  
  if(overflag)then begin
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      if(overflag)then begin
        if(nonblank(CMTr.OverdueLangCode))then begin
          IVr.LangCode = CMTr.OverdueLangCode;
        end;
        if(getAdditionalLangCode(CredManr,"OverdueLangCode",reslang))then begin
          IVr.LangCode = reslang;
        end;
        
        if(invwithovd)then begin
          if(nonblank(CMTr.InvOverdLangCode))then begin
            IVr.LangCode = CMTr.InvOverdLangCode;
          end;
          if(getAdditionalLangCode(CredManr,"InvOverdLangCode",reslang))then begin
            IVr.LangCode = reslang;
          end;
        end;
        if(agrchanginv)then begin
          if(nonblank(CMTr.AgreChangeLangCode))then begin
            IVr.LangCode = CMTr.AgreChangeLangCode;
          end;
          if(getAdditionalLangCode(CredManr,"AgreChangeLangCode",reslang))then begin
            IVr.LangCode = reslang;
          end;
        end;
      end;
    end;
  end else begin
    if(agrchanginv)then begin
      if(nonblank(CMTr.AgreChangeLangCode))then begin
        IVr.LangCode = CMTr.AgreChangeLangCode;
      end;
      if(getAdditionalLangCode(CredManr,"AgreChangeLangCode",reslang))then begin
        IVr.LangCode = reslang;
      end;
    end;
  end;
    
return;
end;

global
procedure SetupOverdueLangCode(var record IVVc IVr,record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  Boolean serf;
  record CMInvoicingBlock CIb;
  string 20 reslang;

  CMTr.Code = CredManr.Type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if (CredManr.UseCompensationInvoices==1) then begin
      if (nonblank(CMTr.CompensLangCode)) then begin
        IVr.LangCode = CMTr.CompensLangCode;
      end;
      if(getAdditionalLangCode(CredManr,"CompensLangCode",reslang))then begin
        IVr.LangCode = reslang;
      end;
    end else begin
      if (nonblank(CMTr.OverdueLangCode)) then begin
        IVr.LangCode = CMTr.OverdueLangCode;
      end;
      if(getAdditionalLangCode(CredManr,"OverdueLangCode",reslang))then begin
        IVr.LangCode = reslang;
      end;
    end;
  end;
  BlockLoad(CIb);
  if (nonblank(CIb.OverduePayTerm)) then begin
    IVr.PayDeal = CIb.OverduePayTerm;
    IVVc_PastePayDeal2(IVr,"","",serf);
  end;  
  return;
end;

global
procedure SetupBuyoutLangCode(var record IVVc IVr,record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  string 20 reslang;

  CMTr.Code = CredManr.Type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if (nonblank(CMTr.BuyOutLangCode)) then begin
      IVr.LangCode = CMTr.BuyOutLangCode;
    end;
    if(getAdditionalLangCode(CredManr,"BuyOutLangCode",reslang))then begin
      IVr.LangCode = reslang;
    end;
  end;

  return;
end;



global
procedure AddLateFees(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Integer latedays,val lateamount,array string lateformula)
begin
  val laterate;
  record CMInvoicingBlock CIb;
  Boolean addf;
  record CredManTypeVc CMTr;
  string 255 item;
  transaction Boolean gIsBuyOutInvoice; 
  
  if (lateamount>0) then begin
    addf = true;
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      if (CMTr.MinOverdueFee>0 and lateamount<CMTr.MinOverdueFee) then begin
        addf = false;
      end;
    end;
    if (addf or gIsBuyOutInvoice) then begin
      BlockLoad(CIb);
      item = CMb.LateRateItem;
      if (CredManr.UseCompensationInvoices==1) then begin
        item = CIb.CompensationItem;
      end;
      //SetupInvoiceRowAndAdd(CredManr,IVr,CMb.LateFeeItem,"",1,0,0,kEventTypeIssueLateFees,-1);
      SetupInvoiceRowAndAdd(CredManr,IVr,item,"",1,lateamount,0,kEventTypeIssueLateFees,-1);
      BlockLoad(CIb);
      if (CIb.AddOverdueDetails==1) then begin
        AddOverdueComments(IVr,lateformula);
      end;
    end;
  end;

  return;
end;

function Integer GetMonthDays(Date td)
begin
  Integer res;

  res = DaysInMonth(GetYear(td),GetMonth(td));

  GetMonthDays = res;
  return;
end;

function Longint GetCredManLateFees(record CredManVc CredManr,Date sd,Date ed)
begin
  Boolean TrHs,testf;
  record CredManChangeVc Changer;
  Longint res;

  res = CredManr.LateFeeDays;

  TrHs = true;
  Changer.CredManNr = CredManr.SerNr;
  while (LoopKey("CredManDate",Changer,1,TrHs)) begin
    if (Changer.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      testf = false;
      if (Changer.OKFlag==1 and Changer.LateFeeDays>-1) then begin
        if (DateInRange(sd,Changer.TransDate,Changer.EndDate)) then begin
          testf = true;
        end;
        if (DateInRange(ed,Changer.TransDate,Changer.EndDate)) then begin
          testf = true;
        end;
        if (testf) then begin
          res = Changer.LateFeeDays;
          TrHs = false;
        end;
      end;
    end;
  end;

  GetCredManLateFees = res;
  return;
end;

procedure GetLatePaymentPlan(record CredManVc CredManr,record CredHistVc CredHistr,Date sd,Date temped,Date overduetd,var array val amounts,var array Integer daycnt,var array string period)
begin
  Date tempsd,tempsd2;
  record CredHistVc CredPayr;//CredPayr - same credhistvc register, just for payments
  Integer i,daydiff,daydiff2,daydiff3;
  Boolean TrHs;
  val paysum;
  Longint latefeedays;
  record CMInvoicingBlock CMIb;
  date ed,df;
  string 100 newperiod;
  record IVVc IVr;
  record CMApplicationSetBlock CMAb;
  record CMBuyOutBlock CMBOb;
  transaction Boolean gPaymentProcedure;
  transaction Boolean gIsBuyOutInvoice; 
  
  blockload(CMIb);
  blockload(CMAb);
  blockload(CMBOb);
    
  ed = temped;
  /*if(CMIb.NewCalcForGrace==1)then begin
    if(ed>=currentdate)then begin
      ed = addday(ed,-1);
    end;
  end;*/
  
  if(gPaymentProcedure or gIsBuyOutInvoice)then begin
    if(gPaymentProcedure)then begin
      if(CMAb.BuyOutInclPaymDay==1)then begin
        ed = addday(ed,1);
      end;
    end;
    if(gIsBuyOutInvoice)then begin
      if(CMBOb.CalcOvdBOday==0)then begin
        ed = addday(ed,-1);
      end;
    end;
  end else begin
    if(CMAb.OvdInclInvDay==0)then begin
      ed = addday(ed,-1);
    end;
  end;
    
  paysum = CredHistr.Sum;
  tempsd = sd;//this is the start date when this item should have been paid since
  if (nonblank(overduetd)) then begin
    tempsd = overduetd;
  end;
  if (tempsd<=CredHistr.PayDate) then begin
    tempsd = AddDay(CredHistr.PayDate,1);
  end;
  tempsd2 = tempsd;

  /*
  if (CredManr.LateFeeDays>0) then begin
    tempsd = AddDay(tempsd,CredManr.LateFeeDays);
  end;
  */

  latefeedays = GetCredManLateFees(CredManr,tempsd,tempsd);

  ClearArray(amounts);
  ClearArray(period);
  TrHs = true;
  CredPayr.PreviousNr = CredHistr.SerNr;
  while (LoopKey("PreviousNr",CredPayr,1,TrHs)) begin
    if (CredPayr.PreviousNr!=CredHistr.SerNr) then begin
      TrHs = false;
    end else begin
      if (CredPayr.TransDate>CredHistr.PayDate) then begin
        if (CredPayr.TransDate>tempsd and CredPayr.TransDate<=ed) then begin
          daydiff = DateDiff(CredPayr.TransDate,tempsd)+1;//or DateDiff2 to get daydiff+1 days
          daydiff2 = DateDiff(CredPayr.TransDate,CredHistr.PayDate);//or DateDiff2 to get daydiff+1 days
          
          daydiff3 = daydiff;
          df = CredPayr.TransDate;
          if(true/*CMIb.NewCalcForGrace==1*/)then begin
            if(addday(CredHistr.PayDate,latefeedays+1)>=addday(CredPayr.TransDate,-daydiff+1))then begin
                daydiff3 = daydiff2;
                df = CredPayr.TransDate;
            end;
          end;
          if (latefeedays<daydiff2) then begin
            for (i=0;i<daydiff3;i=i+1) begin
              amounts[amounts.length] = paysum;
              daycnt[daycnt.length] = GetMonthDays(AddDay(tempsd,i));
              period[period.length] = addday(df,-daydiff3+1) & " - " & df;
            end;
          end;
        end;
        if (CredPayr.TransDate>ed) then begin//no need to continue for later payments
          TrHs = false;
        end else begin
          if (tempsd<CredPayr.TransDate) then begin
            tempsd = AddDay(CredPayr.TransDate,1);
          end;
        end;
      end;
      if (CredPayr.TransDate<=ed) then begin
        paysum = paysum - CredPayr.Sum;
      end;
    end;
  end;
  
  /*if(CMIb.StartDateForOverdue==1)then begin// not work correct
    IVr.SerNr = CredHistr.RecordNr;
    if(readfirstmain(IVr,1,true))then begin
      if(IVr.PayDate<sd)then begin
        tempsd = sd;
      end;
    end;
  end;*/
  
  if (paysum>0 and tempsd<=ed) then begin
    daydiff = DateDiff(ed,tempsd)+1;
    daydiff2 = DateDiff(ed,CredHistr.PayDate);
    
    daydiff3 = daydiff;
    df = ed;
    if(true/*CMIb.NewCalcForGrace==1*/)then begin
      if(CredManr.LateFeeDays>daydiff2-daydiff)then begin
        daydiff3 = daydiff2;
        df = ed;
      end;   
    end; 
    
    if (latefeedays<=daydiff2) then begin// Changed < to <=  // Edit ************************** BPI Ukraine - KramarAlexandr - 05, 04 03 2022 y. at 12:22:27 PM
      for (i=0;i<daydiff3;i=i+1) begin
        amounts[amounts.length] = paysum;
        daycnt[daycnt.length] = GetMonthDays(AddDay(tempsd,i));
        period[period.length] = addday(df,-daydiff3+1) & " - " & df;
      end;
    end;
  end;
  return;
end;


function string 255 replaceOverdueStr(string InvNo, val Value, string Period, integer Days,string Rate, val RowSum)
begin
  record OverdueCalcTextVc OCTr;
  string 255 tstr,txInvNo,txValue,txPeriod,txDays,txRate,txRowSum;
  
  OCTr.Code = "OCTXT";
  readfirstmain(OCTr,1,true);

  txValue = Value;
  if(Value==0)then begin
    txValue = "0.00";
  end;

  txRowSum = RowSum;
  if(RowSum==0)then begin
    txRowSum = "0.00";
  end;
  
  tstr = LineTextGet2(OCTr,0);
  tstr = StrReplace(tstr,"?InvNo?",InvNo);
  tstr = StrReplace(tstr,"?Value?",txValue);
  tstr = StrReplace(tstr,"?Period?",Period);
  tstr = StrReplace(tstr,"?Days?",Days);
  tstr = StrReplace(tstr,"?Rate?",Rate);
  tstr = StrReplace(tstr,"?RowSum?",txRowSum);
  
  replaceOverdueStr = tstr;
return;
end;


global
procedure CheckOverdueInvoicesForItem(record CredManVc CredManr,record CredManSetBlock CMb,val maxmonths,Date invdate,Date prevtd,var Integer latedays,var val lateamount,string item,Date overduetd,var array string lateformula,Integer ratetype)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  array val amounts;
  array Integer daycnt;
  val latefee;
  Integer i,odays,lastdaycnt;
  val overdueprc,lastamount;
  Date mindate;
  record OverdueCalcTextVc OCTr;
  string 255 tstr,rate,invoicenr,lastperiod;
  val rowsum;
  record IVVc IVr;
  array string 30 periods;
  record CMInvoicingBlock CMIb;
  
  blockload(CMIb);
  
  OCTr.Code = "OCTXT";
  readfirstmain(OCTr,1,true);
  
  if (maxmonths>0) then begin
    mindate = AddMonth(invdate,-maxmonths);
  end;
  
  if(nonblankdate(CMIb.OverdueFrom))then begin
    if(mindate<CMIb.OverdueFrom)then begin
      mindate = CMIb.OverdueFrom;
    end;
  end;
  
  overdueprc = CredManr.OverduePercentage;
  if (CredManr.AnnualRate==1) then begin
    //overdueprc = overdueprc/12; overdues should not be affected by annual
  end;
  TrHs = true;
  CredHistr.ArtCode = item;
  CredHistr.CredManNr = CredManr.SerNr;
  while (LoopKey("ArtCode",CredHistr,2,TrHs)) begin
    if (CredHistr.ArtCode!=item or CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      if (blank(mindate) or CredHistr.TransDate>=mindate) then begin
        //Construct an array of days with amount that is over due starting with the first day of period
        GetLatePaymentPlan(CredManr,CredHistr,prevtd,invdate,overduetd,amounts,daycnt,periods);
        lastamount = 0;
        odays = 0;
        lastperiod = "";
        for (i=0;i<amounts.length;i=i+1) begin
          if (ratetype==0) then begin //as default
            latefee = latefee + (amounts[i]*(overdueprc/100));
          end else begin
            latefee = latefee + (amounts[i]*(overdueprc/100)/lastdaycnt);
          end;
          if ((lastamount!=amounts[i] and lastamount>0) or (ratetype==1 and lastdaycnt!=daycnt[i])) then begin
            if (ratetype==0) then begin //as default
              if(CMIb.OvdRoundOptions==1)then begin
                latefee = round(latefee,defaultcurroundoff);
                rowsum = round(lastamount*(overdueprc/100) * odays,defaultcurroundoff);
              end else begin
                rowsum = lastamount*(overdueprc/100) * odays;
              end;
              rate = ValToString((overdueprc/100),M45Val,"",",",0);
              tstr = odays & " Days " &  " - " & item & " - " & lastamount & " * " & rate & "=" & rowsum;
              if(OCTr.UseNewCalc==1)then begin
                invoicenr = "";
                
                if(CredHistr.RecordType==0)then begin
                  if(CredHistr.RecordNr>-1)then begin
                    IVr.SerNr = CredHistr.RecordNr;
                    if(readfirstmain(IVr,1,true))then begin
                      invoicenr = IVr.OfficialSerNr;
                      if(blank(invoicenr))then begin
                        invoicenr = IVr.SerNr;
                      end;
                    end;
                  end;
                end;
                if(CMIb.OvdRoundOptions==1)then begin
                  latefee = round(latefee,defaultcurroundoff);
                  rowsum = round(lastamount*(overdueprc/100) * odays,defaultcurroundoff);
                end else begin
                  rowsum = lastamount*(overdueprc/100) * odays;
                end;
                
                tstr = replaceOverdueStr(invoicenr,lastamount,lastperiod,odays,rate,rowsum);
              end;
              lateformula[lateformula.length] = tstr;
            end else begin
              invoicenr = "";
              if(CredHistr.RecordType==0)then begin
                if(CredHistr.RecordNr>-1)then begin
                  IVr.SerNr = CredHistr.RecordNr;
                  if(readfirstmain(IVr,1,true))then begin
                    invoicenr = IVr.OfficialSerNr;
                    if(blank(invoicenr))then begin
                        invoicenr = IVr.SerNr;
                      end;
                  end;
                end;
              end;
              if(CMIb.OvdRoundOptions==1)then begin
                latefee = round(latefee,defaultcurroundoff);
                rowsum = round(lastamount * odays*(overdueprc/100)/lastdaycnt,defaultcurroundoff);
              end else begin
                rowsum = lastamount * odays*(overdueprc/100)/lastdaycnt;
              end;
              rate = ValToString((overdueprc/100),M45Val,"",",",0);
              tstr = odays & " Days " &  " - " & item & " - " & lastamount & " * " & rate & "/" & lastdaycnt & "=" & rowsum;
              if(OCTr.UseNewCalc==1)then begin
                tstr = replaceOverdueStr(invoicenr,lastamount,lastperiod,odays,rate,rowsum);
              end;
              lateformula[lateformula.length] = tstr;
            end;
            odays = 0;
          end;
          odays = odays + 1;
          lastamount = amounts[i];
          lastdaycnt = daycnt[i];
          lastperiod = periods[i];
        end;
        if (odays>0) then begin
          if (ratetype==0) then begin //as default
            invoicenr = "";
            if(CredHistr.RecordType==0)then begin
              if(CredHistr.RecordNr>-1)then begin
                IVr.SerNr = CredHistr.RecordNr;
                if(readfirstmain(IVr,1,true))then begin
                  invoicenr = IVr.OfficialSerNr;
                  if(blank(invoicenr))then begin
                    invoicenr = IVr.SerNr;
                  end;
                end;
              end;
            end;
            if(CMIb.OvdRoundOptions==1)then begin
              latefee = round(latefee,defaultcurroundoff);
              rowsum = round((lastamount*(overdueprc/100) * odays),defaultcurroundoff);
            end else begin
              rowsum = (lastamount*(overdueprc/100) * odays);
            end;
            
            rate = ValToString((overdueprc/100),M45Val,"",",",0);
            tstr = odays & " Days " &  " - " & item & " - " & lastamount & " * " & rate & "=" & rowsum;
            if(OCTr.UseNewCalc==1)then begin
              tstr = replaceOverdueStr(invoicenr,lastamount,lastperiod,odays,rate,rowsum);
            end;
            lateformula[lateformula.length] = tstr;
          end else begin
            invoicenr = "";
            if(CredHistr.RecordType==0)then begin
              if(CredHistr.RecordNr>-1)then begin
                IVr.SerNr = CredHistr.RecordNr;
                if(readfirstmain(IVr,1,true))then begin
                  invoicenr = IVr.OfficialSerNr;
                  if(blank(invoicenr))then begin
                    invoicenr = IVr.SerNr;
                  end;
                end;
              end;
            end;
            if(CMIb.OvdRoundOptions==1)then begin
              latefee = round(latefee,defaultcurroundoff);
              rowsum = round((lastamount * odays*(overdueprc/100)/lastdaycnt),defaultcurroundoff);
            end else begin
              rowsum = (lastamount * odays*(overdueprc/100)/lastdaycnt);
            end;
            
            rate = ValToString((overdueprc/100),M45Val,"",",",0);
            tstr = odays & " Days " &  " - " & item & " - " & lastamount & " * " & rate & "/" & lastdaycnt & "=" & rowsum;
            if(OCTr.UseNewCalc==1)then begin
              tstr = replaceOverdueStr(invoicenr,lastamount,periods[i],odays,rate,rowsum);
            end;
            lateformula[lateformula.length] = tstr;
          end;
        end;
      end;
    end;
  end;

  lateamount = lateamount + latefee;

  return;
end;

procedure GetInvoiceEndPeriod(Longint ivnr, var date res, var date intres)
begin
  record IVVc IVr;
  row IVVc IVrw;
  integer rwcnt,i;
  boolean foundf;
  record CredHistVc CredHistr;
  
  IVr.SerNr = ivnr;
  if (ReadFirstMain(IVr,1,true)) then begin
    res = IVr.CredToDate;
    intres = IVr.InvDate;
  end;
  
  rwcnt = matrowcnt(IVr);
  
  CredHistr.RecordNr = IVr.SerNr;
  CredHistr.RecordType = 0;
  if(readfirstkey("RecordNr",CredHistr,2,true))then begin
    if(nonblankdate(CredHistr.CredToDate))then begin
      intres = CredHistr.CredToDate;
    end;
  end;
  
  if (blank(res)) then begin
    res = IVr.InvDate;
  end;
  
  //GetInvoiceEndPeriod = res;
  return;
end;

procedure GetLastOverdueInvoiceDate(Longint sernr,string item,var date res,var date intres)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  Date td,td1;
  record CMApplicationSetBlock CMAb;
  transaction Boolean gPaymentProcedure;
  
  blockload(CMAb);

  TrHs = true;
  CredHistr.CredManNr = sernr;
  CredHistr.ChargeType = 9;
  while (LoopKey("CredManChargeType",CredHistr,2,TrHs)) begin
    if (CredHistr.ChargeType!=9 or CredHistr.CredManNr!=sernr) then begin
      TrHs = false;
    end else begin
      GetInvoiceEndPeriod(CredHistr.RecordNr,td,td1);
      if (td>res) then begin
        res = td;
      end;
      if (td1>intres) then begin
        intres = td1;
      end;
    end;
  end;
  
  if(!gPaymentProcedure)then begin
    if(CMAb.OvdInclInvDay==1)then begin
      if (nonblank(res)) then begin
        res = AddDay(res,1);
      end;
      if (nonblank(intres)) then begin
        intres = AddDay(intres,1);
      end;
    end;
  end;

  //GetLastOverdueInvoiceDate = res;
  return;
end;

global
function Integer GetRateType(record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  record CMInvoicingBLock CIb;
  Integer res;

  res = -1;
  
  if (CredManr.OverdueRateType>0) then begin
    res = CredManr.OverdueRateType - 1;
  end else begin
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      if (CMTr.OverdueRateType>0) then begin
        res = CMTr.OverdueRateType - 1;
      end;
    end;
  end;
  if (res==-1) then begin
    BlockLoad(CIb);
    res = CIb.OverdueRateType;
  end;

  GetRateType = res;
  return;
end;

global
procedure GetCredManOverdueInvoices2(record CredManVc CredManr,record CredManSetBlock CMb,Date originvdate,Date prevtd,var Integer latedays,var val lateamount,var val lateprincipal,var val lateinterest,var array string lateformula,Boolean paidf,Boolean ignorelastoverduef,var Date calcsd)
begin
  record CMInvoicingBlock CIb;
  record INVc INr;
  Date overduetd,temp_td,intlastdate;
  record CUVc CUr;
  Integer ratetype;
  vector boolean useditems;
  integer notusedlatedays;
  array string 255 notusedlateformula;
  date invdate;
  record CMApplicationSetBlock CMAb;
  transaction Boolean gPDRAfterReciept;
  
  invdate = originvdate;
  /*if(gPDRAfterReciept and invdate>=currentdate)then begin
    blockload(CMAb);//Off CM -> Settings -> Credit Management settings -> checkbox "Include payment day in overdue calculation" performance
    if(CMAb.BuyOutInclPaymDay==1)then begin
      invdate = addday(invdate,1);
    end;
  end;*/
  
  ClearStringArray(lateformula);
  latedays = 0;
  lateamount = 0;
  CUr.Code = CredManr.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin
    if (CUr.InterestFlag==1 and CredManr.SkipOverDue==0) then begin
      BlockLoad(CIb);
      temp_td = prevtd;
      if (!paidf) then begin
        temp_td = AddDay(temp_td,1);
      end;

      if (ignorelastoverduef==false) then begin
        GetLastOverdueInvoiceDate(CredManr.SerNr,CMb.LateFeeItem,overduetd,intlastdate);
      end;
      
      if(CIb.StartDateForOverdue==0)then begin
        intlastdate = overduetd;
      end;
      
      if (nonblank(overduetd)) then begin
        calcsd = overduetd;
      end else begin
        calcsd = prevtd;
      end;
      //we should go through the history and check for late payments
      ratetype = GetRateType(CredManr);
      if (nonblank(CIb.OverdueItemClass)) then begin
        while (LoopKey("DICode:" & CIb.OverdueItemClass,INr,1,true)) begin
          if(useditems[INr.Code]==false)then begin
            useditems[INr.Code] = true;
            CheckOverdueInvoicesForItem(CredManr,CMb,CIb.OverdueMonths,invdate,prevtd,latedays,lateamount,INr.Code,intlastdate,lateformula,ratetype);
          end;
        end;
      end;
      if (nonblank(CMb.RateItem)) then begin
        INr.Code = CMb.RateItem;
        if (ReadFirstMain(INr,1,true)) then begin
            CheckOverdueInvoicesForItem(CredManr,CMb,CIb.OverdueMonths,invdate,prevtd,notusedlatedays,lateinterest,INr.Code,intlastdate,notusedlateformula,ratetype);
          end;
        end;
      if (nonblank(CMb.InstalmentItem)) then begin
        INr.Code = CMb.InstalmentItem;
        if (ReadFirstMain(INr,1,true)) then begin
            CheckOverdueInvoicesForItem(CredManr,CMb,CIb.OverdueMonths,invdate,prevtd,notusedlatedays,lateprincipal,INr.Code,intlastdate,notusedlateformula,ratetype);//was overduetd
        end;
      end;
    end;
  end;
  
  
  logforadmin(0,"lateamount " & lateamount);
  
  return;
end;

global
procedure GetCredManOverdueInvoices(record CredManVc CredManr,record CredManSetBlock CMb,Date invdate,Date prevtd,var Integer latedays,var val lateamount,var array string lateformula,Boolean paidf,Boolean ignorelastoverduef,var Date calcsd)
begin
  val lateprincipal,lateinterest;
  
  GetCredManOverdueInvoices2(CredManr,CMb,invdate,prevtd,latedays,lateamount,lateprincipal,lateinterest,lateformula,paidf,ignorelastoverduef,calcsd);
  return;
end;

global
procedure MergeItemsInInvoice(var record IVVc IVr,record CredManVc CredManr)
begin
  Integer i,rwcnt,chargetype;
  row IVVc IVrw;
  vector val vRows;
  array string 255 arr;
  val quant,reb;
  Longint pos,factinv;
  string 255 index,tstr,item,spec;
  vector string 255 vSpec;

  
  rwcnt = MatRowCnt(IVr);
  for (i=rwcnt-1;i>=0;i=i-1) begin
    MatRowGet(IVr,i,IVrw);
    if (nonblank(IVrw.ArtCode)) then begin
      index = IVrw.ArtCode & "|" & IVrw.Quant & "|" & IVrw.vRebate & "|" & IVrw.ChargeType & "|" & IVrw.FactoringInvoice & "|" & IVrw.Spec;
      vSpec[IVrw.Spec] = IVrw.Spec;
      vRows[index] = vRows[index] + IVrw.Price;
      MatRowDelete(IVr,i);
    end;
  end;
  GetVectorTags(vRows,arr);
  for (i=0;i<arr.length;i=i+1) begin
    pos = -1;
    GetNextSubstring(arr[i],pos,"|",item);
    GetNextSubstring(arr[i],pos,"|",tstr);
    quant = StringToVal(tstr,M4Val);
    GetNextSubstring(arr[i],pos,"|",tstr);
    reb = StringToVal(tstr,M4Val);
    GetNextSubstring(arr[i],pos,"|",tstr);
    chargetype = StringToInt(tstr);
    GetNextSubstring(arr[i],pos,"|",tstr);
    factinv = StringToLongint(tstr);
    GetNextSubstring(arr[i],pos,"|",spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,item,vSpec[spec],quant,vRows[arr[i]],reb,chargetype,factinv);
  end;

  return;
end;

function Boolean GetNextInvoicableDate(var Date td,var Date prevtd,Date ed,record CredManVc CredManr)
begin
  Boolean res;
  
  prevtd = td;
  td = AddMonth(td,1);
  td.Day = DaysInMonth(td.Year,td.Month);
  if (td<=ed and td<=CredManr.endDate) begin //deal with all the other invoices
    res = true;
  end;

  GetNextInvoicableDate = res;
  return;
end;

function Boolean PMCodeMatches(record CredManVc CredManr,Longint cupnr)
begin
  Boolean res;
  record IPVc IPr;
  record ARPayHistVc ARPayHistr;
    
  ARPayHistr.CUPNr = cupnr;
  ARPayHistr.FileName = "IPVc";
  if (ReadFirstKey("MainKey",ARPayHistr,2,true)) then begin
    IPr.SerNr = ARPayHistr.SerNr;
    if (ReadFirstMain(IPr,1,true)) then begin
      if (CredManPMCodeMatches2(IPr.PayMode,CredManr,true)) then begin
        res = true;
      end;
    end else begin
      res = true;
    end;
  end else begin
    res = true;
  end;

  PMCodeMatches = res;
  return;
end;

global
procedure CM_AddPrepayments(var record IVVc IVr,record CredManVc CredManr,record CMInvoicingBlock CIb)
begin
  record ARPayVc ARPayr;
  val remval;
  Boolean TrHs;
  row IVVc IVrw;
  record IVVc IV2r;
  string 255 warning;
  Boolean chsum;
  
  if (CIb.AddPrepayments) then begin
    remval = IVr.Sum4;
    TrHs = true;
    ARPayr.CustCode = IVr.CustCode;
    while (LoopKey("CustCode",ARPayr,1,TrHs) and remval>0) begin
      if (ARPayr.CustCode!=IVr.CustCode) then begin
        TrHs = false;
      end else begin
        if (ARPayr.PayDate<=IVr.TransDate) then begin
          if (PMCodeMatches(CredManr,ARPayr.CUPNr)) then begin
            ClearRow(IVr,IVrw,kInvoiceRowTypePrepayment);
            IVrw.Spec = USetStr(1288);
            IVrw.CUPNr = ARPayr.CUPNr;
            PasteARPayInIV(IVr,IVrw,-1);
            MatRowInsert(IVr,0,IVrw);
            if IVVc_PasteSum(IVr,0,chsum,1) then begin 
              if (chsum) then begin
                IVDchsum(IVr,0);
              end;
            end;  
            remval = remval - IVrw.BasePrice;
          end;
        end;
      end;
    end;
  end;

  return;
end;

global
updating procedure StoreLoanInvoice(var record IVVc IVr,record CredManVc CredManr)
begin
  record IVVc oldIVr;
  transaction Boolean gPDRAfterReciept;
  
  SetOverdueLangCode(IVr,CredManr);
  
  if (IVr.Sum4>0) then begin
    IVr.SerNr = NextSerNr("IVVc",IVr.InvDate,-1,false,"");
    if (RecordInsert(IVr,true)) then begin
      RecordCopy(oldIVr,IVr);
      IVr.OKFlag = 1;
      LinkCredManAndInvoice(IVr,CredManr);
      if (RecordUpdate(oldIVr,IVr,true)==0) then begin
        if(gPDRAfterReciept==false)then begin
          CreateInvoicePdfFile(IVr);
        end;
      end;
    end;
  end;

  return;
end;

global
procedure CheckAndAddHiddenPrinciple(var record IVVc IVr,record CMInvoicingBlock CIb)
begin
  row IVVc IVrw,hiddenIVrw;
  Integer i,rwcnt;
  Boolean foundf;
  
  if (CIb.HiddenPrinciple==1) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.ChargeType>0 and IVrw.ChargeType!=kEventTypeCalcInstalment) then begin
        foundf = true;
        i = rwcnt;
      end;
    end;
    if (foundf) then begin
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        if (IVrw.ChargeType==kEventTypeCalcInstalment) then begin
          MatRowDelete(IVr,i);
          if (InvoiceHasHiddenLine(IVr)==false) then begin
            ClearRow(IVr,hiddenIVrw,kInvoiceRowTypeHidden);
            MatRowPut(IVr,MatRowCnt(IVr),hiddenIVrw);
          end;
          MatRowPut(IVr,MatRowCnt(IVr),IVrw);
          goto LCheckAndAddHiddenPrinciple;
        end;
      end;
    end;
  end;

LCheckAndAddHiddenPrinciple:;
  return;
end;

function val GetPaidAmountRatio(record CredManVc CredManr,Date td)
begin
  val res;
  record OPrsVc OPrsr;
  Boolean TrHs;
  val paid;
  
  res = 1;

  if (CredManr.VINr>0) then begin
    OPrsr.TransType = kOPrsTransTypePayment;
    OPrsr.TransDate = CredManr.startDate;
    OPrsr.VINr = CredManr.VINr;
    TrHs = true;
    while (LoopKey("VIKey",OPrsr,3,TrHs)) begin
      if (OPrsr.TransDate>td or OPrsr.VINr!=CredManr.VINr or OPrsr.TransType!=kOPrsTransTypePayment) then begin
        TrHs = false;
      end else begin
        paid = paid + FindInvoicePaidAmount_OP(OPrsr.VINr,OPrsr.TransNr);
      end;
    end;
    res = paid/CredManr.InvSum4;
    
  end;

  GetPaidAmountRatio = res;
  return;
end;

global
function Integer GetInterestPaymentType(record CredManVc CredManr)
begin
  record CMInvoicingBlock CIb;
  record CredManTypeVc CMTr;
  Integer res;

  res = CredManr.RealInterestFlag-1;
  if (res==-1) then begin
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      res = CMTr.RealInterestFlag-1;
    end;
  end;

  if (res==-1) then begin
    BlockLoad(CIb);
    res = CIb.RealInterestFlag;
  end;
  GetInterestPaymentType = res;
  return;
end;

function Boolean CanInvoiceDate(record CredManVc CredManr,Date td,Boolean allf,Boolean startfullf)
begin
  Boolean res;
  
  if (allf) then begin
    res = true;
  end;

  if (!allf and !startfullf) then begin
    if (td<CredManr.FirstInvDate) then begin
      res = true;
    end;
  end;

  CanInvoiceDate = res;
  return;
end;  

updating procedure CreateInvoicesFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date ed,var record IVVc firstIVr,string ivno,Boolean manualf,Boolean allf)
begin
  Integer i,rwcnt,rwcnt2,j;
  row CredManPayPlanVc CredManPayPlanrw;
  Date lastd,lastd2;
  record IVVc IVr,oldIVr,oIVr,tmpIVr;
  row IVVc IVrw;
  Boolean firstf,startfullf;
  Integer latedays;
  val lateamount;
  record CMInvoicingBlock CIb;
  array string 255 lateformula;
  Date calcsd;
  
  BlockLoad(CIb);
  lastd2 = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (nonblank(CredManPayPlanrw.FromDate)) then begin
      startfullf = true;
    end;
    if (CredManPayPlanrw.PlanType<=4 and CredManPayPlanrw.TransDate<=ed and CanInvoiceDate(CredManr,CredManPayPlanrw.TransDate,allf,startfullf)) then begin
      if (lastd!=CredManPayPlanrw.TransDate) then begin
        //Setup new invoice
        if (nonblank(lastd)) then begin
          //if (IVr.InvDate==CredManr.startDate) then begin
            MergeItemsInInvoice(IVr,CredManr);
          //end;
          if (CredManCanInvoiceOverdues(CredManr)) then begin
            GetCredManOverdueInvoices(CredManr,CMb,lastd,lastd2,latedays,lateamount,lateformula,false,false,calcsd);
            switch (CIb.OverdueIVType) begin
              case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
              case 1: 
                SetupLoanInvoice(CredManr,CMb,oIVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno,2,true);
                SetupOverdueLangCode(oIVr,CredManr);
                AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
                StoreLoanInvoice(oIVr,CredManr);
              case 2:
                if (nonblank(CredManr.CancelDate)) then begin
                  SetupLoanInvoice(CredManr,CMb,oIVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno,2,true);
                  SetupOverdueLangCode(oIVr,CredManr);
                  AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
                  StoreLoanInvoice(oIVr,CredManr);
                end;
            end;
          end;
          CM_AddPrepayments(IVr,CredManr,CIb);
          if (IVr.SerNr>-1) then begin
            CheckAndAddHiddenPrinciple(IVr,CIb);
            if (manualf) then begin
              IVr.ManualInvoice = 1;
            end;
            StoreLoanInvoice(IVr,CredManr);
            //if (firstf==false) then begin
              RecordCopy(firstIVr,IVr);
            //  firstf = true;
            //end;
          end else begin
            logforadmin(0,"Failed to store Invoice. No Serial Number. Check Number Series. Not continuing to generate invoices");  
            goto lout;    
          end;
        end;
        lastd2 = AddDay(lastd,1);//to get the start date for penalty calculation.
        lastd = CredManPayPlanrw.TransDate;
        SetupLoanInvoice(CredManr,CMb,IVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno,GetInvoiceType(CredManr,lastd),true);

      end;
/* not needed. this is done when creating the actual plan
      if (CredManPayPlanrw.PlanType==kEventTypeCalcInterest) then begin
        if (CredManr.RealInterestFlag==1) then begin
          CredManPayPlanrw.Sum = CredManPayPlanrw.Sum*GetPaidAmountRatio(CredManr,IVr.InvDate);
        end;
      end;
*/
      if (CredManPayPlanrw.ToDate>IVr.CredToDate) then begin
        RecordCopy(tmpIVr,IVr);
        SetupLoanInvoice(CredManr,CMb,IVr,lastd,IVr.CredFromDate,CredManPayPlanrw.ToDate,true,false,ivno,GetInvoiceType(CredManr,lastd),true);
        rwcnt2 = MatRowCnt(tmpIVr);
        for (j=0;j<rwcnt2;j=j+1) begin
          MatRowGet(tmpIVr,j,IVrw);
          if (IVrw.Quant>0) then begin
            MatRowPut(IVr,MatRowCnt(IVr),IVrw);
          end;
        end;
      end;
      SetupInvoiceRowAndAdd(CredManr,IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);

    end;
    if (CredManPayPlanrw.TransDate>ed) then begin
      i = rwcnt;
    end;
  end;
  if (nonblank(lastd)) then begin
    MergeItemsInInvoice(IVr,CredManr);
    if (CredManCanInvoiceOverdues(CredManr)) then begin
      GetCredManOverdueInvoices(CredManr,CMb,lastd,lastd2,latedays,lateamount,lateformula,false,false,calcsd);
      switch (CIb.OverdueIVType) begin
        case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
        case 1: 
          SetupLoanInvoice(CredManr,CMb,oIVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno,2,true);
          AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
          SetupOverdueLangCode(oIVr,CredManr);
          StoreLoanInvoice(oIVr,CredManr);
      end;
    end;
    CM_AddPrepayments(IVr,CredManr,CIb);
    if (IVr.SerNr>-1) then begin
      CheckAndAddHiddenPrinciple(IVr,CIb);
      if (manualf) then begin
        IVr.ManualInvoice = 1;
      end;
      StoreLoanInvoice(IVr,CredManr);
      //if (firstf==false) then begin
        RecordCopy(firstIVr,IVr);
      //end;
    end else begin
      logforadmin(0,"Failed to store Invoice. No Serial Number. Check Number Series");
    end;
  end;

lout:;
  return;
end;

global
procedure TestCredManInvoicesFromPlan2(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date sd,Date ed,var array record IVVc aIVr)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  Date lastd,lastd2;
  record IVVc IVr;
  Boolean firstf;
  Integer latedays;
  val lateamount;
  array string 255 lateformula;
  transaction Boolean gSilenceIVOpenPrepExists;
  
  gSilenceIVOpenPrepExists = true;
  lastd2 = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.PlanType<=4 and (blank(sd) or CredManPayPlanrw.TransDate>=sd)) then begin// and CredManPayPlanrw.TransDate<=ed
      if (lastd!=CredManPayPlanrw.TransDate) then begin
        //Setup new invoice
        if (nonblank(lastd)) then begin
          aIVr[aIVr.length] = IVr;
        end;
        lastd2 = AddDay(lastd,1);//to get the start date for penalty calculation.
        lastd = CredManPayPlanrw.TransDate;
        SetupLoanInvoice(CredManr,CMb,IVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,false,false,"",-1,false);

      end;
      //skip late fees here?? 
      if (CredManPayPlanrw.PlanType!=9) then begin
        SetupInvoiceRowAndAdd(CredManr,IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);
      end;

    end;
    if (CredManPayPlanrw.TransDate>ed) then begin
      i = rwcnt;
    end;
  end;
  if (nonblank(lastd)) then begin
    aIVr[aIVr.length] = IVr;
  end;
  gSilenceIVOpenPrepExists = false;

  return;
end;

global
procedure TestCredManInvoicesFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date ed,var array record IVVc aIVr)
begin

  TestCredManInvoicesFromPlan2(CredManr,CMb,CredManPayPlanr,"",ed,aIVr);

  return;
end;

global
procedure GetItemName(string code,var string spec)
begin
  record INVc INr;

  INr.Code = code;
  ReadFirstMain(INr,1,true);
  spec = INr.Name;

  return;
end;

procedure BuildInvoiceBasedOnSchedule(record CredManVc CredManr,row CredManSchedVc CSrw,record CredManSetBlock CMb,record CMApplicationSetBlock ASb,Date lastd,var record IVVc IVr,Boolean updf,Boolean addfeesf)
begin
  Integer latedays;
  val lateamount;
  string 255 spec;
  record CMInvoicingBlock CIb;
  record IVVc oIVr;
  array string 255 lateformula;
  record CredFeesMatrixVc FMr;
  row CredFeesMatrixVc FMrw;
  Integer i,rwcnt;
  Date calcsd;

  BlockLoad(CIb);
  RecordClear(IVr);
  RecordNew(IVr);
  SetupLoanInvoice(CredManr,CMb,IVr,CSrw.InvDate,CSrw.FromDate,CSrw.ToDate,true,false,"",GetInvoiceType(CredManr,CSrw.InvDate),updf);
  if (CSrw.Principle>0) then begin
    GetItemName(CMb.InstalmentItem,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CMb.InstalmentItem,spec,1,CSrw.Principle,blankval,kEventTypeCalcInstalment,-1);
  end;
  if (CSrw.Deposit>0) then begin
    GetItemName(CMb.DepositItem,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CMb.DepositItem,spec,1,CSrw.Deposit,blankval,kEventTypeCalcInstalment,-1);
  end;
  if (CSrw.Interest>0) then begin
    GetItemName(CMb.RateItem,spec);
    if (CredManr.RealInterestFlag==1) then begin
//      CSrw.Interest = CSrw.Interest*GetPaidAmountRatio(CredManr,IVr.InvDate);
    end;
    SetupInvoiceRowAndAdd(CredManr,IVr,CMb.RateItem,spec,1,CSrw.Interest,blankval,kEventTypeCalcInterest,-1);
  end;
  if (CSrw.Fees>0) then begin
    UnpackRowFieldMatrix(CSrw,"FeesMatrix",FMr);
    rwcnt = MatRowCnt(FMr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(FMr,i,FMrw);
      GetItemName(FMrw.ArtCode,spec);
      SetupInvoiceRowAndAdd(CredManr,IVr,FMrw.ArtCode,spec,1,FMrw.Sum,blankval,kEventTypeCalcFees,-1);
    end;
  end;
  if (updf) then begin
    MergeItemsInInvoice(IVr,CredManr);
  end;
  if (addfeesf and CredManCanInvoiceOverdues(CredManr)) then begin
    GetCredManOverdueInvoices(CredManr,CMb,CSrw.InvDate,lastd,latedays,lateamount,lateformula,false,false,calcsd);
    switch (CIb.OverdueIVType) begin
      case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
      case 1: 
        SetupLoanInvoice(CredManr,CMb,oIVr,CSrw.InvDate,CSrw.FromDate,CSrw.ToDate,true,false,"",2,true);
        SetupOverdueLangCode(oIVr,CredManr);
        AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
        if (updf) then begin
          qupdating.StoreLoanInvoice(oIVr,CredManr);
        end;
      case 2:
        if (nonblank(CredManr.CancelDate)) then begin
          SetupLoanInvoice(CredManr,CMb,oIVr,CSrw.InvDate,CSrw.FromDate,CSrw.ToDate,true,false,"",2,true);
          SetupOverdueLangCode(oIVr,CredManr);
          AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
          if (updf) then begin
            qupdating.StoreLoanInvoice(oIVr,CredManr);
          end;
        end;
    end;
  end;
  
  if (updf) then begin
    CM_AddPrepayments(IVr,CredManr,CIb);
    CheckAndAddHiddenPrinciple(IVr,CIb);
  end;

  return;
end;

function Integer InvoiceTypeFromSchedule(record CredManVc CredManr,row CredManSchedVc CSrw)
begin
  Integer res;

  res = 1;
  if (CredManr.FirstInvDate>CSrw.InvDate) then begin
    if (CSrw.Deposit==0 and CSrw.Interest==0 and CSrw.Principle==0 and CSrw.Fees!=0) then begin
      res = 0;
    end;
  end;

  InvoiceTypeFromSchedule = res;
  return;
end;

updating function Boolean CreateInvoiceBasedOnSchedule(record CredManVc CredManr,Date ed,var record IVVc firstIVr,Boolean manualf,Boolean allf)
begin
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw,lastCSrw;
  Integer i,rwcnt,rw;
  record IVVc IVr,oldIVr;
  record CredManSetBlock CMb;
  record CMApplicationSetBlock ASb;
  record CMInvoicingBlock CIb;
  Date lastd;
  Boolean firstf;
  Boolean res;
  record CredManTypeVc CMTr;
  val totdays,useddays;
  val ratio;
  Boolean testf;

  Date ted,sd,invdat2;
  Integer latedays;
  val lateamount;
  Boolean addf,startfullf;
  array string 255 lateformula;
  Date calcsd;

  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    res = true;
    BlockLoad(CMb);
    BlockLoad(ASb);
    BlockLoad(CIb);
    lastd = CredManr.FirstInvDate;
    rwcnt = MatRowCnt(CSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CSr,i,CSrw);
      testf = false;
      if (nonblank(CSrw.FromDate)) then begin
        startfullf = true;
      end;
      if (CSrw.InvDate<=ed and CSrw.Invoiced==0 and CanInvoiceDate(CredManr,CSrw.InvDate,allf,startfullf)) then begin
        testf = true;
      end;
      if (nonblank(CredManr.CancelDate) and CSrw.Invoiced==0) then begin
        if (lastCSrw.InvDate<ed and CSrw.InvDate>=ed) then begin
          testf = true;
          useddays = DateDiff(ed,CSrw.FromDate) + 1;
          totdays = DateDiff(CSrw.ToDate,CSrw.FromDate) + 1;
          ratio = useddays/totdays;
          CSrw.Principle = CSrw.Principle*ratio;
          CSrw.Interest = CSrw.Interest*ratio;
          CSrw.ToDate = ed;
          CSrw.InvDate = ed;
        end;
      end;      
      if (testf) then begin
        BuildInvoiceBasedOnSchedule(CredManr,CSrw,CMb,ASb,lastd,IVr,true,true);
        if (IVr.SerNr>-1) then begin
          if (manualf) then begin
            IVr.ManualInvoice = 1;
          end;
          StoreLoanInvoice(IVr,CredManr);
          //if (firstf==false) then begin
            RecordCopy(firstIVr,IVr);
          //  firstf = true;
          //end;
        end;
      end else begin
        if (CSrw.InvDate>ed) then begin
          i = rwcnt;
        end;
      end;
      lastd = AddDay(CSrw.InvDate,1);
      CopyRow(CSr,CSrw,lastCSrw);
    end;
    if (CIb.OverdueIVType==2 and GetDay(CurrentDate)==CIb.OverdueIVDay) then begin
      ted = CurrentDate;
      ted.Day = 1;
      sd = AddMonth(ted,-1);
      ted = AddDay(ted,-1);
      invdat2 = CurrentDate;
      GetCredManOverdueInvoices(CredManr,CMb,ted,sd,latedays,lateamount,lateformula,false,false,calcsd);
      addf = true;
      CMTr.Code = CredManr.Type;
      if (ReadFirstMain(CMTr,1,true)) then begin
        if (CMTr.MinOverdueFee>0 and lateamount<CMTr.MinOverdueFee) then begin
          addf = false;
        end;
      end;
      if (addf) then begin
        SetupLoanInvoice(CredManr,CMb,IVr,invdat2,sd,ted,true,false,"",2,true);
        SetupOverdueLangCode(IVr,CredManr);
        AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
        StoreLoanInvoice(IVr,CredManr);
        //if (firstf==false) then begin
          RecordCopy(firstIVr,IVr);
        //  firstf = true;
        //end;
      end;
    end;
  end;
  CreateInvoiceBasedOnSchedule = res;
  return;
end;

global
procedure TestInvoiceBasedOnSchedule(record CredManVc CredManr,record CredManSchedVc CSr,Date ed,var array record IVVc aIVr)
begin
  row CredManSchedVc CSrw;
  Integer i,rwcnt,rw;
  record IVVc IVr,oldIVr;
  record CredManSetBlock CMb;
  record CMApplicationSetBlock ASb;
  Date lastd;
  Boolean firstf;
  Boolean res;
  
  BlockLoad(CMb);
  BlockLoad(ASb);
  lastd = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CSr,i,CSrw);
    if (CSrw.InvDate<=ed and CSrw.Invoiced==0) then begin
      BuildInvoiceBasedOnSchedule(CredManr,CSrw,CMb,ASb,lastd,IVr,false,false);
      aIVr[aIVr.length] = IVr;
    end else begin
      if (CSrw.InvDate>ed) then begin
        i = rwcnt;
      end;
    end;
    lastd = AddDay(CSrw.InvDate,1);
  end;

  return;
end;

global
procedure TestInvoiceBasedOnScheduleRow(record CredManSchedVc CSr,row CredManSchedVc CSrw,var record IVVc IVr)
begin
  record CredManSetBlock CMb;
  record CMApplicationSetBlock ASb;
  Date lastd;
  Boolean firstf;
  Boolean res;
  record CredManVc CredManr;
  transaction Boolean gSilenceIVOpenPrepExists;
  
  BlockLoad(CMb);
  BlockLoad(ASb);
  CredManr.SerNr = CSr.CredManNr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    gSilenceIVOpenPrepExists = true;
    BuildInvoiceBasedOnSchedule(CredManr,CSrw,CMb,ASb,"",IVr,false,false);
    gSilenceIVOpenPrepExists = false;
  end;

  return;
end;


global
updating procedure CreateSingleAgreementInvoice2(record CredManVc CredManr,Date ed,var record IVVc IVr,string ivno,Boolean manualf,Boolean allf)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  string 255 oldlang;

  if (CanCreateSingleAgreementInvoice(CredManr,ed)) then begin
    oldlang = CM_SetCompanyLanguage;
    if (CreateInvoiceBasedOnSchedule(CredManr,ed,IVr,manualf,allf)==false) then begin
      BlockLoad(CMb);
      BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
      CreateInvoicesFromPlan(CredManr,CMb,CredManPayPlanr,ed,IVr,ivno,manualf,allf);
    end;
    CM_ResetCompanyLanguage(oldlang);
  end;

  return;
end;

global
updating procedure CreateSingleAgreementInvoice(record CredManVc CredManr,Date ed,var record IVVc IVr,string ivno,Boolean manualf)
begin

  CreateSingleAgreementInvoice2(CredManr,ed,IVr,ivno,manualf,true);

  return;
end;

function val GetBuyOutFee(record CredManVc CredManr,Date td,val balance)
begin
  val res;
  val rate;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt,cnt;
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record SMVc SMr;
  row SMVc SMrw;
  date lastinvdate;

  rate = CredManr.BuyoutFeePrc;
  res = (balance) *(rate/100);
  res = res + CredManr.BuyoutFeeFixed;

  if (CredManr.BuyoutFeeMonths>0) then begin
    CSr.CredManNr = CredManr.SerNr;
    if (ReadFirstMain(CSr,1,true)) then begin
      rwcnt = MatRowCnt(CSr);
      cnt = CredManr.BuyoutFeeMonths;
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CSr,i,CSrw);
        if (CSrw.InvDate>td and cnt>0) then begin
          res = res + CSrw.Interest;
          cnt = cnt - 1;
        end;
        if (cnt<=0) then begin
          i = rwcnt;
        end;
      end;

    end else begin
      BlockLoad(CMb);
      if (BuildCredManInfoMatrixOnSchedule(CredManr,CMb,SMr)==false) then begin
        BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
        BuildCredManInfoMatrix(CredManr,CredManPayPlanr,CMb,SMr);
      end;
      rwcnt = MatRowCnt(SMr);
      cnt = CredManr.BuyoutFeeMonths;
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(SMr,i,SMrw);
        if (SMrw.TransDate>td and cnt>0) then begin
          res = res + SMrw.CredVal;
          cnt = cnt - 1;
        end;
        if (cnt<=0) then begin
          i = rwcnt;
        end;
      end;
    end;
  end;

  GetBuyOutFee = res;
  return;
end;

function val GetBuyOutFeeChBO(record CredManVc CredManr,Date td,val balance)
begin
  val res;
  val rate;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt,cnt;
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record SMVc SMr;
  row SMVc SMrw;
  date lastinvdate;

  rate = CredManr.BuyoutFeePrc;
  res = (balance) *(rate/100);
  res = res + CredManr.BuyoutFeeFixed;

  if (CredManr.BuyoutFeeMonths>0) then begin
    CSr.CredManNr = CredManr.SerNr;
    if (ReadFirstMain(CSr,1,true)) then begin
      rwcnt = MatRowCnt(CSr);
      cnt = CredManr.BuyoutFeeMonths;
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CSr,i,CSrw);
        if (CSrw.ToDate>=td and cnt>0) then begin
          res = res + CSrw.Interest;
          cnt = cnt - 1;
        end;
        if (cnt<=0) then begin
          i = rwcnt;
        end;
      end;

    end else begin
      BlockLoad(CMb);
      if (BuildCredManInfoMatrixOnSchedule(CredManr,CMb,SMr)==false) then begin
        BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
        BuildCredManInfoMatrix(CredManr,CredManPayPlanr,CMb,SMr);
      end;
      rwcnt = MatRowCnt(SMr);
      cnt = CredManr.BuyoutFeeMonths;
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(SMr,i,SMrw);
        if (SMrw.TransDate>td and cnt>0) then begin
          res = res + SMrw.CredVal;
          cnt = cnt - 1;
        end;
        if (cnt<=0) then begin
          i = rwcnt;
        end;
      end;
    end;
  end;

  GetBuyOutFeeChBO = res;
  return;
end;

global
procedure AddBuyOutFee(record CredManVc CredManr,var record IVVc IVr,val balance)
begin
  //record CMInvoicingBlock CIb;
  record CMBuyOutBlock CMBOb;
  string 255 spec;
  val buyoutfee;
  
  //BlockLoad(CIb);
  BlockLoad(CMBOb);
  
  buyoutfee = GetBuyOutFee(CredManr,IVr.InvDate,balance);
  GetItemName(CMBOb.BuyOutItem,spec);
  if (nonblank(CMBOb.BuyOutItem) and buyoutfee>0) then begin
    SetupInvoiceRowAndAdd(CredManr,IVr,CMBOb.BuyOutItem,spec,1,buyoutfee,blankval,15,-1);
  end;

  return;
end;

global
procedure AddInsuranceCost(record CredManVc CredManr,var record IVVc IVr,record CMInvoicingBlock CIb)
begin
  string 255 spec;
  val buyoutfee;
  
  if (nonblank(CIb.LetterOfDemand) and CredManr.LetterOfDemand>0) then begin
    GetItemName(CIb.LetterOfDemand,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CIb.LetterOfDemand,spec,1,CredManr.LetterOfDemand,blankval,15,-1);
  end;
  if (nonblank(CIb.InsuranceCost) and CredManr.InsuranceCost>0) then begin
    GetItemName(CIb.InsuranceCost,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CIb.InsuranceCost,spec,1,CredManr.InsuranceCost,blankval,15,-1);
  end;

  return;
end;

global
procedure GetBuyOutData(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,var Date lastinv,var val balance,var val issueinstbal)
begin
  record CredHistVc CredHistr;
  Boolean foundf;
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  val curbal;
  Boolean stopf;
 
  if (GetInterestPaymentType(CredManr)==2) then begin
    curbal = 0;
  end else begin
    curbal = CredManr.InvSum4;
  end;

  lastinv = CredManr.startDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.PlanType<=4) then begin
      stopf = true;
    end else begin
      if (stopf==false or CredManPayPlanrw.PlanType==18) then begin
        CredHistr.SerNr = CredManPayPlanrw.IssuedNr;
        if (ReadFirstMain(CredHistr,1,true)) then begin
          if (CredManPayPlanrw.ArtCode!=CMb.LateFeeItem and CredManPayPlanrw.ArtCode!=CMb.LateRateItem and (CredHistr.RecordType==0 or CredHistr.RecordType==4 or CredHistr.RecordType==5)) then begin
            if (TypeAffectsBalance(CredHistr.ChargeType)) then begin
              curbal = curbal - CredHistr.Sum;
              if(CredHistr.ChargeType==kEventTypeIssueInstalment)then begin
                issueinstbal = issueinstbal + CredHistr.Sum;
              end;
            end;
            if (CredHistr.ChargeType==kEventTypePayout) then begin
              curbal = curbal + CredHistr.Sum;
            end;
            balance = curbal;
            foundf = true;
            if (CredHistr.RecordType==0 and CredHistr.CredToDate>lastinv) then begin
              lastinv = AddDay(CredHistr.CredToDate,1);
            end;
          end;
        end;
      end;
    end;
  end;
  if (!foundf) then begin
    balance = CredManr.InvSum4;
  end;

  return;
end;

procedure CreateBuyOutInvoiceFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date td,var record IVVc IVr,BOolean testf,var Date sd,Boolean balancef,record ORVc ORr)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  record CredManPayPlanVc CredManPayPlan2r;
  val balance,tval;
  Date lastinv;
  Integer i,rwcnt,lastusedrow,sernrf;
  Integer latedays,rwcnt2,j;
  val lateamount,issuedinsbal,buyoutfee;
  val cumint,calcbal,principlelateamount,interestlateamount;
  array string 255 lateformula,afuturefee;
  vector val vfuturefee;
  record CredManVc tCredManr;
  record CMInvoicingBlock CIb;
  Date calcsd;
  string 20 pd,warning;
  record CMBuyOutBlock CMBOb;
  record CredManSetBlock CredManSetb;
  row IVVc IVrw;
  string 255 spec;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  record CredFeesMatrixVc FMr;
  row CredFeesMatrixVc FMrw;
  boolean skipint;
  
/*
1. Get the last invoice date and the balance
2. Set up and create an invoice
*/ 
  BlockLoad(CIb);
  BlockLoad(CMBOb);
  blockload(CredManSetb);
  GetBuyOutData(CredManr,CredManPayPlanr,CMb,lastinv,balance,issuedinsbal);
  
  if(lastinv>td)then begin
    lastinv = addmonth(td,-1);
  end;
  if(nonblankdate(ORr.OrdDate))then begin
    balance = ORr.BaseSum4;
  end;
  
  if (balance>0) then begin
    pd = CIb.BuyOutPayDeal;
    if (blank(pd)) then begin
      pd = CIb.FirstInvPayDeal;
    end;
    SetupLoanInvoice2(CredManr,CMb,IVr,td,lastinv,td,true,false,"",1,true,pd);
    
    
    CSr.CredManNr = CredManr.SerNr;
    if (ReadFirstMain(CSr,1,true)) then begin
      rwcnt = MatRowCnt(CSr);
      for (i=0;i<rwcnt;i=i+1) begin
       MatRowGet(CSr,i,CSrw);
        if (CSrw.Invoiced==1) then begin
          if(CSrw.ToDate==IVr.InvDate)then begin
            if(CMBOb.DoNotCreditlastDayInvoices==1)then begin
              skipint = true;
              cumint = cumint - CSrw.Interest;
              balance = balance - CSrw.Principle;
            end;
          end;
        end;
      end;
    end;
    
    AddInstalmentFixedBO(CredManr,CredManPayPlan2r,CMb,balance,td,cumint,calcbal,lastinv,td);
    RecordCopy(tCredManr,CredManr);
    tCredManr.InvSum4 = balance;
    tCredManr.DepositSum = 0;
    tval = GetAgreementAmount(CredManr);
    if(nonblankdate(ORr.OrdDate))then begin
      cumint = ORr.TotGP;
      balance = ORr.TotGP;
    end;
    
    if(ORr.InvMark==1 or ORr.DownPaySent==0)then begin
      if(skipint==false)then begin
        AddInterestBO(tCredManr,CredManPayPlan2r,CMb,kMonthTypeFirst,td,ORr.TotGP,balance,lastinv,td,-1,true);
      end;
    end;
    sd = GetLastInvoiceDate(CredManr,ORr.OrdDate);
    GetCredManOverdueInvoices2(CredManr,CMb,ORr.OrdDate,sd,latedays,lateamount,principlelateamount,interestlateamount,lateformula,false,false,calcsd);
    GetCredManOverdueInvoices(CredManr,CMb,ORr.OrdDate,sd,latedays,lateamount,lateformula,true,false,calcsd);
    //SetupLoanInvoice(CredManr,CMb,IVr,td,calcsd,td,true,false,"",2,true);
    
    buyoutfee = ORr.TAX2Sum;
    GetItemName(CIb.BuyOutItem,spec);
    if (nonblank(CIb.BuyOutItem) and buyoutfee>0) then begin
      SetupInvoiceRowAndAdd(CredManr,IVr,CIb.BuyOutItem,spec,1,buyoutfee,blankval,15,-1);
    end;
    
    if (nonblank(CIb.LetterOfDemand) and ORr.SumIncCom>0) then begin
      GetItemName(CIb.LetterOfDemand,spec);
      SetupInvoiceRowAndAdd(CredManr,IVr,CIb.LetterOfDemand,spec,1,ORr.SumIncCom,blankval,15,-1);
    end;

    if (nonblank(CIb.InsuranceCost) and ORr.RvrsVAT>0) then begin
      GetItemName(CIb.InsuranceCost,spec);
      SetupInvoiceRowAndAdd(CredManr,IVr,CIb.InsuranceCost,spec,1,ORr.RvrsVAT,blankval,15,-1);
    end;
    
    if(ORr.DiscSum>0)then begin
      CSr.CredManNr = CredManr.SerNr;
      if (ReadFirstMain(CSr,1,true)) then begin
        rwcnt = MatRowCnt(CSr);
        for (i=0;i<rwcnt;i=i+1) begin
         MatRowGet(CSr,i,CSrw);
          if (CSrw.Invoiced==0) then begin
            if (CSrw.Fees>0 and CSrw.FromDate>ORr.OrdDate) then begin
              UnpackRowFieldMatrix(CSrw,"FeesMatrix",FMr);
              rwcnt2 = MatRowCnt(FMr);
              for (j=0;j<rwcnt2;j=j+1) begin
                MatRowGet(FMr,j,FMrw);
                vfuturefee[FMrw.ArtCode] = vfuturefee[FMrw.ArtCode] + FMrw.Sum;
              end;
            end;
          end;
        end;
      end;
      
      getvectortags(vfuturefee,afuturefee);
      for(i=0;i<afuturefee.length;i=i+1)begin
        GetItemName(afuturefee[i],spec);
        SetupInvoiceRowAndAdd(CredManr,IVr,afuturefee[i],spec,1,vfuturefee[afuturefee[i]],blankval,kEventTypeCalcFees,-1);
      end;
    
    end;  
    
    rwcnt = MatRowCnt(CredManPayPlan2r);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CredManPayPlan2r,i,CredManPayPlanrw);
      SetupInvoiceRowAndAdd(CredManr,IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);
    end;
    
    for(i=0;i<matrowcnt(IVr);i=i+1)begin
      matrowget(IVr,i,IVrw);
      if(IVrw.stp==1 and nonblank(IVrw.ArtCode))then begin
        lastusedrow = i;
      end;
    end;

    AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
    AddInsuranceCost(CredManr,IVr,CIb);
  end;

  return;
end;

global
updating procedure CreateProlongInvoice(record CredManVc CredManr,string paydeal,string salesman,string itemspec,var record IVVc nIVr)
begin
  record CMInvoicingBlock CIb;
  record CredManSetBlock CMb;
  record IVVc IVr,oldIVr;
  val rate,sum;
  string 255 spec,reslang;
  string 20 pd;
  record CredManTypeVc CMTr;
    
  BlockLoad(CIb);
  BlockLoad(CMb);

  pd = paydeal;
  if (blank(pd)) then begin
    pd = CIb.FirstInvPayDeal;
  end;

  SetupLoanInvoice3(CredManr,CMb,IVr,CurrentDate,"","",true,false,"",1,true,pd,salesman);
  rate = CredManr.StdProlongPrc;
  if (CredManr.AnnualRate==1) then begin
    rate = rate/12;
  end;
  sum = (CredManr.InvSum4 - CredManr.DepositSum) *(rate/100);
  sum = sum + CredManr.StdProlongFee;
 
  spec = itemspec;
  if (blank(spec)) then begin
    GetItemName(CIb.ProlongItem,spec);
  end;
  SetupInvoiceRowAndAdd(CredManr,IVr,CIb.ProlongItem,spec,1,sum,blankval,14,-1);
  CM_AddPrepayments(IVr,CredManr,CIb);
  
  CMTr.Code = CredManr.Type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if(nonblank(CMTr.AgreChangeLangCode))then begin
      IVr.LangCode = CMTr.AgreChangeLangCode;
    end;
  end;
  if(getAdditionalLangCode(CredManr,"AgreChangeLangCode",reslang))then begin
    IVr.LangCode = reslang;
  end;
  
  StoreLoanInvoice(IVr,CredManr);
  
  if(IVr.SerNr>0)then begin
    RecordCopy(nIVr,IVr);
  end;

  return;
end;


global
updating procedure CreateChangesInvoice(record CredManVc CredManr,string paydeal,string salesman,string itemspec,var record IVVc nIVr,record RcVc RepSpec,vector val nocreditsum)
begin
  record CMInvoicingBlock CIb;
  record CredManSetBlock CMb;
  record IVVc IVr,oldIVr;
  val rate,sum;
  string 255 spec,reslang;
  string 20 pd;
  integer cumint,balance;
  record CMBuyOutBlock CMBOb;
  date frdate,todate,invdate;
  string 20 princItem;
  val calcbal,newint;
  record CredManVc tmpCredManr;
  record CredManTypeVc CMTr;
  
  recordcopy(tmpCredManr,CredManr);
  
  BlockLoad(CIb);
  BlockLoad(CMb);
  BlockLoad(CMBOb);
  

  princItem = CMb.InstalmentItem;
  
  pd = paydeal;
  if (blank(pd)) then begin
    pd = CIb.FirstInvPayDeal;
  end;
  
  invdate = currentdate;
  if(RepSpec.d1<RepSpec.sEndDate)then begin
    frdate = RepSpec.sStartDate;
    todate = RepSpec.sEndDate;
    invdate = RepSpec.d1;
  end else begin
    frdate = addday(RepSpec.sEndDate,1);
    todate = RepSpec.d1;
    invdate = RepSpec.d1;
  end;
  
  SetupLoanInvoice3(CredManr,CMb,IVr,invdate,"","",true,false,"",1,true,pd,salesman);
  if(RepSpec.vals3!=0 or RepSpec.vals4!=0)then begin
/*  
    if(stringtoval(RepSpec.FirstAcc,m4val)>0)then begin
      logtext(0,"RepSpec.FirstAcc " & RepSpec.FirstAcc);
      GetItemName(CMb.RateItem,spec);
      spec = spec  & " " & frdate & ":" & addday(invdate,-1);
      SetupInvoiceRowAndAdd(CredManr,IVr,CMb.RateItem,spec,1,stringtoval(RepSpec.FirstAcc,m4val),blankval,kEventTypeCalcInterest,-1);
      spec = "";
    end;
*/
    if(nonblank(princItem))then begin
      if(nocreditsum[princItem]>0)then begin
        /* we don't need manual entries for principal or interest
        tmpCredManr.InvSum4 = nocreditsum[princItem];
        tmpCredManr.DepositSum = blankval;
        tmpCredManr.ExtraDepositSum = blankval;
        calcbal = stringtoval(RepSpec.ObjStr,m4Val);
        if(RepSpec.vals3!=0)then begin
          tmpCredManr.IntRate = RepSpec.vals3;
        end;
        newint = GetRateAmount(tmpCredManr,tmpCredManr.IntRate,kMonthTypeFirst,invdate,todate,calcbal,false,false);      
        GetItemName(CMb.RateItem,spec);
        spec = spec  & " " & invdate & ":" & todate;
        SetupInvoiceRowAndAdd(CredManr,IVr,CMb.RateItem,spec,1,newint,blankval,kEventTypeCalcInterest,-1);
        spec = "";
        */

        /*logtext(0,"nocreditsum[princItem] " & nocreditsum[princItem]);
        GetItemName(princItem,spec);
        spec = spec  & " " & frdate & ":" & addday(invdate,-1);
        SetupInvoiceRowAndAdd(CredManr,IVr,princItem,spec,1,nocreditsum[princItem],blankval,kEventTypeCalcInstalment,-1);
        spec = "";*/
      end;
    end;
    
  end;

  /*if(stringtoval(RepSpec.f6,m4val)>0)then begin
    GetItemName(CMBOb.FutFeeItem,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CMBOb.FutFeeItem,spec,1,stringtoval(RepSpec.f6,m4val),blankval,kEventTypeCalcFees,-1);
    spec = "";
  end;*/

  /*if(stringtoval(RepSpec.f12,m4val)>0)then begin
    GetItemName(CMBOb.FutFeeItem,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CMBOb.FutFeeItem,spec,1,stringtoval(RepSpec.f12,m4val),blankval,kEventTypeCalcFees,-1);
    spec = "";
  end;*/
  
  if (RepSpec.flags[2]==1) then begin//Issue Prolong Invoice
    if(blank(RepSpec.f9)/*stringtoval(RepSpec.f9,m4val)==0*/)then begin
      rate = CredManr.StdProlongPrc;
      if (CredManr.AnnualRate==1) then begin
        rate = rate/12;
      end;
      sum = (CredManr.InvSum4 - CredManr.DepositSum) *(rate/100);
      sum = sum + CredManr.StdProlongFee;
    end else begin
      sum = sum + stringtoval(RepSpec.f9,m4val);
    end;
    spec = itemspec;
    if (blank(spec)) then begin
      GetItemName(CIb.ProlongItem,spec);
    end;
    SetupInvoiceRowAndAdd(CredManr,IVr,CIb.ProlongItem,spec,1,sum,blankval,14,-1);
  end;
  CM_AddPrepayments(IVr,CredManr,CIb);
  
  
  CMTr.Code = CredManr.Type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if(nonblank(CMTr.AgreChangeLangCode))then begin
      IVr.LangCode = CMTr.AgreChangeLangCode;
    end;
  end;
  if(getAdditionalLangCode(CredManr,"AgreChangeLangCode",reslang))then begin
    IVr.LangCode = reslang;
  end;
  
  StoreLoanInvoice(IVr,CredManr);
  
  if (IVr.SerNr>0) then begin
    RecordCopy(nIVr,IVr);
  end;

  return;
end;


global
updating procedure CreateManualExtraInvoice(record RcVc RepSpec,var record IVVc IVr)
begin
  record CMInvoicingBlock CIb;
  record CredManSetBlock CMb;
  record IVVc oldIVr;
  val rate,sum;
  string 255 spec;
  record CredManVc CredManr;
  string 5 pd;
  string 20 salesman;
  
  CredManr.SerNr = RepSpec.long1;
  if (ReadFirstMain(CredManr,1,true)) then begin
    BlockLoad(CIb);
    BlockLoad(CMb);
    pd = RepSpec.f2;
    if (blank(pd)) then begin
      pd = CIb.FirstInvPayDeal;
    end;
    salesman = RepSpec.f3;
    
    SetupLoanInvoice3(CredManr,CMb,IVr,RepSpec.d1,"","",true,false,"",1,true,pd,salesman);
    spec = trim(RepSpec.f4);
    if (blank(spec)) then begin
      GetItemName(RepSpec.f1,spec);
    end;
    SetupInvoiceRowAndAdd(CredManr,IVr,RepSpec.f1,spec,1,RepSpec.vals0,blankval,15,-1);
    CM_AddPrepayments(IVr,CredManr,CIb);

    StoreLoanInvoice(IVr,CredManr);
  end;

  return;
end;

function val GetCreditedInterest(record CredManVc CredManr,Date td,var Longint ivnr)
begin
  val res;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt;
  Integer diff,diff2;

  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    rwcnt = MatRowCnt(CSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CSr,i,CSrw);
      if (CSrw.FromDate<=td) then begin
        if (CSrw.ToDate>td) then begin
          if (CSrw.Interest>0) then begin
            if (CSrw.Invoiced==1) then begin
              diff = DateDiff(CSrw.ToDate,CSrw.FromDate)+1;
              diff2 = DateDiff(CSrw.ToDate,td)+1;
              res = res + CSrw.Interest*diff2/diff;
              ivnr = CSrw.InvoiceNr;
            end;
          end;
        end;
      end else begin
        i = rwcnt;
      end; 
    end;
  end;


  GetCreditedInterest = res;
  return;
end;

global updating procedure PayAllOpenInvoices(record CredManVc CredManr,Date todate,record ORVc ORr,string itemsclass)
begin
  record IVVc IVr,setIVr,oldIVCreditr,IVCreditr;
  row IVVc IVrw,IV2rw;
  integer i,rwcnt,rwcnt2,j,mtrw;
  boolean TrHs,testf,isfullpayed;
  record ARVc ARr;
  integer credflag;
  record CredHistVc CredHistr,CredHist2r;
  boolean TrHs2,foundf,creditthisinvoice;
  record INVc INr;
  string 255 tstr,princItem,itemtocredit,intItem;
  val t,tt,tot1,tot2,tot3,intcredsum,Sum,tval;
  longint t2,res;
  date blankd;
  vector val vIVItemOpenAmmount;
  record CredManSetBlock CMb;
  record SMVc SMr;
  row SMVc SMrw;
  record CMInvoicingBlock CMIb;
  
  blockload(CMb);
  
  Sum = 0;
  
  logforadmin(0,"PayAllOpenInvoices");
  
  IVr.CustCode = CredManr.CustCode;
  TrHs = true;
  while(loopkey("CustCode",IVr,1,TrHs))begin
    testf = true;
    if(IVr.CustCode!=CredManr.CustCode)then begin TrHs = false; testf = false; end;
    if(IVr.CustCredManNr!=CredManr.SerNr)then begin testf = false; end;
    if(IVr.OKFlag==0)then begin testf = false; end;
    if(IVr.Invalid==1)then begin testf = false; end;
    if(IVr.InvType==kInvoiceTypeCredit)then begin testf = false; end;
    
    
    if(testf)then begin
      creditthisinvoice = false;
      isfullpayed = false;
      ARr.InvoiceNr = IVr.SerNr;
      if(!readfirstmain(ARr,1,true))then begin
        isfullpayed = true;
      end;
      credflag = 1;
      if(IVr.InvType==kInvoiceTypeCredit)then begin
        credflag = -1;
      end;
      
      rwcnt = matrowcnt(IVr);
      for(i=0;i<rwcnt;i=i+1)begin
        matrowget(IVr,i,IVrw);
        if(IVrw.stp==kInvoiceRowTypeNormal and nonblank(IVrw.ArtCode))then begin
          if(isfullpayed)then begin

          end else begin
            if(IVr.InvType!=kInvoiceTypeCredit)then begin
              resetloop(CredHistr);
              CredHistr.RecordNr = IVr.SerNr;
              CredHistr.RecordType = 0;
              TrHs2 = true;
              foundf = false;
              while (LoopKey("RecordNr",CredHistr,2,TrHs2)) begin
                if ((CredHistr.RecordNr!=IVr.SerNr) or (CredHistr.RecordType!=0)) then begin
                  TrHs2 = false;
                end;
                if (TrHs2 and CredHistr.ArtCode==IVrw.ArtCode) then begin
                  foundf = true;
                  logforadmin(0,"IV For Cred  " & IVr.SerNr & " todate " & todate);
                  t = GetCredHistOpenValueOnDate(CredHistr.SerNr,blankd);
                  Sum = Sum + t;
                end;
              end;
            end;
          end;
        end;
      end;
    end;    
  end;
    
  if(Sum>0)then begin
    blockload(CMIb);
    recordnew(SMr);
    SMr.RegDate = todate;
    SMr.Sign = CMIb.PaymentMode;
    SMrw.Objects = CredManr.CustCode;
    SMrw.DebVal = Sum;
    SMrw.CurncyCode = CredManr.CurncyCode;
    SMrw.LongField01 = CredManr.SerNr;
    matrowput(SMr,0,SMrw);
    ReceiptEntryCreateReceipts(SMr,true,tval);
  end;
  
return;
end;




global updating procedure ReconcileOpenInvoices(record CredManVc CredManr,Date todate,record ORVc ORr,string itemsclass,var vector val nocreditsum)
begin
  record IVVc IVr,setIVr,oldIVCreditr,IVCreditr;
  row IVVc IVrw,IV2rw;
  integer i,rwcnt,rwcnt2,j,mtrw;
  boolean TrHs,testf,isfullpayed,creditanyvay;
  record ARVc ARr;
  integer credflag;
  record CredHistVc CredHistr,CredHist2r;
  boolean TrHs2,foundf,creditthisinvoice,installmentf;
  record INVc INr;
  string 255 tstr,princItem,itemtocredit,intItem;
  val t,tt,tot1,tot2,tot3,intcredsum,chk;
  longint t2,res;
  date blankd;
  vector val vIVItemOpenAmmount,vItemsToPay;
  record CredManSetBlock CMb;
  record CMBuyOutBlock CMBuyOutb;
  record IPVc IPr,oldIPr;
  row IPVc IPrw;
  record CMInvoicingBlock CIb;
  
  
  
  blockload(CMb);
  blockload(CMBuyOutb);
  blockload(CIb);
  
  princItem = CMb.InstalmentItem;
  intItem = CMb.RateItem;
  itemtocredit = princItem;
    
  if(nonblank(itemsclass))then begin
    itemtocredit = "";
    creditanyvay = true;
    while(loopmain(INr,1,true))begin
      if(setinset(itemsclass,INr.DispGroups))then begin
        itemtocredit = itemtocredit & INr.Code & ","; 
      end;
    end;
    if(ORr.InvMark==1)then begin
      itemtocredit = itemtocredit & "," & intItem;
    end;
  end else begin
    if(ORr.InvMark==1)then begin
      itemtocredit = itemtocredit & "," & intItem;
    end;
  end;
  
  
  IVr.CustCode = CredManr.CustCode;
  TrHs = true;
  while(loopkey("CustCode",IVr,1,TrHs))begin
    testf = true;
    if(IVr.CustCode!=CredManr.CustCode)then begin TrHs = false; testf = false; end;
    if(IVr.CustCredManNr!=CredManr.SerNr)then begin testf = false; end;
    if(IVr.OKFlag==0)then begin testf = false; end;
    if(IVr.Invalid==1)then begin testf = false; end;
    if(IVr.InvType==kInvoiceTypeCredit)then begin testf = false; end;
    
    
    if(testf)then begin
      creditthisinvoice = false;
      isfullpayed = false;
      ARr.InvoiceNr = IVr.SerNr;
      if(!readfirstmain(ARr,1,true))then begin
        isfullpayed = true;
      end;
      credflag = 1;
      if(IVr.InvType==kInvoiceTypeCredit)then begin
        credflag = -1;
      end;
      
      rwcnt = matrowcnt(IVr);
      for(i=0;i<rwcnt;i=i+1)begin
        matrowget(IVr,i,IVrw);
        if(IVrw.stp==kInvoiceRowTypeNormal and nonblank(IVrw.ArtCode))then begin
          if(isfullpayed)then begin

          end else begin
            if(IVr.InvType!=kInvoiceTypeCredit)then begin
              resetloop(CredHistr);
              CredHistr.RecordNr = IVr.SerNr;
              CredHistr.RecordType = 0;
              TrHs2 = true;
              foundf = false;
              while (LoopKey("RecordNr",CredHistr,2,TrHs2)) begin
                if ((CredHistr.RecordNr!=IVr.SerNr) or (CredHistr.RecordType!=0)) then begin
                  TrHs2 = false;
                end;
                if (TrHs2 and CredHistr.ArtCode==IVrw.ArtCode) then begin
                  foundf = true;
                  logforadmin(0,"IV For Cred  " & IVr.SerNr & " todate " & todate);
                  t = GetCredHistOpenValueOnDate(CredHistr.SerNr,blankd);
                  if(CMBuyOutb.DoNotCreditlastDayInvoices==0)then begin
                    if(IVr.PayDate>=todate and t>0 or creditanyvay)then begin
                      creditthisinvoice = true;
                    end;
                  end else begin
                    if(IVr.PayDate>todate and t>0 or creditanyvay)then begin
                      creditthisinvoice = true;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
      
      if(creditthisinvoice)then begin
        recordcopy(setIVr,IVr);
        mtrw = matrowcnt(setIVr);
        clearvector(vIVItemOpenAmmount);
        clearvector(vItemsToPay);
        checkIfInvoiceFromAgreement(IVr,vIVItemOpenAmmount)
        for(i=0;i<mtrw;i=i+1)begin
          matrowget(setIVr,i,IVrw);
          logtext(0,"IVrw.ArtCode " & IVrw.ArtCode & " sum " & vIVItemOpenAmmount[IVrw.ArtCode]);
          IVrw.Price = vIVItemOpenAmmount[IVrw.ArtCode];
          IVrw.Sum = vIVItemOpenAmmount[IVrw.ArtCode];
          if(intcredsum>0 and IVrw.ArtCode==intItem)then begin
            IVrw.Sum = intcredsum;            
          end;
          vItemsToPay[IVrw.ArtCode] = vItemsToPay[IVrw.ArtCode] + IVrw.Sum;
          matrowput(setIVr,i,IVrw);
        end;
        for(i=0;i<mtrw;i=i+1)begin
          matrowget(setIVr,i,IVrw);
          if(IVrw.stp!=1 or blank(IVrw.ArtCode) or IVrw.Sum==0 or IVrw.Price==0 or !setinset(IVrw.ArtCode,itemtocredit))then begin
            if(IVrw.stp==1 and nonblank(IVrw.ArtCode))then begin
              nocreditsum[IVrw.ArtCode] = nocreditsum[IVrw.ArtCode] + IVrw.Sum;
            end;
            matrowdelete(setIVr,i);
            i=i-1;
            mtrw = mtrw - 1;
          end else begin
            if(IVrw.ArtCode==princItem)then begin
              if(IVrw.stp==1 and nonblank(IVrw.ArtCode))then begin
                nocreditsum[IVrw.ArtCode] = nocreditsum[IVrw.ArtCode] + IVrw.Sum;
              end;
            end;
          end;
        end;
        setIVr.SerNr = -1;
        setIVr.OKFlag = 0;
        setIVr.NoInterestFlag = 1;

        foundf = false;
        
        rwcnt2 = matrowcnt(setIVr);
        for(j=0;j<rwcnt2;j=j+1)begin
          matrowget(setIVr,j,IV2rw);
          if(IV2rw.Sum>0 and nonblank(IV2rw.ArtCode))then begin
            foundf = true;
          end;
        end;
        logtext(0,"reconcile found " & foundf);

        if(foundf)then begin
          recordnew(IPr);
          IPr.TransDate = todate;
          IPr.SerNr = NextSerNr("IPVc",IPr.TransDate,-1,false,"");
          IPr.RegDate = CurrentDate;
          IPr.OKFlag = 0;
          IPr.PayMode = CIb.PaymentMode;
          IPPastePayMode(IPr);
          
          logtext(0,"IPPastePayMode");
          
          ClearRow(IPr,IPrw,1);
          IPrw.InvoiceNr = IVr.SerNr;
          logtext(0,"IVr.SerNr " & IVr.SerNr);
          MatRowPut(IPr,0,IPrw);
          PasteInvIn2IPr(IPr,0,IPr.TransDate,chk,false,installmentf);
          DistributeCredHistValues(IPr,0);
          
          
          mtrw = matrowcnt(IPr);
          logtext(0,"mtrw " & mtrw);
          for(i=0;i<mtrw;i=i+1)begin
            matrowget(IPr,i,IPrw);
            logtext(0,"IPrw.CredHistItem " & IPrw.CredHistItem & " " & vItemsToPay[IPrw.CredHistItem]);
            if(nonblank(IPrw.CredHistItem))then begin
              if(vItemsToPay[IPrw.CredHistItem]>0)then begin
                if(vItemsToPay[IPrw.CredHistItem]!=IPrw.RecVal)then begin
                  IPrw.RecVal = vItemsToPay[IPrw.CredHistItem];
                  MatRowPut(IPr,i,IPrw);
                  IPVc_PasteRecVal(IPr,i);
                  IPSumup(IPr);
                end;
              end else begin
                matrowdelete(IPr,i);
                mtrw = mtrw - 1;
                i = i - 1;
              end;
            end;
          end;
          mtrw = matrowcnt(IPr);
          if(mtrw>0)then begin
            logtext(0,"recordinsert " & IPr.SerNr);
            recordinsert(IPr,true);
            recordcopy(oldIPr,IPr);
            IPr.OKFlag = 1;
            recordupdate(oldIPr,IPr,true);
          end;
        end;
        
      end;
    end;    
  end;
  
return;
end;


global updating procedure CreditThisInvoiceFutureFees(record IVVc IVr,vector val vFutFeesSums,vector val vToBal,date todate,integer changeinvtype)
begin
  array string 20 aFutFeesSums;
  record IVVc setIVr,oldIVCreditr,IVCreditr;
  row IVVc IVrw,IV2rw;
  longint res;
  integer rwcnt,i;
  
  
  res = CreateCreditNoteIV(IVr,kInvoiceTypeCredit,IVCreditr,"",false);
  IVCreditr.InvDate = todate;
  IVCreditr.TransDate = IVCreditr.InvDate;
  IVCreditr.PayDate = IVCreditr.InvDate;
  logforadmin(0,"res " & res & " cred SerNr " & IVCreditr.SerNr & " IVCreditr.InvDate " & IVCreditr.InvDate);
  if (res==0) then begin
    IVCreditr.SerNr = NextSerNr("IVVc",IVCreditr.InvDate,-1,false,"");
    IVCreditr.IsChangeAgrInvoice = changeinvtype;
    logtext(0,"Generated sernr " & IVCreditr.SerNr);
    RecordInsert(IVCreditr,true);
    if(IVCreditr.SerNr>-1)then begin
      recordcopy(oldIVCreditr,IVCreditr);
    end;
    rwcnt = matrowcnt(IVCreditr);
    for(i=0;i<rwcnt;i=i+1)begin
      matrowget(IVCreditr,i,IVrw);
      if((blank(IVrw.ArtCode) and IVrw.stp==1) or IVrw.stp==kInvoiceRowTypeHidden)then begin
        matrowdelete(IVCreditr,i);
        i = i - 1;
        rwcnt = rwcnt - 1;
      end;
    end;
    rwcnt = matrowcnt(IVCreditr);
    for(i=0;i<rwcnt;i=i+1)begin
      matrowget(IVCreditr,i,IVrw);
      if(IVrw.stp==kInvoiceRowTypeNormal)then begin
        if(vFutFeesSums[IVrw.ArtCode]!=0)then begin
          IVrw.Price = vFutFeesSums[IVrw.ArtCode];
          IVrw.Sum = vFutFeesSums[IVrw.ArtCode];
          MatRowPut(IVCreditr,i,IVrw);
          IVDchsum(IVCreditr,i);
        end else begin
          if(vToBal[IVrw.ArtCode]!=0)then begin
            IVrw.Price = vToBal[IVrw.ArtCode];
            IVrw.Sum = vToBal[IVrw.ArtCode];
            MatRowPut(IVCreditr,i,IVrw);
            IVDchsum(IVCreditr,i);
          end else begin
            matrowdelete(IVCreditr,i);
            i=i-1;
            rwcnt = rwcnt - 1;
          end;
        end;
      end;
    end;
    IVSumup(IVCreditr,true);   
    IVCreditr.OKFlag = 1;
    if(IVCreditr.SerNr>-1)then begin
      recordupdate(oldIVCreditr,IVCreditr,true);
    end;
  end;
  
  
  
return;
end;

global updating procedure ReconcileThisInvoiceFutureFees(record IVVc IVr,vector val vFutFeesSums,vector val vToBal,date todate)
begin
  array string 20 aFutFeesSums;
  record IVVc setIVr,oldIVCreditr,IVCreditr;
  row IVVc IVrw,IV2rw;
  record CMInvoicingBlock CIb;
  record IPVc IPr,oldIPr;
  row IPVc IPrw;
  boolean installmentf;
  integer i,mtrw,rwcnt;
  val chk;
  
  blockload(CIb);
  
  
  recordnew(IPr);
  IPr.TransDate = todate;
  IPr.SerNr = NextSerNr("IPVc",IPr.TransDate,-1,false,"");
  IPr.RegDate = CurrentDate;
  IPr.OKFlag = 0;
  IPr.PayMode = CIb.PaymentMode;
  IPPastePayMode(IPr);
  
  logtext(0,"IPPastePayMode");
  
  ClearRow(IPr,IPrw,1);
  IPrw.InvoiceNr = IVr.SerNr;
  logtext(0,"IVr.SerNr " & IVr.SerNr);
  MatRowPut(IPr,0,IPrw);
  PasteInvIn2IPr(IPr,0,IPr.TransDate,chk,false,installmentf);
  DistributeCredHistValues(IPr,0);
  
  
  mtrw = matrowcnt(IPr);
  logtext(0,"mtrw " & mtrw);
  for(i=0;i<mtrw;i=i+1)begin
    matrowget(IPr,i,IPrw);
    logtext(0,"IPrw.CredHistItem " & IPrw.CredHistItem & " " & vFutFeesSums[IPrw.CredHistItem]);
    if(nonblank(IPrw.CredHistItem))then begin
      if(vFutFeesSums[IPrw.CredHistItem]>0)then begin
        if(vFutFeesSums[IPrw.CredHistItem]!=IPrw.RecVal)then begin
          IPrw.RecVal = vFutFeesSums[IPrw.CredHistItem];
          MatRowPut(IPr,i,IPrw);
          IPVc_PasteRecVal(IPr,i);
          IPSumup(IPr);
        end;
      end else begin
        if(vToBal[IPrw.CredHistItem]>0)then begin
          if(vToBal[IPrw.CredHistItem]!=IPrw.RecVal)then begin
            IPrw.RecVal = vToBal[IPrw.CredHistItem];
            MatRowPut(IPr,i,IPrw);
            IPVc_PasteRecVal(IPr,i);
            IPSumup(IPr);
          end;
        end else begin
          matrowdelete(IPr,i);
          IPSumup(IPr);
          mtrw = mtrw - 1;
          i = i - 1;
        end;
      end;
    end;
  end;
  mtrw = matrowcnt(IPr);
  if(mtrw>0)then begin
    logtext(0,"recordinsert " & IPr.SerNr);
    recordinsert(IPr,true);
    recordcopy(oldIPr,IPr);
    IPr.OKFlag = 1;
    recordupdate(oldIPr,IPr,true);
  end;
  
  
return;
end;


global updating procedure AgrChangeCloseOldInvoices(record RcVc RepSpec,record CredManVc CredManr,Date todate,record ORVc ORr,string itemsclass,var vector val nocreditsum)
begin
  record IVVc IVr,setIVr,oldIVCreditr,IVCreditr;
  row IVVc IVrw,IV2rw;
  integer i,rwcnt,rwcnt2,j,mtrw;
  boolean TrHs,testf,isfullpayed,creditanyvay;
  record ARVc ARr;
  integer credflag;
  record CredHistVc CredHistr,CredHist2r;
  boolean TrHs2,foundf,proceedinv,isoldinvoice;
  record INVc INr;
  string 255 tstr,itemtocredit,futurefeesitems;
  string 20 demandItem,insurItem,prematureItem,intItem,feesItem,princItem;
  val t,tt,tot1,tot2,tot3,intcredsum;
  longint t2,res;
  date blankd;
  vector val vFutFeesSums,vToBal,vBlank;
  array string 20 aFutFeesSums,aToBal;
  record CredManSetBlock CMb;
  record CMBuyOutBlock CMBuyOutb;
  record CMInvoicingBlock CIb;
    
  logforadmin(0,"========AgrChangeCloseOldInvoices");
  blockload(CMb);
  blockload(CMBuyOutb);
  blockload(CIb);
  
  //Search all items for work
  
  demandItem = CIb.LetterOfDemand;
  insurItem = CIb.InsuranceCost;
  prematureItem = CIb.BuyOutItem;
  intItem = CMb.RateItem;
  feesItem = CMb.LateRateItem;
  princItem = CMb.InstalmentItem;
  if(nonblank(itemsclass))then begin
    futurefeesitems = "";
    
    while(loopmain(INr,1,true))begin
      if(setinset(itemsclass,INr.DispGroups))then begin
        futurefeesitems = futurefeesitems & INr.Code & ","; 
      end;
    end;
  end;
  logforadmin(0,"futurefeesitems " & futurefeesitems);
  logforadmin(0,"demandItem " & demandItem);
  logforadmin(0,"insurItem " & insurItem);
  logforadmin(0,"prematureItem " & prematureItem);
  logforadmin(0,"intItem " & intItem);
  logforadmin(0,"feesItem " & feesItem);
  logforadmin(0,"princItem " & princItem);

  //Search all Open Invoices
  
  logtext(0,"Search all Open Invoices");
  
  IVr.CustCode = CredManr.CustCode;
  TrHs = true;
  while(loopkey("CustCode",IVr,1,TrHs))begin
    
    testf = true;
    if(IVr.CustCode!=CredManr.CustCode)then begin TrHs = false; testf = false; end;
    if(IVr.CustCredManNr!=CredManr.SerNr)then begin testf = false; end;
    if(IVr.OKFlag==0)then begin testf = false; end;
    if(IVr.Invalid==1)then begin testf = false; end;
    if(IVr.InvType==kInvoiceTypeCredit)then begin testf = false; end;
    if(IVr.CredFromDate>todate)then begin testf = false; end;
    if(blankdate(IVr.CredToDate))then begin testf = false; end;
   
    if(CMBuyOutb.DoNotCreditlastDayInvoices==1)then begin
      if(IVr.PayDate==todate)then begin
        testf = false;
      end;
    end;
    
    if(testf)then begin
      ARr.InvoiceNr = IVr.SerNr;
      if(!readfirstmain(ARr,1,true))then begin
        testf = false;
      end;
    end;
    
    if(testf)then begin 
      isoldinvoice = false;
           
      logforadmin(0,"IVr.CredFromDate " & IVr.CredFromDate);
      logforadmin(0,"IVr.CredToDate " & IVr.CredToDate);
      
      if(IVr.CredToDate<=todate)then begin
        isoldinvoice = true;
      end;
      
      logforadmin(0,IVr.SerNr & " isoldinvoice " & isoldinvoice);
      
      
      clearvector(vFutFeesSums);
      clearvector(vToBal);
      
      proceedinv = false;
      rwcnt = matrowcnt(IVr);
      for(i=0;i<rwcnt;i=i+1)begin
        matrowget(IVr,i,IVrw);
        if(IVrw.stp==kInvoiceRowTypeNormal and nonblank(IVrw.ArtCode))then begin
          resetloop(CredHistr);
          CredHistr.RecordNr = IVr.SerNr;
          CredHistr.RecordType = 0;
          TrHs2 = true;
          foundf = false;
          while (LoopKey("RecordNr",CredHistr,2,TrHs2)) begin
            if ((CredHistr.RecordNr!=IVr.SerNr) or (CredHistr.RecordType!=0)) then begin
              TrHs2 = false;
            end;
            if (TrHs2 and CredHistr.ArtCode==IVrw.ArtCode) then begin
              foundf = true;
              t = GetCredHistOpenValueOnDate(CredHistr.SerNr,blankd);
              if(t>0)then begin
                
                if(RepSpec.flags[4]==1 or isoldinvoice==false)then begin//Distribute Debts to Future Fees
                  if(setinset(IVrw.ArtCode,futurefeesitems))then begin
                    logforadmin(0,IVrw.ArtCode & " future fees " & t);
                    vFutFeesSums[IVrw.ArtCode] = vFutFeesSums[IVrw.ArtCode] + t;
                    proceedinv = true;
                  end;
                end;
                
                if(RepSpec.sm1==1 or isoldinvoice==false)then begin//Added to New Balance
                  if(!setinset(IVrw.ArtCode,futurefeesitems))then begin
                    vToBal[IVrw.ArtCode] = vToBal[IVrw.ArtCode] + t;
                    logforadmin(0,IVrw.ArtCode & " to balance " & t);
                    proceedinv = true;
                  end;
                end;
                if(!setinset(IVrw.ArtCode,futurefeesitems))then begin
                  nocreditsum[IVrw.ArtCode] = nocreditsum[IVrw.ArtCode] + t;
                end;
              end;
            end;
          end;
        end;
      end;
      
      if(proceedinv)then begin
        logforadmin(0,"Need to reform this invoices " & IVr.SerNr);
        
        cleararray(aFutFeesSums);
        cleararray(aToBal);
        getvectortags(vFutFeesSums,aFutFeesSums);
        getvectortags(vToBal,aToBal);
        
        for(i=0;i<aFutFeesSums.length;i=i+1)begin
          logforadmin(0,"Future Fees Item " & aFutFeesSums[i] & " sum " & vFutFeesSums[aFutFeesSums[i]]);
        end;
        for(i=0;i<aToBal.length;i=i+1)begin
          logforadmin(0,"To balance Item " & aToBal[i] & " sum " & vToBal[aToBal[i]]);
        end;
        
        if(isoldinvoice)then begin
          if(aFutFeesSums.length>0)then begin
            if(CMBuyOutb.InterestCredOrPay==0)then begin
              CreditThisInvoiceFutureFees(IVr,vFutFeesSums,vToBal,IVr.CredToDate,1);//Credit future fees and instaltment
            end else begin
              ReconcileThisInvoiceFutureFees(IVr,vFutFeesSums,vBlank,IVr.CredToDate);
              if(aToBal.length>0)then begin
                CreditThisInvoiceFutureFees(IVr,vBlank,vToBal,IVr.CredToDate,1);
              end;
            end;
          end else begin
            if(aToBal.length>0)then begin
              CreditThisInvoiceFutureFees(IVr,vBlank,vToBal,IVr.CredToDate,1);
            end;
          end;
        end else begin
          if(aFutFeesSums.length>0 or aToBal.length>0)then begin
            CreditThisInvoiceFutureFees(IVr,vFutFeesSums,vBlank,todate,2);//Credit future fees and instaltment
          end;
        end;
        
      end;
    end;    
  end;
  
  
return;
end;

global updating procedure CreditOpenInvoices(record CredManVc CredManr,Date todate,record ORVc ORr,string itemsclass,var vector val nocreditsum)
begin
  record IVVc IVr,setIVr,oldIVCreditr,IVCreditr;
  row IVVc IVrw,IV2rw;
  integer i,rwcnt,rwcnt2,j,mtrw;
  boolean TrHs,testf,isfullpayed,creditanyvay;
  record ARVc ARr;
  integer credflag;
  record CredHistVc CredHistr,CredHist2r;
  boolean TrHs2,foundf,creditthisinvoice;
  record INVc INr;
  string 255 tstr,princItem,itemtocredit,intItem;
  val t,tt,tot1,tot2,tot3,intcredsum;
  longint t2,res;
  date blankd;
  vector val vIVItemOpenAmmount;
  record CredManSetBlock CMb;
  record CMBuyOutBlock CMBuyOutb;
  
  
  blockload(CMb);
  blockload(CMBuyOutb);
  
  princItem = CMb.InstalmentItem;
  intItem = CMb.RateItem;
  itemtocredit = princItem;
    
  if(nonblank(itemsclass))then begin
    itemtocredit = "";
    if(CMBuyOutb.InterestCredOrPay==0)then begin
      creditanyvay = true;
      while(loopmain(INr,1,true))begin
        if(setinset(itemsclass,INr.DispGroups))then begin
          itemtocredit = itemtocredit & INr.Code & ","; 
        end;
      end;
      if(ORr.InvMark==1)then begin
        itemtocredit = itemtocredit & "," & intItem;
      end;
    end;
  end else begin
    if(ORr.InvMark==1)then begin
      itemtocredit = itemtocredit & "," & intItem;
    end;
  end;
  
  logforadmin(0,"CreditOpenInvoices");
  
  IVr.CustCode = CredManr.CustCode;
  TrHs = true;
  while(loopkey("CustCode",IVr,1,TrHs))begin
    testf = true;
    if(IVr.CustCode!=CredManr.CustCode)then begin TrHs = false; testf = false; end;
    if(IVr.CustCredManNr!=CredManr.SerNr)then begin testf = false; end;
    if(IVr.OKFlag==0)then begin testf = false; end;
    if(IVr.Invalid==1)then begin testf = false; end;
    if(IVr.InvType==kInvoiceTypeCredit)then begin testf = false; end;
    
    
    if(testf)then begin
      creditthisinvoice = false;
      isfullpayed = false;
      ARr.InvoiceNr = IVr.SerNr;
      if(!readfirstmain(ARr,1,true))then begin
        isfullpayed = true;
      end;
      credflag = 1;
      if(IVr.InvType==kInvoiceTypeCredit)then begin
        credflag = -1;
      end;
      
      rwcnt = matrowcnt(IVr);
      for(i=0;i<rwcnt;i=i+1)begin
        matrowget(IVr,i,IVrw);
        if(IVrw.stp==kInvoiceRowTypeNormal and nonblank(IVrw.ArtCode))then begin
          if(isfullpayed)then begin

          end else begin
            if(IVr.InvType!=kInvoiceTypeCredit)then begin
              resetloop(CredHistr);
              CredHistr.RecordNr = IVr.SerNr;
              CredHistr.RecordType = 0;
              TrHs2 = true;
              foundf = false;
              while (LoopKey("RecordNr",CredHistr,2,TrHs2)) begin
                if ((CredHistr.RecordNr!=IVr.SerNr) or (CredHistr.RecordType!=0)) then begin
                  TrHs2 = false;
                end;
                if (TrHs2 and CredHistr.ArtCode==IVrw.ArtCode) then begin
                  foundf = true;
                  logforadmin(0,"IV For Cred  " & IVr.SerNr & " todate " & todate);
                  t = GetCredHistOpenValueOnDate(CredHistr.SerNr,blankd);
                  if(CMBuyOutb.DoNotCreditlastDayInvoices==0)then begin
                    if(IVr.PayDate>=todate and t>0 or creditanyvay)then begin
                      creditthisinvoice = true;
                    end;
                  end else begin
                    if(IVr.PayDate>todate and t>0 or creditanyvay)then begin
                      creditthisinvoice = true;
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
      
      if(creditthisinvoice)then begin
        logforadmin(0,"TryToCredit Invoice " & IVr.SerNr);
        recordcopy(setIVr,IVr);
        mtrw = matrowcnt(setIVr);
        checkIfInvoiceFromAgreement(IVr,vIVItemOpenAmmount)
        for(i=0;i<mtrw;i=i+1)begin
          matrowget(setIVr,i,IVrw);
          IVrw.Price = vIVItemOpenAmmount[IVrw.ArtCode];
          IVrw.Sum = vIVItemOpenAmmount[IVrw.ArtCode];
          if(intcredsum>0 and IVrw.ArtCode==intItem)then begin
            IVrw.Sum = intcredsum;
          end;
          matrowput(setIVr,i,IVrw);
        end;
        for(i=0;i<mtrw;i=i+1)begin
          matrowget(setIVr,i,IVrw);
          if(IVrw.stp!=1 or blank(IVrw.ArtCode) or IVrw.Sum==0 or IVrw.Price==0 or !setinset(IVrw.ArtCode,itemtocredit))then begin
            if(IVrw.stp==1 and nonblank(IVrw.ArtCode))then begin
              nocreditsum[IVrw.ArtCode] = nocreditsum[IVrw.ArtCode] + IVrw.Sum;
            end;
            matrowdelete(setIVr,i);
            i=i-1;
            mtrw = mtrw - 1;
          end else begin
            if(IVrw.ArtCode==princItem)then begin
              if(IVrw.stp==1 and nonblank(IVrw.ArtCode))then begin
                nocreditsum[IVrw.ArtCode] = nocreditsum[IVrw.ArtCode] + IVrw.Sum;
              end;
            end;
          end;
        end;
        setIVr.SerNr = -1;
        setIVr.OKFlag = 0;
        setIVr.NoInterestFlag = 1;

        foundf = false;
        
        rwcnt2 = matrowcnt(setIVr);
        for(j=0;j<rwcnt2;j=j+1)begin
          matrowget(setIVr,j,IV2rw);
          if(IV2rw.Sum>0 and nonblank(IV2rw.ArtCode))then begin
            foundf = true;
          end;
        end;
        
        recordnew(IVCreditr);
        logforadmin(0,"todate " & todate);
        
        logforadmin(0,"foundf " & foundf);
        if (foundf) then begin
          if ((IVr.OKFlag!=0) and (IVr.InvType!=kInvoiceTypeCredit and IVr.InvType!=kInvoiceTypeCreditSpecialSales)) then begin
            res = CreateCreditNoteIV(IVr,kInvoiceTypeCredit,IVCreditr,"",false);
            IVCreditr.IsChangeAgrInvoice = 1;
            if(IVCreditr.PayDate<IVCreditr.InvDate)then begin
              IVCreditr.PayDate = IVCreditr.InvDate;
            end;
            IVCreditr.InvDate = todate;
            logforadmin(0,"res " & res & " cred SerNr " & IVCreditr.SerNr);
            if (res==0) then begin
              IVCreditr.SerNr = NextSerNr("IVVc",IVCreditr.InvDate,-1,false,"");
              RecordInsert(IVCreditr,true);
              if(IVCreditr.SerNr>-1)then begin
                recordcopy(oldIVCreditr,IVCreditr);
              end;
              IVCreditr.CreditPrincipleRule = setIVr.CreditPrincipleRule;
              rwcnt = matrowcnt(IVCreditr);
              for(i=0;i<rwcnt;i=i+1)begin
                matrowget(IVCreditr,i,IVrw);
                if((blank(IVrw.ArtCode) and IVrw.stp==1) or IVrw.stp==kInvoiceRowTypeHidden)then begin
                  matrowdelete(IVCreditr,i);
                  i=i-1;
                  rwcnt = rwcnt - 1;
                end;
              end;
              rwcnt = matrowcnt(IVCreditr);
              for(i=0;i<rwcnt;i=i+1)begin
                matrowget(IVCreditr,i,IVrw);
                rwcnt2 = matrowcnt(setIVr);
                foundf = false;
                for(j=0;j<rwcnt2;j=j+1)begin
                  matrowget(setIVr,j,IV2rw);
                  if(IV2rw.Sum>0 and nonblank(IV2rw.ArtCode) and IVrw.ArtCode==IV2rw.ArtCode)then begin
                    foundf = true;
                    IVrw.Price = IV2rw.Sum;
                    IVrw.Sum = IV2rw.Sum;
                    MatRowPut(IVCreditr,i,IVrw);
                    IVDchsum(IVCreditr,i);
                  end;
                end;
                if(foundf==false and IVrw.stp!=kInvoiceRowTypeCredit)then begin
                  matrowdelete(IVCreditr,i);
                  i=i-1;
                  rwcnt = rwcnt - 1;
                end;
              end;
              IVSumup(IVCreditr,true);   
              IVCreditr.OKFlag = 1;
              if(IVCreditr.SerNr>-1)then begin
                recordupdate(oldIVCreditr,IVCreditr,true);
              end;
            end;
          end;
        end;
      end;
    end;    
  end;
  
return;
end;

global updating procedure CreateSplitInvoice(record CredManVc CredManr,Date todate,record ORVc ORr,string itemsclass,date fromdate,date datetodate,longint lastinvnr)
begin
  record IVVc IVr,setIVr,oldIVCreditr,IVCreditr;
  row IVVc IVrw,IV2rw;
  integer i,rwcnt,rwcnt2,j,mtrw;
  boolean TrHs,testf,isfullpayed,creditanyvay;
  record ARVc ARr;
  integer credflag;
  record CredHistVc CredHistr,CredHist2r;
  boolean TrHs2,foundf,creditthisinvoice;
  record INVc INr;
  string 255 tstr,princItem,itemtocredit,intItem,spec;
  val t,tt,tot1,tot2,tot3,intcredsum;
  longint t2,res;
  date blankd;
  vector val vIVItemOpenAmmount;
  record CredManSetBlock CMb;
  record CMBuyOutBlock CMBuyOutb;
  
  blockload(CMb);
  blockload(CMBuyOutb);
    
  IVr.SerNr = lastinvnr;
  if(readfirstmain(IVr,1,true))then begin
    SetupLoanInvoice3(CredManr,CMb,setIVr,todate,fromdate,addday(todate,-1),true,false,"",1,true,IVr.PayDeal,IVr.SalesMan);
    //recordcopy(setIVr,IVr);
    
    //setIVr.SerNr = NextSerNr("IVVc",CurrentDate,-1,false,"");
    setIVr.CredToDate = addday(todate,-1);
    rwcnt = matrowcnt(IVr);   
    GetItemName(CMb.RateItem,spec);
    SetupInvoiceRowAndAdd(CredManr,setIVr,CMb.RateItem,spec,1,ORr.TotGP,blankval,14,-1);
    spec = "";
        
    StoreLoanInvoice(setIVr,CredManr);
  end;
  
  
return;
end;


global
updating procedure DoBuyOutAgreement(record CredManVc CredManr,Date td,Boolean creditf,var record IVVc firstIVr,record ORVc ORr)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record IVVc IVr,oldIVr,oIVr,tmpIVr;
  record CMInvoicingBlock CIb;
  Date sd;
  val openamount,lateamount;
  Integer latedays,i,rwcnt;
  array string 255 lateformula;
  Date calcsd;
  row IVVc IVrw;
  val credval,ncredval;
  Longint ivnr;
  vector val vCredVal;
  transaction Boolean gIsBuyOutInvoice; 
  vector val tmpval;
  record CMBuyOutBlock CMBOb;
    
  gIsBuyOutInvoice = true;

  if (CredManr.OKFlag==1 and CredManr.Approved==1) then begin
    BlockLoad(CMb);
    BlockLoad(CIb);
     BlockLoad(CMBOb);
    BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
    CreditOpenInvoices(CredManr,td,ORr,"",tmpval);// Edit ************************** BPI Ukraine - KramarAlexandr - 03, 18 08 2021 y. at 2:26:56 PM
    
    
    
    CreateBuyOutInvoiceFromPlan(CredManr,CMb,CredManPayPlanr,td,IVr,false,sd,false,ORr);
    rwcnt = matrowcnt(IVr);
    if(ORr.ShipMark==1)then begin
      CM_AddPrepayments(IVr,CredManr,CIb);
    end;
    if (IVr.SerNr>-1) then begin
      CheckAndAddHiddenPrinciple(IVr,CIb);
      if (IVr.Sum4>0) then begin
        if (CIb.OverdueIVType>0) then begin
          GetCredManOverdueInvoices(CredManr,CMb,td,sd,latedays,lateamount,lateformula,true,false,calcsd);
          SetupLoanInvoice(CredManr,CMb,oIVr,td,calcsd,td,true,false,"",2,true);
          AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
          SetupOverdueLangCode(oIVr,CredManr);
          StoreLoanInvoice(oIVr,CredManr);
        end;
        SetupBuyoutLangCode(IVr,CredManr);
        StoreLoanInvoice(IVr,CredManr);
        if (creditf) then begin
          credval = GetCreditedInterest(CredManr,td,ivnr);
          if (credval>0) then begin
            tmpIVr.SerNr = ivnr;
            if (ReadFirstMain(tmpIVr,1,true)) then begin
              CreditAndOKInvoice(ivnr,1,ncredval,vCredVal,credval,true,td,CMb.RateItem,GetInvoicePeriodString(CIb,tmpIVr.CredFromDate,tmpIVr.CredToDate),GetInvoicePeriodString(CIb,td,tmpIVr.CredToDate));
            end;
          end;
        end;
        GenerateAgreementSchedule(CredManr,true,true);
        RecordCopy(firstIVr,IVr);
      end else begin
        logforadmin(0,"Failed to store Invoice. Sum is 0");
      end;
    end else begin
      logforadmin(0,"Failed to store Invoice. No Serial Number. Check Number Series");
    end;
  end;
  
  logtext(0,"CheckCredManFinished from DoBuyOutAgreement");
  CheckCredManFinished(CredManr.SerNr,ORr.OrdDate);
  
  return;
end;

procedure CheckUnpaidInvoices(record CredManVc CredManr,var val dueamount,var val openamount)
begin
  record ARVc ARr;
  record IVVc IVr;
  Boolean TrHs;

  dueamount = 0;
  openamount = 0;
  //didn't add a new index in order to save db size. This won't be so expensive.
  
  TrHs = true;
  IVr.CustCode = CredManr.CustCode;
  while (LoopKey("CustCode",IVr,1,TrHs)) begin
    if (IVr.CustCode!=CredManr.CustCode) then begin
      TrHs = false;
    end else begin
      if (IVr.CustCredManNr==CredManr.SerNr) then begin
        ARr.InvoiceNr = IVr.SerNr;
        if (ReadFirstMain(ARr,1,true)) then begin
          if (ARr.DueDate<CurrentDate) then begin
            dueamount = dueamount + ARr.RVal;
          end;
          openamount = openamount + ARr.RVal;
        end;
      end;
    end;
  end;

  return;
end;

global
function val GetActualBalance(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,Boolean openf)
begin
  val res,curbal;
  row CredManPayPlanVc CredManPayrw;
  Integer rwcnt,i;
  val openamount;

  if (GetInterestPaymentType(CredManr)==2) then begin
    curbal = 0;
  end else begin
    curbal = CredManr.InvSum4;
  end;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayrw);
    if (CredManPayrw.PlanType>=5 and CredManPayrw.PlanType!=9) then begin
      if (TypeAffectsBalance(CredManPayrw.PlanType)) then begin
        curbal = curbal - CredManPayrw.Sum;
      end;
      if (CredManPayrw.PlanType==kEventTypePayout) then begin
        curbal = curbal + CredManPayrw.Sum;
      end;
      if (CredManPayrw.PlanType==kEventTypeIssueInstalment or IsPartialBuyoutType(CredManPayrw.PlanType)) then begin
        openamount = openamount + CredManPayrw.OpenAmount;
      end;
    end;
    if (CredManPayrw.PlanType<5) then begin
      i = rwcnt;
    end;
    /*
    if (CredManPayrw.TransDate>=CurrentDate) then begin
      i = rwcnt;
    end;
    */
  end;

  if (openf) then begin
    curbal = curbal + openamount;
  end;

  GetActualBalance = curbal;
  return;
end;

function val GetPrepaymentValue(record CredManVc CredManr)
begin
  record ARPayVc ARPayr;
  Boolean TrHs;
  val res;
  
  ARPayr.CustCode = CredManr.CustCode;
  TrHs = true;
  while (LoopKey("CustCode",ARPayr,1,TrHs)) begin
    if (ARPayr.CustCode!=CredManr.CustCode) then begin
      TrHs = false;
    end else begin
      if (PMCodeMatches(CredManr,ARPayr.CUPNr)) then begin
        res = res + ARPayr.RVal;
      end;
    end;
  end;

  GetPrepaymentValue = res;
  return;
end;

function val FindUpdaidCredHistType(Longint ivnr)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  val res;
  
  TrHs = true;
  CredHistr.RecordNr = ivnr;
  CredHistr.RecordType = 0;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordNr!=ivnr or CredHistr.RecordType!=0) then begin
      TrHs = false;
    end else begin
      if (CredHistr.ChargeType==kEventTypeIssueInterest and CredHistr.PaidFlag==0) then begin
        res = res + GetCredHistOpenAmount(CredHistr,kEventTypeIssueInterest);
      end;
    end;
  end;

  FindUpdaidCredHistType = res;
  return;
end;

function val GetInterestAmount(record CredManVc CredManr,Date td)
begin
  val res;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt;
  Integer diff,diff2;
  
  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    rwcnt = MatRowCnt(CSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CSr,i,CSrw);
      if (CSrw.FromDate<=td) then begin
        if (CSrw.Interest>0) then begin
          if (CSrw.Invoiced==1) then begin
            res = res + FindUpdaidCredHistType(CSrw.InvoiceNr);
          end else begin
            if (CSrw.ToDate>td) then begin
              diff = DateDiff(CSrw.ToDate,CSrw.FromDate)+1;
              diff2 = DateDiff(td,CSrw.FromDate)+1;
              res = res + CSrw.Interest*diff2/diff;
            end else begin
              res = res + CSrw.Interest;
            end;
          end;
        end;
      end else begin
        i = rwcnt;
      end;
    end;
  end;

  GetInterestAmount = res;
  return;
end;

//same as GetLateDaysInPeriod except returns amounts incl. of VAT
function Integer GetLateDaysInPeriod2(record CredHistVc CredHistr,Date sd,Date ed,var val dueamount)
begin
  Boolean TrHs;
  record CredHistVc CredPayr;
  val paysum;
  Integer res;
  val vatprc,vatval,vatexclprc,vatinclprc,rowtax;
  record IVVc IVr;
  row IVVc IVrw;
  Integer i,rwcnt;
  string 255 vatcode;

  dueamount = blankval; 
  paysum = CredHistr.Sum;
  IVr.SerNr = CredHistr.RecordNr;
  if (ReadFirstMain(IVr,1,true)) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.CredHistNr==CredHistr.SerNr) then begin
        //InvVat(1,1,IVr.NoTAXonVAT,IVr.ExportFlag,IVrw.VATCode,CredHistr.Sum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);
        //paysum = paysum - vatval;
        vatcode = IVrw.VATCode;
        i = rwcnt;
      end;
    end;
  end;

  TrHs = true;
  CredPayr.PreviousNr = CredHistr.SerNr;
  while (LoopKey("PreviousNr",CredPayr,1,TrHs)) begin
    if (CredPayr.PreviousNr!=CredHistr.SerNr) then begin
      TrHs = false;
    end else begin
      if (CredPayr.PayDate<=ed) then begin
        InvVat(1,1,IVr.NoTAXonVAT,IVr.ExportFlag,vatcode,CredPayr.Sum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);
        paysum = paysum - (CredPayr.Sum/* - vatval*/);
      end;
    end;
  end;
  if (paysum<0) then begin
    paysum = 0;
  end;
  if (paysum>0) then begin
    res = DateDiff(ed,CredHistr.PayDate);
    InvVat(1,1,IVr.NoTAXonVAT,IVr.ExportFlag,IVrw.VATCode,paysum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);
    paysum = paysum /*- vatval*/; //need amounts incl. of VAT
  end;
  dueamount = dueamount + paysum;

  GetLateDaysInPeriod2 = res;
  return;
end;

/**
chargetype=-1: any charge type
*/
global
procedure GetCredManLateAmounts2(record CredManVc CredManr,Date sd,Date ed,Integer chargetype,var Longint maxlatedays,var val dueamount,var val notdueamount,var Date limitdate)
begin
  string 255 res;
  record CredHistVc CredHistr;
  Boolean TrHs;
  Longint latedays;
  Date tmpdate;
  val t;
  integer keys;
  
  dueamount = 0;
  notdueamount = blankval;
  maxlatedays = 0;
  TrHs = true;
  CredHistr.CredManNr = CredManr.SerNr;
  if (chargetype==-1) then begin
    keys = 1;
  end else begin;
    CredHistr.ChargeType = chargetype;
    keys = 2;
  end;
  while (LoopKey("CredManChargeType",CredHistr,keys,TrHs)) begin
    if (chargetype==-1) then begin
      if (CredHistr.CredManNr!=CredManr.SerNr) then begin
        TrHs = false;
      end;
    end else begin
      if (CredHistr.CredManNr!=CredManr.SerNr or CredHistr.ChargeType!=chargetype) then begin
        TrHs = false;
      end;
    end;
    if (TrHs) then begin
      if ((CredHistr.RecordType==0) and (CredHistr.PaidFlag==0)) then begin
        logforadmin(0,"CredHistr " & CredHistr.SerNr & " PayDate=" & CredHistr.PayDate & " CredHistr.Sum=" & CredHistr.Sum & " CredHistr.PaidSum=" & CredHistr.PaidSum);
        if (CredHistr.PayDate<=ed) then begin
          latedays = GetLateDaysInPeriod2(CredHistr,sd,ed,t);
          dueamount = dueamount + t;
          /*
          if (dueamount>0 and latedays>=90) then begin
            tmpdate = AddDay(CredHistr.PayDate,90);
            if ((tmpdate<limitdate or blank(limitdate)) and tmpdate<ed) then begin
              limitdate = tmpdate;
            end;
          end;
          */
          maxlatedays = MAXLongint(maxlatedays,latedays);
        end else begin
          //if (CredHistr.TransDate<=ed) then begin
            latedays = GetLateDaysInPeriod2(CredHistr,sd,ed,t);
            notdueamount = notdueamount + t;
          //end;
        end;
      end;
    end;
  end;
  logforadmin(0,"GetCredManLateAmounts2 " & CredManr.SerNr & " sd=" & sd & " ed=" & ed & " " & StringFromSet(2010,chargetype) & " dueamount="& dueamount & " notdueamount=" & notdueamount & " maxlatedays=" & maxlatedays);
  return;
end;

/**
returns interest from the last DUE period till date specified
*/
function val GetLastDuePeriodInterest(record CredManVc CredManr, record CredManPayPlanVc CredManPayPlanr, date untildate)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  record IVVc IVr;
  record CredHistVc CredHistr;
  integer i,rwcnt,lasti;
  date lastduedate;
  val res,calcbal,t;
  boolean foundf,TrHs;
  Integer int_type;

  int_type = GetInterestPaymentType(CredManr);
  if (int_type==2) then begin
    calcbal = 0;
  end else begin
    calcbal = CredManr.InvSum4;
  end;
  foundf = false;
  //Get last interest invoice
  /*
  TrHs = true;
  CredHistr.CredManNr = CredManr.SerNr;
  CredHistr.RecordType = 0;
  while (LoopBackKey("CredManTypeDate",CredHistr,2,TrHs)) begin
    if ((CredHistr.CredManNr!=CredManr.SerNr) or (CredHistr.RecordType!=0)) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      if (CredHistr.ChargeType==kEventTypeIssueInterest) then begin
         if ((CredHistr.CredFromDate>=untildate) and (CredHistr.CredToDate<=???) and (CredHistr.PaidFlag==0)) then begin
           if (blankdate(lastduedate)) then begin
            lastduedate = CredHistr.CredFromDate;
           end else begin
             if (lastduedate>CredHistr.CredFromDate) then begin
               lastduedate = CredHistr.CredFromDate;
               foundf = true;
             end;
           end;
         end;
      end;
    end;
  end;
  
  */
  
  rwcnt = MatRowCnt(CredManPayPlanr);
//  CreateFile("GetLastDuePeriodInterest_" & CredManr.SerNr & ".txt");
//  ExportRecord(CredManPayPlanr);
  
  //ExportString("rwcnt");
  //ExportString(rwcnt);
  //NewLine;
  
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    switch (CredManPayPlanrw.PlanType) begin
      case kEventTypeIssueInterest: 
        if ((CredManPayPlanrw.FromDate<=untildate) and (untildate<=CredManPayPlanrw.ToDate)) then begin
          lastduedate = CredManPayPlanrw.FromDate;
          t = CredManPayPlanrw.Sum/((DateDiff(CredManPayPlanrw.ToDate,CredManPayPlanrw.FromDate)+1));
          t = t * (DateDiff(untildate,CredManPayPlanrw.FromDate)+1);
          i = rwcnt;
          foundf = true;
        end;
/*        
        if (CredManPayPlanrw.IssuedNr!=-1) then begin
          CredHistr.SerNr = CredManPayPlanrw.IssuedNr;
          if (ReadFirstMain(CredHistr,1,true)) then begin
            switch (CredHistr.RecordType) begin//invoice
              case 0:
                if (CredHistr.PaidSum<CredHistr.Sum) then begin
                  IVr.SerNr = CredHistr.RecordNr;
                  if (ReadFirstMain(IVr,1,true)) then begin
                    if ((lastduedate<IVr.PayDate) and (IVr.PayDate<=untildate)) then begin
                      lastduedate = IVr.PayDate;
                      lasti = i;
                      foundf = true;
                    end;
                  end;
                end;
            end;
          end;
        end;
        */
    end;
  end;
  
  if (foundf) then begin
    //MatRowGet(CredManPayPlanr,lasti,CredManPayPlanrw);
    //calc interest rate from CredManPayPlanrw.FromDate to  untildate
    //res = GetRateAmount(CredManr,CredManr.IntRate,kMonthTypeLast,CredManPayPlanrw.FromDate,untildate,calcbal,false,false);//last param fixeddays false?
    //res = GetRateAmount(CredManr,CredManr.IntRate,kMonthTypeLast,CredHistr.CredFromDate,untildate,calcbal,false,false);//last param fixeddays false?
    res = GetRateAmount(CredManr,CredManr.IntRate,kMonthTypeFirst,lastduedate,untildate,calcbal,false,false);//last param fixeddays false?
    logforadmin(0,"GetLastDuePeriodInterest: LAsti=" & lasti & " lastduedate=" & lastduedate & " FromDate=" & CredManPayPlanrw.FromDate & " untildate=" & untildate & " calcbal=" & calcbal & " interest=" & res & " intplan=" & t & " CredManPayPlanrw.Sum=" & CredManPayPlanrw.Sum);
  end;
  
  GetLastDuePeriodInterest = res;
  return;
end;

function val GetBuyOutFutureFees(longint credmannr,record CredManPayPlanVc CredManPayPlanr,date td)
begin
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  row CredManPayPlanVc CredManPayPlanrw;
  Integer i,rwcnt;
  val res;
  /*
  CSr.CredManNr = credmannr;
  if (ReadFirstMain(CSr,1,true)) then begin
    rwcnt = MatRowCnt(CSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CSr,i,CSrw);
      if (CSrw.FromDate>td) then begin
        if (CSrw.Fees>0) then begin
          if (CSrw.Invoiced==1) then begin
            res = res + FindUpdaidCredHistType(CSrw.InvoiceNr);
          end else begin
            res = res + CSrw.Fees;
          end;
        end;
      end;
    end;
  end;
  res = blankval;
  logforadmin(0,"GetBuyOutFutureFees: CredManSchedVc " & res);
  */
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.FromDate>td) then begin
      if(CredManPayPlanrw.PlanType==kEventTypeCalcFees) then begin
        res = res + CredManPayPlanrw.Sum;
      end;
    end;
  end;
  logforadmin(0,"GetBuyOutFutureFees: CredManPayPlanVc " & res);
  GetBuyOutFutureFees = res;
  return;
end;

function val GetOtherOpenFees(longint credmannr, date d, var vector val vItemVals)
begin
  val res,t;
  record CredHistVc CredHistr;
  boolean TrHs;
    
  /*
  Other open fees - total of all OPEN invoices except Principle, Interest, Overdues, Letter of Demand and Insurance
  */
  TrHs = true;
  CredHistr.CredManNr = credmannr;
  CredHistr.RecordType = 0;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if ((CredHistr.CredManNr!=credmannr) or (CredHistr.RecordType!=0)) then begin
      TrHs = false;
    end else begin
      if ((CredHistr.ChargeType==kEventTypeIssueDeposit) or (CredHistr.ChargeType==kEventTypeIssueFees)) then begin
        t = GetCredHistOpenValueOnDate(CredHistr.SerNr,d);
        vItemVals[CredHistr.ArtCode] = vItemVals[CredHistr.ArtCode] + t;
        res = res + t;
      end;
    end;
  end;
  GetOtherOpenFees = res;
  return;
end;

function val GetCredManItemOpenValueOnDate(longint credmannr,string item,date d)
begin
  val res;
  record CredHistVc CredHistr;
  boolean TrHs;
  
  CredHistr.CredManNr = credmannr;
  CredHistr.RecordType = 0;
  TrHs = true;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if ((CredHistr.CredManNr!=credmannr) or (CredHistr.RecordType!=0)) then begin
      TrHs = false;
    end else begin
      if ((CredHistr.ArtCode==item)) then begin
        res = res + GetCredHistOpenValueOnDate(CredHistr.SerNr,d);
      end;
    end;
  end;
  GetCredManItemOpenValueOnDate = res;
  return;
end;

function val GetOpenInsuranceValue(longint credmannr,date d)
begin
  val res;
  record CMInvoicingBlock CIb;
    
  BlockLoad(CIb);
  if (nonblank(CIb.InsuranceCost)) then begin
    GetCredManItemOpenValueOnDate(credmannr,CIb.InsuranceCost,d);
  end;
  GetOpenInsuranceValue = res;
  return;  
end;

function val GetOpenOverdueFeesValue(longint credmannr,date d)
begin
  val res;
  record CMInvoicingBlock CIb;
  record CredHistVc CredHistr;
  Boolean TrHs;
  
  BlockLoad(CIb);
  if (nonblank(CIb.OverdueItemClass)) then begin
    CredHistr.CredManNr = credmannr;
    CredHistr.RecordType = 0;
    TrHs = true;
    while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
      if ((CredHistr.CredManNr!=credmannr) or (CredHistr.RecordType!=0)) then begin
        TrHs = false;
      end else begin
        if (ItemInItemGroupOrClass(CredHistr.ArtCode,"",CIb.OverdueItemClass)) then begin
          res = res + GetCredHistOpenValueOnDate(CredHistr.SerNr,d);
        end;
      end;
    end;
  end else begin
    logforadmin(0,"OverdueItemClass not set");
  end;
  GetOpenOverdueFeesValue = res;
  return;  
end;

function val GetOpenLetterOfDemandValue(longint credmannr,date d)
begin
  val res;
  record CMInvoicingBlock CIb;
    
  BlockLoad(CIb);
  if (nonblank(CIb.LetterOfDemand)) then begin
    res = GetCredManItemOpenValueOnDate(credmannr,CIb.LetterOfDemand,d);
  end;
  GetOpenLetterOfDemandValue = res;
  return;  
end;

global
procedure CheckBuyOutAgreement2(record CredManVc CredManr,var record RcVc RepSpec,Boolean balancef)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record CredManSchedVc CSr;
  record IVVc IVr;
  val dueamount,openamount,lateamount,prepayval,buyoutfee;
  Integer latedays;
  Date sd,sd2,blankd;
  transaction Boolean gSilenceIVOpenPrepExists;
  array string 255 lateformula;
  Boolean schedf;
  Date calcsd;
  val creditedint;
  Date limitdate;
  Longint principlelatedays,interestlatedays,overdueslatedays;
  val principlelateamount,interestlateamount;
  val t,interestmmount;
  val notlateprinciple,notlateinterest;
  val currperiodinterest,futurefees,totopeninvoices,otheropenfees;
  vector val vItemVals;
  Longint dummy_ivnr;
  record ORVc ORr;
  
logforadmin(0,"CheckBuyOutAgreement start");
//logforadmin(0,"aa RepSpec.d1=" & RepSpec.d1); //d1 is CurrentDate here. Why?

  gSilenceIVOpenPrepExists = true;
  BlockLoad(CMb);
    BuildCredManPayPlanCust2(CredManr,CredManPayPlanr,CMb,true,false,false);
  //  logforadmin(0,"2 RepSpec.d1=" & RepSpec.d1);
    CreateBuyOutInvoiceFromPlan(CredManr,CMb,CredManPayPlanr,RepSpec.d1,IVr,true,sd2,balancef,ORr);
//  end;
  CheckUnpaidInvoices(CredManr,dueamount,openamount);
  sd = GetLastInvoiceDate(CredManr,RepSpec.d1);
  GetCredManOverdueInvoices2(CredManr,CMb,RepSpec.d1,sd,latedays,lateamount,principlelateamount,interestlateamount,lateformula,false,false,calcsd);
  GetCredManLateAmounts2(CredManr,CredManr.startDate,RepSpec.d1,5,principlelatedays,principlelateamount,notlateprinciple,limitdate);
  GetCredManLateAmounts2(CredManr,CredManr.startDate,RepSpec.d1,6,interestlatedays,interestlateamount,notlateinterest,limitdate);
  //GetCredManLateAmounts(CredManr,RepSpec.sStartDate,RepSpec.sEndDate,9,overdueslatedays,overdueslateamount,limitdate);
  RepSpec.vals3 = GetActualBalance(CredManr,CredManPayPlanr,false);

  prepayval = GetPrepaymentValue(CredManr);
  if (balancef==false) then begin
    buyoutfee = GetBuyOutFee(CredManr,RepSpec.d1,RepSpec.vals3);
  end;
  
  interestmmount = GetInterestAmount(CredManr,RepSpec.d1);
  
  RepSpec.vals1 = IVr.Sum4;
  RepSpec.vals0 = dueamount;//should this be openamount?
  if(RepSpec.flags[2]==1)then begin
    RepSpec.vals2 = openamount + IVr.Sum4 - prepayval + interestmmount;//added interestlateamount // Edit ************************** BPI Ukraine - KramarAlexandr - 05, 08 10 2021 y. at 3:50:52 PM
    if (prepayval>0 and RepSpec.vals2<0) then begin
      RepSpec.vals2 = 0;
    end;
  end else begin
    RepSpec.vals2 = openamount + IVr.Sum4 + interestmmount;//added interestlateamount // Edit ************************** BPI Ukraine - KramarAlexandr - 05, 08 10 2021 y. at 3:50:52 PM
  end;
  
  RepSpec.f14 = buyoutfee;
  
  RepSpec.vals4 = dueamount;
  RepSpec.f12 = lateamount;//(RepSpec.vals2-RepSpec.vals3-RepSpec.vals4);
  //BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,false);
  if (RepSpec.flags[1]==1) then begin
    RepSpec.f20 = GetCreditedInterest(CredManr,RepSpec.d1,dummy_ivnr);  
  end;
  t = GetActualBalance(CredManr,CredManPayPlanr,true);
  RepSpec.f13 = t;
  RepSpec.f17 = principlelateamount+interestlateamount;//was openamount;
  RepSpec.f16 = interestmmount;
  RepSpec.f10 = principlelateamount;//f20 - the last fxx
  RepSpec.f11 = interestlateamount;
  RepSpec.f15 = t + notlateprinciple; //GetActualBalance(CredManr,CredManPayPlanr,true);PLUS total of all OPEN, but NOT overdue principle
  currperiodinterest = GetLastDuePeriodInterest(CredManr,CredManPayPlanr,RepSpec.d1);//should display interest from the last DUE period till today.
  futurefees = GetBuyOutFutureFees(CredManr.SerNr,CredManPayPlanr,RepSpec.d1);
  otheropenfees = GetOtherOpenFees(CredManr.SerNr,blankd,vItemVals);
  
  RepSpec.Comment = prepayval;//ValToString(prepayval,M45Val,"",".",0);//valtostring(prepayval,m45val);//Prepayments
  
  gSilenceIVOpenPrepExists = false;

logforadmin(0,"CheckBuyOutAgreement end");

  return;
end;


procedure FindAllInvoicesAndPrepayments(record CredManVc CredManr,var vector val vcalcval,date todate)
begin
  record IVVc IVr;
  row IVVc IVrw;
  integer i,rwcnt,j,rwcnt1;
  boolean TrHs,testf,isfullpayed;
  record ARVc ARr;
  integer credflag;
  record CredHistVc CredHistr,CredHist2r;
  boolean TrHs2,foundf;
  record INVc INr;
  string 255 tstr;
  val t,tt,tot1,tot2,tot3;
  longint t2;
  date blankd;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  record CMBuyOutBlock CMBOb;
  
  blockload(CMBOb);
  
  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin end;
  rwcnt1 = matrowcnt(CSr);
  
  IVr.CustCode = CredManr.CustCode;
  TrHs = true;
  while(loopkey("CustCode",IVr,1,TrHs))begin
    testf = true;
    if(IVr.CustCode!=CredManr.CustCode)then begin TrHs = false; testf = false; end;
    if(IVr.CustCredManNr!=CredManr.SerNr)then begin testf = false; end;
    if(IVr.OKFlag==0)then begin testf = false; end;
    if(IVr.Invalid==1)then begin testf = false; end;
    if(IVr.InvType==kInvoiceTypeCredit)then begin testf = false; end;
    
    
    if(testf)then begin
      isfullpayed = false;
      ARr.InvoiceNr = IVr.SerNr;
      if(!readfirstmain(ARr,1,true))then begin
        isfullpayed = true;
      end;
      credflag = 1;
      if(IVr.InvType==kInvoiceTypeCredit)then begin
        credflag = -1;
      end;
      
      rwcnt = matrowcnt(IVr);
      for(i=0;i<rwcnt;i=i+1)begin
        matrowget(IVr,i,IVrw);
        
        if(IVrw.stp==kInvoiceRowTypeNormal and nonblank(IVrw.ArtCode))then begin
          vcalcval["INVOICED:" & IVrw.ArtCode] = vcalcval["INVOICED:" & IVrw.ArtCode] + IVrw.Sum*credflag;
          vcalcval["INVOICED"] = vcalcval["INVOICED"] + IVrw.Sum*credflag;
          logforadmin(0,IVr.SerNr & " INVOICED:" & IVrw.ArtCode & " " & IVrw.Sum*credflag);
          if(isfullpayed)then begin
            vcalcval["CLOSEDINVOICED:" & IVrw.ArtCode] = vcalcval["CLOSEDINVOICED:" & IVrw.ArtCode] + IVrw.Sum*credflag; 
            vcalcval["CLOSEDINVOICED"] = vcalcval["CLOSEDINVOICED"] + IVrw.Sum*credflag;
            logforadmin(0,IVr.SerNr & " CLOSEDINVOICED:" & IVrw.ArtCode & " " & IVrw.Sum*credflag);
          end else begin
            if(IVr.InvType!=kInvoiceTypeCredit)then begin
              resetloop(CredHistr);
              CredHistr.RecordNr = IVr.SerNr;
              CredHistr.RecordType = 0;
              TrHs2 = true;
              foundf = false;
              while (LoopKey("RecordNr",CredHistr,2,TrHs2)) begin
                if ((CredHistr.RecordNr!=IVr.SerNr) or (CredHistr.RecordType!=0)) then begin
                  TrHs2 = false;
                end;
                if (TrHs2 and CredHistr.ArtCode==IVrw.ArtCode) then begin
                  foundf = true;
                  t = GetCredHistOpenValueOnDate(CredHistr.SerNr,blankd);
                  vcalcval["OPENINVOICED:" & IVrw.ArtCode] = vcalcval["OPENINVOICED:" & IVrw.ArtCode] + t; 
                  vcalcval["OPENINVOICED"] = vcalcval["OPENINVOICED"] + t; 
                  logforadmin(0,IVr.SerNr & " OPENINVOICED:" & IVrw.ArtCode & " " & t);
                  for(j=0;j<rwcnt1;j=j+1)begin
                    matrowget(CSr,j,CSrw);
                    if(CSrw.InvDate==IVr.InvDate)then begin
                      if(IVr.PayDate>CSrw.ToDate)then begin
                        IVr.PayDate = CSrw.ToDate;
                      end;
                    end;
                  end;
                  if(IVr.PayDate<todate or (CMBOb.DoNotCreditlastDayInvoices==1 and IVr.PayDate==todate))then begin
                    vcalcval["OVDOPENINVOICED:" & IVrw.ArtCode] = vcalcval["OVDOPENINVOICED:" & IVrw.ArtCode] + t; 
                    vcalcval["OVDOPENINVOICED"] = vcalcval["OVDOPENINVOICED"] + t; 
                    logforadmin(0,IVr.SerNr & " OVDOPENINVOICED:" & IVrw.ArtCode & " " & t);//overdued
                    if((CMBOb.DoNotCreditlastDayInvoices==1 and IVr.PayDate==todate))then begin
                      vcalcval["OVDOPENINVOICEDLAST"] = vcalcval["OVDOPENINVOICEDLAST"] + t; 
                    end;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;    
  end;

return;
end;

global
function Boolean GetAgreementChangeDaysType(record CredManVc CredManr)
begin
  Boolean res;
  record CMBuyOutBlock CMBOb;
  record CMApplicationSetBlock CMASb;

  BlockLoad(CMBOb);

  if(CMBOb.FactOrFixedDaysBO==0)then begin
    res = true;
  end;
  if(CMBOb.FactOrFixedDaysBO==2)then begin
    if(CredManr.DaysInMonth==1)then begin
      res = true;
    end;
    if(CredManr.DaysInMonth==0)then begin
      BlockLoad(CMASb);
      if(CMASb.DaysInMonth==0)then begin
        res = true;
      end;
    end;
  end;

  GetAgreementChangeDaysType = res;
  return;
end;


global
function val GetOpenPrinciples(record CredManVc CredManr,var vector val vvals1,date inputtodate,var val shortprinc)
begin
  val res,curbal;
  Integer rwcnt,i,spenddays,leftdays;
  val openamount;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  val x,y,z,dayval;
  integer intday,fullperiod;
  record CMBuyOutBlock CMBOb;
  date todate;
  transaction boolean gBuyOutProcess;
  transaction boolean gChangeProcess;
  boolean daysinmonth30;
  record CMApplicationSetBlock CMASb;
  date fissd,fised;
  
  FindFiscalYear(inputtodate,fissd,fised);

  blockload(CMBOb);
  
  daysinmonth30 = GetAgreementChangeDaysType(CredManr);

  if(!gChangeProcess)then begin
    gBuyOutProcess = true;
  end;
  
  CSr.CredManNr = CredManr.SerNr;
  if(readfirstmain(CSr,1,true))then begin
    rwcnt = matrowcnt(CSr);
    for(i=0;i<rwcnt;i=i+1)begin
      matrowget(CSr,i,CSrw);
      if(CSrw.Invoiced==0)then begin
        curbal = curbal + CSrw.Principle;
        if(dateinrange(CSrw.InvDate,fissd,fised))then begin
          shortprinc = shortprinc + CSrw.Principle;
        end;
      end;
      if(nonblankdate(CSrw.FromDate) and nonblankdate(CSrw.ToDate))then begin
        
        if(CSrw.Invoiced==0)then begin
          if(inputtodate<=CSrw.FromDate)then begin
            vvals1["FUTUREFEES"] = vvals1["FUTUREFEES"] + CSrw.Fees;
          end;
        end;
        
        if(dateinrange(inputtodate,CSrw.FromDate,CSrw.ToDate))then begin
          todate = inputtodate;
          if(gBuyOutProcess)then begin
            if(CMBOb.CalcIntBOday==0)then begin
              todate = addday(inputtodate,-1);
            end else begin

            end;
          end;
          if(gChangeProcess)then begin
            if(CMBOb.CalcIntChangeDay==0)then begin
              todate = addday(inputtodate,-1);
            end else begin

            end;
          end;

          fullperiod = datediff(CSrw.ToDate,CSrw.FromDate)+1;
          if(CSrw.Invoiced==0)then begin
            if(daysinmonth30)then begin
              vvals1["CURRPERIODINTEREST"] = vvals1["CURRPERIODINTEREST"] + round(CSrw.Interest * (datediff(todate,CSrw.FromDate)+1) / 30,defaultcurroundoff);
            end else begin
              vvals1["CURRPERIODINTEREST"] = vvals1["CURRPERIODINTEREST"] + round(CSrw.Interest * (datediff(todate,CSrw.FromDate)+1) / fullperiod,defaultcurroundoff);
            end;
            //logforadmin(0,CSrw.Interest & " vvals1[\"CURRPERIODINTEREST\"] " & vvals1["CURRPERIODINTEREST"]);
          end else begin
            todate = inputtodate;
            if(CMBOb.CalcIntBOday==1)then begin
              todate = addday(todate,1);
              y = datediff(todate,CSrw.FromDate);
            end else begin
              y = datediff(todate,CSrw.FromDate)-1;
            end;
            x = CSrw.Interest;
            logforadmin(0,"CSrw.ToDate " & CSrw.ToDate & " CSrw.FromDate " & CSrw.FromDate);
            
            
            if(CMBOb.CalcIntBOday==0)then begin
              spenddays = datediff(inputtodate,CSrw.FromDate)-1;
              leftdays = fullperiod - spenddays;
            end else begin
              spenddays = datediff(inputtodate,CSrw.FromDate);
              leftdays = fullperiod - spenddays;
            end;
            
            if(daysinmonth30)then begin
              dayval = CSrw.Interest / 30;
              if(spenddays>30)then begin
                spenddays = 30;
              end;
            end else begin
              dayval = CSrw.Interest / fullperiod;
            end;
            
            
            
            logforadmin(0,"inputtodate " & inputtodate);
            logforadmin(0,"fullperiod " & fullperiod);
            logforadmin(0,"dayval " & dayval);
            logforadmin(0,"spenddays " & spenddays);
            logforadmin(0,"leftdays " & leftdays);
            
 
            logforadmin(0,"x " & x);
            logforadmin(0,"y " & y);
            logforadmin(0,"z " & z);
            
            
            vvals1["INVOICEDCURRENTPERIOD"] = x - round(spenddays * dayval,defaultcurroundoff);
            if(CMBOb.DoNotCreditlastDayInvoices==1)then begin
              if(CSrw.ToDate==inputtodate)then begin
                vvals1["INVOICEDCURRENTPERIOD"] = 0;
              end else begin
                vvals1["CURRPERIODINTEREST"] = vvals1["CURRPERIODINTEREST"] + round(spenddays * dayval,defaultcurroundoff);
                logforadmin(0,"--------- " & CSrw.Interest);
                logforadmin(0,vvals1["CURRPERIODINTEREST"]);
              end;
            end else begin
              vvals1["CURRPERIODINTEREST"] = vvals1["CURRPERIODINTEREST"] + round(spenddays * dayval,defaultcurroundoff);
              logforadmin(0,"--------- " & CSrw.Interest);
              logforadmin(0,vvals1["CURRPERIODINTEREST"]);
            end;
          end;
        end else begin
          if(CSrw.Invoiced==0)then begin
            if(CSrw.ToDate<todate)then begin
              vvals1["CURRPERIODINTEREST"] = vvals1["CURRPERIODINTEREST"] + CSrw.Interest;
              //logforadmin(0,CSrw.Interest & " vvals1[\"CURRPERIODINTEREST\"] " & vvals1["CURRPERIODINTEREST"]);
           end;
          end;
        end;
      end;
    end;
  end;

  GetOpenPrinciples = curbal;
  return;
end;

global
function boolean CheckCsheduleLastBalance(record CredManVc CredManr)
begin
  boolean res;
  Integer rwcnt,i,spenddays,leftdays;
  val openamount;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  
  res = true;
  
  CSr.CredManNr = CredManr.SerNr;
  if(readfirstmain(CSr,1,true))then begin
    rwcnt = matrowcnt(CSr);
    for(i=0;i<rwcnt;i=i+1)begin
      matrowget(CSr,i,CSrw);
      if(CSrw.Invoiced==1 and CSrw.Balance==0)then begin
        res = false;
      end;
    end;
  end;
  
  CheckCsheduleLastBalance = res;
return;
end;

global
function date CheckCsheduleLastStartPeriod(record CredManVc CredManr)
begin
  date res;
  Integer rwcnt,i,spenddays,leftdays;
  val openamount;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  
  
  CSr.CredManNr = CredManr.SerNr;
  if(readfirstmain(CSr,1,true))then begin
    
    rwcnt = matrowcnt(CSr);
    
    for(i=0;i<rwcnt;i=i+1)begin
      matrowget(CSr,i,CSrw);
      if(CSrw.Invoiced==1 and nonblankdate(CSrw.FromDate))then begin
        res = CSrw.FromDate;
      end;
    end;
  end;
  
  CheckCsheduleLastStartPeriod = res;
return;
end;

global
procedure CheckBuyOutAgreementOmega(record CredManVc CredManr,var record ORVc ORr,Boolean balancef)
begin
  row ORVc ORrw;
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record CredManSchedVc CSr;
  record IVVc IVr;
  record INVc INr;
  val dueamount,openamount,lateamount,prepayval,buyoutfee;
  Integer latedays;
  Date sd,sd2,blankd;
  transaction Boolean gSilenceIVOpenPrepExists;
  array string 255 lateformula;
  Boolean schedf;
  Date calcsd;
  val creditedint;
  Date limitdate,invdateday;
  Longint principlelatedays,interestlatedays,overdueslatedays;
  val principlelateamount,interestlateamount;
  val t,t2,totallate,totalnotlate;
  val notlateprinciple,notlateinterest;
  val currperiodinterest,futurefees,totopeninvoices,otheropenfees;
  val actualbalance,shortprinc;
  vector val vItemVals;
  array string 255 aitems;
  integer i,rwcnt;
  longint dummy_ivnr;
  record CredHistVc CredHistr;
  vector val vcalcval,vcalcval1;
  string 50 intItem,princItem,demandItem,insurItem,prematureItem,feesItem,futurefeesitem;
  record CMInvoicingBlock CIb;
  array string 30 acalcval,afutfeeclassitem;
  val interestammount;
  boolean testf;
  record CMBuyOutBlock CMBOb;
  record CMApplicationSetBlock CMAb;
  transaction boolean gBuyOutProcess;
  transaction boolean gChangeProcess;
  
  if(!gChangeProcess)then begin
    gBuyOutProcess = true;
  end; 
   
  blockload(CIb);
  BlockLoad(CMb);
  BlockLoad(CMBOb);
  blockload(CMAb);
  
  
  
  logforadmin(0,"CheckBuyOutAgreementOmega start");
  
//logforadmin(0,"aa RepSpec.d1=" & RepSpec.d1); //d1 is CurrentDate here. Why?

  gSilenceIVOpenPrepExists = true;
  
  BuildCredManPayPlanCust2(CredManr,CredManPayPlanr,CMb,true,false,false);
  
  CredHistr.CredManNr = CredManr.SerNr;
  readlastkey("CredManTypeDate",CredHistr,1,true);
  if(ORr.OrdDate<CredHistr.TransDate)then begin
    ORr.OrdDate = CredHistr.TransDate;
  end;
  
  CreateBuyOutInvoiceFromPlan(CredManr,CMb,CredManPayPlanr,ORr.OrdDate,IVr,true,sd2,balancef,ORr);
//  end;
  CheckUnpaidInvoices(CredManr,dueamount,openamount);
  sd = GetLastInvoiceDate(CredManr,ORr.OrdDate);
  //lateamount=not invoiced overdues??? ->
  
  invdateday = ORr.OrdDate;
  if(gBuyOutProcess)then begin
    if(CMBOb.CalcOvdBOday==1)then begin
      invdateday = addday(invdateday,1);
    end;  
    if(CMAb.BuyOutInclPaymDay==1)then begin
      invdateday = addday(invdateday,-1);
    end;
  end;
  if(gChangeProcess)then begin
    if(CMBOb.CalcOvdChangeDay==1)then begin
      invdateday = addday(invdateday,1);
    end; 
  end;
  GetCredManOverdueInvoices2(CredManr,CMb,invdateday,sd,latedays,lateamount,principlelateamount,interestlateamount,lateformula,false,false,calcsd);
  
  GetCredManLateAmounts2(CredManr,CredManr.startDate,ORr.OrdDate,-1,principlelatedays,totallate,totalnotlate,limitdate);
  logforadmin(0,"Totals: " & CredManr.SerNr & " totlate=" & totallate & " notlate=" & totalnotlate);
  GetCredManLateAmounts2(CredManr,CredManr.startDate,ORr.OrdDate,5,principlelatedays,t,notlateprinciple,limitdate);
  logforadmin(0,"Principal: " & CredManr.SerNr & " principlelateamount=" & t & " notlateprinciple=" & notlateprinciple);
  GetCredManLateAmounts2(CredManr,CredManr.startDate,ORr.OrdDate,6,interestlatedays,interestlateamount,notlateinterest,limitdate);
  logforadmin(0,"Interest: " & CredManr.SerNr & " interestlateamount=" & interestlateamount & " notlateinterest=" & notlateinterest);
  //GetCredManLateAmounts(CredManr,RepSpec.sStartDate,RepSpec.sEndDate,9,overdueslatedays,overdueslateamount,limitdate);
  //TODO RepSpec.vals3 = GetActualBalance(CredManr,CredManPayPlanr,false);
  actualbalance = GetActualBalance(CredManr,CredManPayPlanr,false);
  
  prepayval = GetPrepaymentValue(CredManr);
  ORr.PrepaidAmount = prepayval;
  if (balancef==false) then begin
    buyoutfee = GetBuyOutFeeChBO(CredManr,ORr.OrdDate,actualbalance);
  end;
  //TODO RepSpec.vals1 = IVr.Sum4;//"Last Invoice Value"
  //TODO RepSpec.vals0 = dueamount;//should this be openamount? "Expected Payment"?
  //RepSpec.vals2 = openamount + IVr.Sum4 - prepayval;
  ORr.TAX2Sum = buyoutfee;
  /* old
  ORr.FrBase = openamount + IVr.Sum4 - prepayval;
  if (prepayval>0 and  ORr.FrBase<0) then begin
    ORr.FrBase = 0;
  end;
  */
  
  //TODO RepSpec.vals4 = dueamount;
  //RepSpec.f12 = lateamount;//(RepSpec.vals2-RepSpec.vals3-RepSpec.vals4);
  ORr.FrPrice = lateamount;//not invoiced overdues. What is lateamount?
  //BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,false);
  /*if (RepSpec.flags[1]==1) then begin
    RepSpec.f20 = GetCreditedInterest(CredManr,RepSpec.d1);  
  end;
  */
  if (ORr.InvMark==1) then begin
    ORr.Commision = GetCreditedInterest(CredManr,ORr.OrdDate,dummy_ivnr);  
  end;
  //t = GetActualBalance(CredManr,CredManPayPlanr,true);
  
  //RepSpec.f13 = t;
  
  ORr.Sum0 = t;
  //RepSpec.f17 = principlelateamount+interestlateamount;//was openamount;
  ORr.Sum2 = totallate;//+totalnotlate;//openamount;//principlelateamount+interestlateamount;//was openamount;
  //RepSpec.f16 = GetInterestAmount(CredManr,RepSpec.d1);
  ORr.Sum1 = GetInterestAmount(CredManr,ORr.OrdDate);
  //RepSpec.f10 = principlelateamount;//f20 - the last fxx
  ORr.Sum4 = principlelateamount;
  //RepSpec.f11 = interestlateamount;
  ORr.Sum3 = interestlateamount;
  //RepSpec.f15 = t + notlateprinciple; //GetActualBalance(CredManr,CredManPayPlanr,true);PLUS total of all OPEN, but NOT overdue principle
  ORr.BaseSum4 = ORr.Sum0 + notlateprinciple;
  /*CreateFile("credmanpayplan_e.txt");
    CredManPayPlanr.SerNr = CredManr.SerNr;
    ExportRecord(CredManPayPlanr);
    CloseFile;
    */
  currperiodinterest = GetLastDuePeriodInterest(CredManr,CredManPayPlanr,ORr.OrdDate);//should display interest from the last DUE period till today.
  ORr.TotGP = currperiodinterest;
  
  
  
  futurefees = GetBuyOutFutureFees(CredManr.SerNr,CredManPayPlanr,ORr.OrdDate);
  ORr.DiscSum = futurefees;
  otheropenfees = GetOtherOpenFees(CredManr.SerNr,ORr.OrdDate,vItemVals);
  ORr.TAX1Sum = otheropenfees;
  ORr.RvrsVAT = GetOpenInsuranceValue(CredManr.SerNr,ORr.OrdDate);
  t = GetOpenOverdueFeesValue(CredManr.SerNr,ORr.OrdDate);
  
  ORr.FrBase = ORr.Sum2+ORr.BaseSum4+ORr.TotGP+ORr.DiscSum+otheropenfees+lateamount+t;
  
  t = GetOpenLetterOfDemandValue(CredManr.SerNr,ORr.OrdDate);
  ORr.SumIncCom = t;
  ORr.FrBase = ORr.FrBase+t+ORr.RvrsVAT+ORr.TAX2Sum-prepayval;
  rwcnt = MatRowCnt(ORr);
  for (i=rwcnt-1;i>=0;i=i-1) begin
    MatRowDelete(ORr,i);
  end;
  GetVectorTags(vItemVals,aitems);
  for (i=0;i<aitems.length;i=i+1) begin
    INr.Code = aitems[i];
    ReadFirstMain(INr,1,true);
    ClearRow(ORr,ORrw,1);
    ORrw.ArtCode = aitems[i];
    ORrw.Spec = INr.Name;
    ORrw.Sum = vItemVals[aitems[i]];
    MatRowPut(ORr,i,ORrw);
  end;  
  //logforadmin(0,"futurefees=" & futurefees & " otheropenfees=" & otheropenfees);
  
  
  //////======================== NEW Logics
  
  demandItem = CIb.LetterOfDemand;
  insurItem = CIb.InsuranceCost;
  prematureItem = CMBOb.BuyOutItem;
  intItem = CMb.RateItem;
  feesItem = CMb.LateRateItem;
  princItem = CMb.InstalmentItem;
  //futurefeesitem = CMBOb.FutFeeItem;
  
  if(nonblank(CMBOb.FutFeeItemClass))then begin
    resetloop(INr);
    INr.Code = "";
    while(loopmain(INr,1,true))begin
      if(setinset(CMBOb.FutFeeItemClass,INr.DispGroups))then begin
        afutfeeclassitem[afutfeeclassitem.length] = INr.Code;
      end;
    end;
  end;
  
  FindAllInvoicesAndPrepayments(CredManr,vcalcval,ORr.OrdDate);
  vcalcval1["OPENNOTOVERDUEINT"] = vcalcval["OPENINVOICED:" & intItem] - vcalcval["OVDOPENINVOICED:" & intItem];
  
  t = GetOpenPrinciples(CredManr,vcalcval1,ORr.OrdDate,shortprinc);
    
  //getvectortags(vcalcval,acalcval);
  //Interest Ammount
  logforadmin(0,"Interest Ammount All " & intItem & " " & vcalcval["INVOICED:" & intItem]);
  logforadmin(0,"Interest Ammount Open " & intItem & " " & vcalcval["OPENINVOICED:" & intItem]);
  logforadmin(0,"Interest Ammount Open Overdued " & intItem & " " & vcalcval["OVDOPENINVOICED:" & intItem]);
  
  logforadmin(0,"Principle Ammount All " & princItem & " " & vcalcval["INVOICED:" & princItem]);
  logforadmin(0,"Principle Ammount Open " & princItem & " " & vcalcval["OPENINVOICED:" & princItem]);
  logforadmin(0,"Principle Ammount Open Overdued " & princItem & " " & vcalcval["OVDOPENINVOICED:" & princItem]);
  
  logforadmin(0,"Fees Ammount All " & feesItem & " " & vcalcval["INVOICED:" & feesItem]);
  logforadmin(0,"Fees Ammount Open " & feesItem & " " & vcalcval["OPENINVOICED:" & feesItem]);
  logforadmin(0,"Fees Ammount Open Overdued " & feesItem & " " & vcalcval["OVDOPENINVOICED:" & feesItem]);
  
  ORr.Sum0 = t;
  ORr.CustVal06 = shortprinc;
  logforadmin(0,"------Interest Ammount" & intItem & " " & vcalcval["OPENINVOICED:" & intItem] - vcalcval["OVDOPENINVOICED:" & intItem]);
  ORr.Sum1 = vcalcval["OPENINVOICED:" & intItem] - vcalcval["OVDOPENINVOICED:" & intItem];
  interestammount = vcalcval["OPENINVOICED:" & intItem] - vcalcval["OVDOPENINVOICED:" & intItem];
  logforadmin(0,"------Overdue Invoices" & vcalcval["OVDOPENINVOICED"]);
  ORr.Sum2 = vcalcval["OVDOPENINVOICED"];
  logforadmin(0,"------of withc Interest" & vcalcval["OVDOPENINVOICED:" & intItem]);
  ORr.Sum3 = vcalcval["OVDOPENINVOICED:" & intItem];
  logforadmin(0,"------of withc Principle" & vcalcval["OVDOPENINVOICED:" & princItem]);
  ORr.Sum4 = vcalcval["OVDOPENINVOICED:" & princItem];
  logforadmin(0,"------Balance" & t + vcalcval["OPENINVOICED:" & princItem] - vcalcval["OVDOPENINVOICED:" & princItem]);
  ORr.BaseSum4 = t + vcalcval["OPENINVOICED:" & princItem] - vcalcval["OVDOPENINVOICED:" & princItem];
  logforadmin(0,"interestammount " & interestammount);
  logforadmin(0,"vcalcval1[\"INVOICEDCURRENTPERIOD\"] " & vcalcval1["INVOICEDCURRENTPERIOD"]);
  
  //ORr.CustVal01 = vcalcval["OVDOPENINVOICED:" & futurefeesitem];
  //logforadmin(0,"ORr.CustVal01 " & futurefeesitem & " " & ORr.CustVal01);
  if(afutfeeclassitem.length>0)then begin
    for(i=0;i<afutfeeclassitem.length;i=i+1)begin
      ORr.CustVal01 = ORr.CustVal01 + vcalcval["OVDOPENINVOICED:" & afutfeeclassitem[i]];
      logforadmin(0,"ORr.CustVal01 " & afutfeeclassitem[i] & " " & ORr.CustVal01);
    end;
  end;
  
  ORr.CustVal02 = Round(CredManr.StdProlongFee + (CredManr.InvSum4 * (CredManr.StdProlongPrc/100)),SetRoundModeD(2));
  
  
  //vcalcval1["CURRPERIODINTEREST"];
  logforadmin(0,"vcalcval1[\"CURRPERIODINTEREST\"] " & vcalcval1["CURRPERIODINTEREST"]);
  //logforadmin(0,"------Current Period Interest" & interestammount - vcalcval1["INVOICEDCURRENTPERIOD"]  );//???????????
  
  logforadmin(0,"------Current Period Interest" & vcalcval1["CURRPERIODINTEREST"]);
  //ORr.TotGP = interestammount - vcalcval1["INVOICEDCURRENTPERIOD"];
  ORr.TotGP = vcalcval1["CURRPERIODINTEREST"];
  
  logforadmin(0,"------Future Fees" & vcalcval1["FUTUREFEES"]);
  if(CMBOb.InvFutFees==1)then begin
    ORr.DiscSum = vcalcval1["FUTUREFEES"];
  end else begin
    ORr.DiscSum = blankval;
  end;
  
  
  logforadmin(0,"OPENINVOICED " & vcalcval["OVDOPENINVOICED"]);
  logforadmin(0,"OPENINVOICED:" & princItem & " " & vcalcval["OPENINVOICED:" & princItem]);
  logforadmin(0,"OPENINVOICED:" & intItem & " " &vcalcval["OPENINVOICED:" & intItem]);
  logforadmin(0,"OPENINVOICED:" & demandItem & " " & vcalcval["OPENINVOICED:" & demandItem]);
  logforadmin(0,"OPENINVOICED:" & feesItem & " " & vcalcval["OPENINVOICED:" & feesItem]);
  logforadmin(0,"------Other Open Fees" & vcalcval["OPENINVOICED"] - vcalcval["OPENINVOICED:" & princItem] - vcalcval["OPENINVOICED:" & intItem] - vcalcval["OPENINVOICED:" & demandItem] - vcalcval["OPENINVOICED:" & feesItem]);
  ORr.TAX1Sum = vcalcval["OPENINVOICED"] - vcalcval["OPENINVOICED:" & princItem] - vcalcval["OPENINVOICED:" & intItem] - vcalcval["OPENINVOICED:" & demandItem] - vcalcval["OPENINVOICED:" & feesItem];
  logforadmin(0,"------Open Overdue Fee Invoices" & vcalcval["OPENINVOICED:" & feesItem]);
//  ORr.??????????
  ORr.DownPayRedcd = vcalcval["OPENINVOICED:" & feesItem];
  logforadmin(0,"------Credited Interest" & vcalcval1["INVOICEDCURRENTPERIOD"]);
  ORr.DownPaySent = vcalcval1["INVOICEDCURRENTPERIOD"];
  
  logforadmin(0,"------Letter Of Demand" & vcalcval["OPENINVOICED:" & demandItem]);
  ORr.SumIncCom = vcalcval["OPENINVOICED:" & demandItem];
  logforadmin(0,"------Insurance Cost" & vcalcval["OPENINVOICED:" & insurItem]);
  ORr.RvrsVAT = vcalcval["OPENINVOICED:" & insurItem];
  logforadmin(0,"------Premature Term. Fee" & vcalcval["OPENINVOICED:" & prematureItem]);
  logforadmin(0,"------Premature Term. Fee" & buyoutfee);
  ORr.TAX2Sum = buyoutfee;//vcalcval["OPENINVOICED:" & prematureItem];
    
  //t = GetOpenOverdueFeesValue(CredManr.SerNr,ORr.OrdDate);
  
  logforadmin(0,"TOTAL==================");
  logforadmin(0,"Premature Term. Fee ORr.TAX2Sum " & ORr.TAX2Sum);
  logforadmin(0,"Overdue Invoices ORr.Sum2 " & ORr.Sum2);
  logforadmin(0,"Balance ORr.BaseSum4 " & ORr.BaseSum4);
  logforadmin(0,"Current Period Interest ORr.TotGP " & ORr.TotGP);
  logforadmin(0,"Future Fees ORr.DiscSum " & ORr.DiscSum);
  logforadmin(0,"Other Open Fees ORr.TAX1Sum " & ORr.TAX1Sum);//-----Disabled becouse include already
  logforadmin(0,"Not invoiced Overdues ORr.FrPrice " & ORr.FrPrice);
  logforadmin(0,"Open Overdue Fee Invoices ORr.DownPayRedcd " & ORr.DownPayRedcd);//-----Disabled becouse include already
  
  ORr.FrBase = ORr.TAX2Sum + ORr.BaseSum4 + ORr.TotGP + ORr.DiscSum /*+ ORr.TAX1Sum*/ + ORr.FrPrice/* + ORr.DownPayRedcd*/;//total debt
  if(ORr.InvMark==0 and ORr.DownPaySent>0)then begin
    ORr.FrBase = ORr.FrBase - ORr.TotGP;
    //ORr.FrBase = ORr.FrBase - ORr.TotGP;
    ORr.OYDescription = ORr.FrBase + ORr.Sum2 + ORr.DownPayRedcd - vcalcval["OVDOPENINVOICED:" & feesItem] + ORr.Sum1;

  end else begin
    if(ORr.TotGP>0)then begin
      if(ORr.ShipMark==0)then begin
        ORr.OYDescription = ORr.FrBase + ORr.Sum2 + ORr.DownPayRedcd - vcalcval["OVDOPENINVOICED:" & feesItem];
      end else begin
        ORr.OYDescription = ORr.FrBase + ORr.Sum2 + ORr.DownPayRedcd - vcalcval["OVDOPENINVOICED:" & feesItem] - ORr.PrepaidAmount;
      end;
    end else begin
      if(ORr.ShipMark==0)then begin
        ORr.OYDescription = ORr.FrBase + ORr.Sum2;
      end else begin
        ORr.OYDescription = ORr.FrBase + ORr.Sum2 - ORr.PrepaidAmount;
      end;
    end;
  end;
  
  if(CMBOb.DoNotCreditlastDayInvoices==1)then begin
    ORr.FrBase = ORr.FrBase - vcalcval["OVDOPENINVOICEDLAST"];
  end;
    
  getvectortags(vcalcval,acalcval);
  
  rwcnt = MatRowCnt(ORr);
  for (i=rwcnt-1;i>=0;i=i-1) begin
    MatRowDelete(ORr,i);
  end;
  
  for(i=0;i<acalcval.length;i=i+1)begin
    if(left(acalcval[i],12)=="OPENINVOICED")then begin
      if(nonblank(lastinrange(acalcval[i],20)) and lastinrange(acalcval[i],20)!=firstinrange(acalcval[i],20))then begin
        logforadmin(0,"MATRIX " & lastinrange(acalcval[i],20) & vcalcval["OPENINVOICED:" & lastinrange(acalcval[i],20)]);
        if(nonblank(lastinrange(acalcval[i],20)))then begin
          testf = true;
          
          if(lastinrange(acalcval[i],20)==intItem)then begin testf = false; end;
          if(lastinrange(acalcval[i],20)==princItem)then begin testf = false; end;
          if(vcalcval["OPENINVOICED:" & lastinrange(acalcval[i],20)]==0)then begin testf = false; end;
          if(lastinrange(acalcval[i],20)==feesItem)then begin testf = false; end;
          
          if(testf)then begin
            INr.Code = lastinrange(acalcval[i],20);
            ReadFirstMain(INr,1,true);
            ClearRow(ORr,ORrw,1);
            ORrw.ArtCode = lastinrange(acalcval[i],20);
            ORrw.Spec = INr.Name;
            ORrw.Sum = vcalcval["OPENINVOICED:" & lastinrange(acalcval[i],20)];
            MatRowPut(ORr,matrowcnt(ORr),ORrw);
          end;
        end;
      end;
    end;
  end;
  
  if(CheckCsheduleLastBalance(CredManr)==false)then begin
    logforadmin(0,CredManr.SerNr &  " balance is 0 ");
    ORr.OYDescription = "";
  end;
  
  
  gSilenceIVOpenPrepExists = false;
  
  
logforadmin(0,"CheckBuyOutAgreementOmega end");

  return;
end;

global
procedure CheckBuyOutAgreement(record CredManVc CredManr,var record RcVc RepSpec)
begin

  CheckBuyOutAgreement2(CredManr,RepSpec,false);
  return;
end;

global
procedure CheckBuyOutAgreementAsync(record CredManVc CredManr,Date td,Integer wn)
begin
  record RcVc RepSpec;
  record ORVc ORr;
  transaction boolean gBuyOutProcess;

  gBuyOutProcess = true;

  //CheckBuyOutAgreement(CredManr,RepSpec);
  if (true/*IsOmegaCustomer*/) then begin//enabled for all customers
    RecordClear(ORr);
    ORr.OrdDate = CurrentDate;
    CheckBuyOutAgreementOmega(CredManr,ORr,false);
    
    RepSpec.vals2 = stringtoval(ORr.OYDescription,m4val);//buyoutvalue//ok
    RepSpec.f13 = ORr.BaseSum4 + ORr.Sum4;//remainingprinciple//ok
    RepSpec.vals4 = ORr.Sum2;//totaldue//ok
    RepSpec.f12 = ORr.FrPrice;//acumpenalty
    RepSpec.f10 = ORr.Sum3;//lateprincipal
    RepSpec.f11 = ORr.Sum4;//lateinterest
    
  end else begin;
    RepSpec.d1 = CurrentDate;
    CheckBuyOutAgreement(CredManr,RepSpec);
  end;
  //CheckBuyOutAgreement(CredManr,RepSpec);
  clientremoteasync.CheckBuyOutAgreementCallBack(RepSpec,wn);

  return;
end;


//very sad that I have to map these now. Adding each new type needs an exception now
function Integer MapChargeTypes(Integer type)
begin
  Integer res;
  
  switch (type) begin
    case 9:  res = type;
    case 10: res = type;
    case 11: res = type;
    case 14: res = type;//prolong fee
    case 15: res = type;//extra fee
    case 16: res = type;//payment made
    case 17: res = type;//sold agreement
    case 18: res = type;//pay out
    case 19: res = type;//partial buyout
    otherwise
      res = type + 4;
  end;

  MapChargeTypes = res;
  return;
end;

global
updating procedure CreateCredHist(Longint recnr,Integer chargetype,string custcode,val sum,Integer rectype,string item,Date duedate,Longint agreementnr,Date invdate,var Longint histnr,Date perfrom,Date perto,Integer mainf,Longint previousnr,val invsum,Longint factinv,val paidval)
begin
  record CredHistVc CredHistr;
  
  histnr = -1;

  RecordNew(CredHistr);
  CredHistr.SerNr = NextSerNr("CredHistVc",CurrentDate,-1,false,"");
  CredHistr.TransDate = invdate;
  CredHistr.RecordNr = recnr;
  CredHistr.ChargeType = MapChargeTypes(chargetype);//from calc type to issued type
  CredHistr.CustCode = custcode;
  CredHistr.RecordType = rectype;
  CredHistr.ArtCode = item;
  CredHistr.PayDate = duedate;
  CredHistr.CredManNr = agreementnr;
  CredHistr.CredFromDate = perfrom;
  CredHistr.CredToDate = perto;
  CredHistr.MainRecord = mainf;
  CredHistr.PreviousNr = previousnr;
  CredHistr.InvSum = invsum;
  CredHistr.FactoringInvoice = factinv;
  if (nonblank(CredHistr.CredFromDate)) then begin
    CredHistr.Comment2 = CredHistr.CredFromDate & ":" & CredHistr.CredToDate;
  end;
  if (paidval>0) then begin
    CredHistr.PaidSum = paidval;
    if (CredHistr.PaidSum==CredHistr.InvSum) then begin
      CredHistr.PaidFlag = 1;
    end;
  end;

  CredHistr.Sum = sum;
  if (RecordInsert(CredHistr,true)) then begin
    histnr = CredHistr.SerNr;
  end;

  return;
end;

global
updating procedure RemoveCredHist(Longint recnr,Integer rectype)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  
  TrHs = true;
  CredHistr.RecordNr = recnr;
  CredHistr.RecordType = rectype;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordType!=rectype or CredHistr.RecordNr!=recnr) then begin
      TrHs = false;
    end else begin
      RecordRemove(CredHistr);
      StepBack(CredHistr);
    end;
  end;

  return;
end;

function val CalculateRowSumWithVAT(record IVVc IVr,row IVVc IVrw)
begin
  val res;
  val vatprc,vatval,vatexclprc,vatinclprc,rowtax;

//first version is just row sum. We should include VAT to match with payments
  res = IVrw.Sum;
  InvVat(1,IVr.InclVAT,IVr.NoTAXonVAT,IVr.ExportFlag,IVrw.VATCode,IVrw.Sum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);

  if (IVr.InclVAT==0) then begin
    res = res + vatval;
  end;



  CalculateRowSumWithVAT = res;
  return;
end;

global
updating procedure UpdateCredHistBalance(Longint credmannr,Longint invnr,Integer type)
begin
  record ORVc ORr;
  Integer i,rwcnt;
  record CredHistVc CredHistr,oldCredHistr;
  row ORVc ORrw;
  Boolean TrHs;
  val bal;
  
  GetCredManEventList2(credmannr,ORr);
  rwcnt = MatRowCnt(ORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORr,i,ORrw);
    if (ORrw.GroupOrdRow==invnr and ORrw.RowOrderType==type) then begin
      bal = ORrw.rowGP;
      i = rwcnt;
    end;
  end;
  TrHs = true;
  CredHistr.RecordNr = invnr;
  CredHistr.RecordType = 0;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordNr!=invnr or CredHistr.RecordType!=type) then begin
      TrHs = false;
    end else begin
      RecordCopy(oldCredHistr,CredHistr);
      CredHistr.Balance = bal;
      RecordUpdate(oldCredHistr,CredHistr,true);
    end;
  end;

  return;
end;
/*
global
updating procedure UpdateCredHistBalancePartialBuyout(Longint credmannr,Longint credhistnr)
begin
  record ORVc ORr;
  Integer i,rwcnt;
  record CredHistVc CredHistr,oldCredHistr;
  row ORVc ORrw;
  Boolean TrHs;
  val bal;
  
  GetCredManEventList2(credmannr,ORr);
  rwcnt = MatRowCnt(ORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORr,i,ORrw);
    if (ORrw.CUServiceHistNr==credhistnr) then begin
      bal = ORrw.rowGP;
      i = rwcnt;
    end;
  end;
  TrHs = true;
  CredHistr.SerNr = credhistnr;
  if (ReadFirstMain(CredHistr,1,true)) begin
    RecordCopy(oldCredHistr,CredHistr);
    CredHistr.Balance = bal;
    RecordUpdate(oldCredHistr,CredHistr,true);
  end;

  return;
end;
*/

updating procedure MakeFakeReceiptHist(record IVVc IVr,row IVVc IVrw)
begin
  Boolean TrHs;
  row IPVc IPrw;
  vector val arrCredManr;
  record IPVc IPr;

  IPr.SerNr = IVr.SerNr;
  IPr.TransDate = IVr.InvDate;
  ClearRow(IPr,IPrw,1);
  IPrw.InvoiceNr = IVr.SerNr;
  IPrw.RecVal = IVrw.BasePrice;
  arrCredManr[IVr.CustCredManNr] = IVrw.BasePrice;
  MatRowPut(IPr,0,IPrw);
  FindUnpaidCredHist(IPr,IPrw,arrCredManr,2);

  return;
end;

function Boolean FindMatchingRow(record IVVc credIVr,Longint histnr,string item,var row IVVc tIVrw)
begin
  Integer i,rwcnt;
  row IVVc IVrw;
  Boolean res;
  
  rwcnt = MatRowCnt(credIVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(credIVr,i,IVrw);
    if (IVrw.CredHistNr==histnr) then begin
      res = true;
      MatRowGet(credIVr,i,tIVrw);
      i = rwcnt;
    end;
  end;
  if (res==false) then begin
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(credIVr,i,IVrw);
      if (IVrw.ArtCode==item) then begin
        res = true;
        MatRowGet(credIVr,i,tIVrw);
        i = rwcnt;
      end;
    end;
  end;

  FindMatchingRow = res;
  return;
end;

global
updating procedure UpdateCredHistInvoice(var record IVVc IVr,record IVVc IV2r)
begin
  row IVVc IVrw,tIVrw,prepIVrw;
  Integer i,rwcnt;
  Boolean prepayf;
  Longint histnr;
  Integer firstf;
  record IVVc credIVr;
  date blankd;
  val vatprc,vatval,vatexclprc,vatinclprc,rowtax;
  vector boolean ifprepay;
    
  firstf = 1;
  if (IVr.InvType==kInvoiceTypeCredit) then begin
    if (IVr.OKFlag==1 and IV2r.OKFlag!=1) then begin
      if (IVr.CredInv>0) then begin
        credIVr.SerNr = IVr.CredInv;
        if (ReadFirstMain(credIVr,1,true)) then begin
          rwcnt = MatRowCnt(IVr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(IVr,i,IVrw);
            if (IVrw.ChargeType>0) then begin
              if (FindMatchingRow(credIVr,IVrw.CredHistNr,IVrw.ArtCode,tIVrw)) then begin
                CreateCredHist(IVr.SerNr,10,IVr.CustCode,CalculateRowSumWithVAT(IVr,IVrw),3,"",IVr.TransDate,IVr.CustCredManNr,IVr.TransDate,histnr,"","",0,tIVrw.CredHistNr,IVrw.Sum,-1,0);

                IVrw.CredHistNr = histnr;
                MatRowPut(IVr,i,IVrw);
                firstf = 0;
              end;
            end;
          end;
        end;
      end;
    end;
    if (IVr.OKFlag==0 and IV2r.OKFlag!=0) then begin
      RemoveCredHist(IVr.SerNr,kCredHistRecTypeCreditNote);
    end;
  end else begin
    if (IVr.OKFlag==0 and IV2r.OKFlag!=0) then begin
      RemoveCredHist(IVr.SerNr,kCredHistRecTypeInvoice);
      RemoveCredHist(IVr.SerNr,kCredHistRecTypePrepayment);
    end;
    
    if (IVr.OKFlag==1 and IV2r.OKFlag!=1) then begin
      rwcnt = MatRowCnt(IVr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        if (IVrw.ChargeType==0 and nonblank(IVrw.ArtCode) and IVr.CustCredManNr>0) then begin
          IVrw.ChargeType = 15;
        end;
        if (IVrw.ChargeType>0) then begin
          CreateCredHist(IVr.SerNr,IVrw.ChargeType,IVr.CustCode,CalculateRowSumWithVAT(IVr,IVrw),kCredHistRecTypeInvoice,IVrw.ArtCode,IVr.PayDate,IVr.CustCredManNr,IVr.InvDate,histnr,IVr.CredFromDate,IVr.CredToDate,firstf,-1,IVr.Sum4,IVrw.FactoringInvoice,0);
          IVrw.CredHistNr = histnr;
          MatRowPut(IVr,i,IVrw);
          firstf = 0;
        end;
        if (IVrw.stp==kInvoiceRowTypePrepayment) then begin
          if (IVrw.BasePrice>0) then begin
            MatRowGet(IVr,i,prepIVrw);
            prepayf = true;
          end;
        end;
      end;
      if (prepayf) then begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          if (IVrw.stp==kInvoiceRowTypePrepayment and IVrw.BasePrice>0) then begin
            MakeFakeReceiptHist(IVr,IVrw);
          end;
        end;
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          logforadmin(0,"i " & i & " IVrw.CredHistNr " & IVrw.CredHistNr);
          if (IVrw.stp==kInvoiceRowTypeNormal and nonblank(IVrw.ArtCode) and IVrw.CredHistNr>0) then begin
            IVrw.SumAfterPrepayment = GetCredHistOpenValueOnDate(IVrw.CredHistNr,blankd);
            ifprepay[i] = true;
            MatRowPut(IVr,i,IVrw);
          end;
        end;
        
      end;
    end;
  end;
  
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVrw.stp==kInvoiceRowTypeNormal and nonblank(IVrw.ArtCode))then begin
      InvVat(1,IVr.InclVAT,IVr.NoTAXonVAT,IVr.ExportFlag,IVrw.VATCode,IVrw.Sum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);
      IVrw.SumWithVAT = IVrw.Sum + vatval;
      if(IVrw.SumAfterPrepayment==0 and ifprepay[i]==false)then begin
        IVrw.SumAfterPrepayment = IVrw.SumWithVAT;
      end;
      MatRowPut(IVr,i,IVrw);
    end;
  end;
  
  UpdateCredHistBalance(IVr.CustCredManNr,IVr.SerNr,0);

  return;
end;

global
updating procedure UpdateCredManScheduleFromInvoice(record IVVc IVr,Boolean setf)
begin
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw,CS2rw;
  Integer rwcnt,i,j;
  record CredManSetBlock CMb;
  val instalmentSum,princpart,delta,rateItemSum,intpart,intdelta;
  row IVVc IVrw;
  integer counter;

  if (IVr.CustCredManNr>0) then begin
    if(IVr.InvType!=kInvoiceRowTypeCredit)then begin
      CSr.CredManNr = IVr.CustCredManNr;
      if (ReadFirstMain(CSr,1,true)) then begin
        RecordCopy(oldCSr,CSr);
        rwcnt = MatRowCnt(CSr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(CSr,i,CSrw);
          if (CSrw.InvDate==IVr.InvDate and (IVr.CredFromDate==CSrw.FromDate or (nonblank(IVr.CredFromDate) and nonblank(CSrw.FromDate)))) then begin
            if (setf) then begin
              CSrw.Invoiced = 1;
              CSrw.InvoiceNr = IVr.SerNr;
            end else begin
              CSrw.Invoiced = 0;
              CSrw.InvoiceNr = "";
            end;
            MatRowPut(CSr,i,CSrw);
            i = rwcnt;
          end;
        end;
        RecordUpdate(oldCSr,CSr,false);
      end;
    end else begin
      BlockLoad(CMb);
        if(nonblank(CMb.InstalmentItem))then begin
        CSr.CredManNr = IVr.CustCredManNr;
        rwcnt = matrowcnt(IVr);
        for(i=0;i<rwcnt;i=i+1)begin
          matrowget(IVr,i,IVrw);
          if(IVrw.stp==1 and IVrw.ArtCode==CMb.InstalmentItem)then begin
            instalmentSum = instalmentSum + IVrw.Sum;
          end;
          if(IVrw.stp==1 and IVrw.ArtCode==CMb.RateItem)then begin
            // rateItemSum = rateItemSum + IVrw.Sum;//Interes no need to add to future periods// Edit ************************** BPI Ukraine - KramarAlexandr - 04, 13 01 2022 y. at 12:09:26 PM
          end;
        end;
        if (ReadFirstMain(CSr,1,true)) then begin
          RecordCopy(oldCSr,CSr);
          rwcnt = MatRowCnt(CSr);
        
          for (i=rwcnt-1;i>=0;i=i-1) begin
            MatRowGet(CSr,i,CSrw);
            if(setf)then begin
              if(CSrw.Invoiced==1)then begin
                ClearRow(CSr,CSrw,1);
                CSrw.InvDate = IVr.InvDate;
                CSrw.Type = 6;
                CSrw.Invoiced = 1;
                CSrw.InvoiceNr = IVr.SerNr;
                CSrw.Principle = -instalmentSum;
                CSrw.Interest = -rateItemSum;
                CSrw.Total = -(instalmentSum + rateItemSum);
                matrowinsert(CSr,i+1,CSrw);
                SumupCredManSched(CSr,i+1);
                rwcnt = matrowcnt(CSr);
                if(IVr.CreditPrincipleRule==0)then begin
                  counter = 0;
                  for(j=rwcnt-1;j>i+1;j=j-1)begin
                    MatRowGet(CSr,j,CS2rw);
                    if(CS2rw.Type==0 and CS2rw.Invoiced==0)then begin
                      counter = counter + 1;
                    end;
                  end;
                  princpart = round(instalmentSum/counter,defaultcurroundoff);
                  intpart = round(rateItemSum/counter,defaultcurroundoff);
                  delta = (princpart*counter)-instalmentSum;
                  intdelta = (intpart*counter)-rateItemSum;
                  for(j=rwcnt-1;j>i+1;j=j-1)begin
                    MatRowGet(CSr,j,CS2rw);
                    if(CS2rw.Type==0 and CS2rw.Invoiced==0)then begin
                      CS2rw.Principle = CS2rw.Principle + princpart - delta;
                      CS2rw.Interest = CS2rw.Interest + intpart - intdelta;
                      delta = 0;
                      intdelta = 0;
                      MatRowPut(CSr,j,CS2rw);
                      SumupCredManSched(CSr,j);
                    end;
                  end;
                end else begin
                  for(j=rwcnt-1;j>i+1;j=j-1)begin
                    MatRowGet(CSr,j,CS2rw);
                    if(CS2rw.Type==0 and CS2rw.Invoiced==0)then begin
                      CS2rw.Principle = CS2rw.Principle + instalmentSum;
                      CS2rw.Interest = CS2rw.Interest + rateItemSum;
                      MatRowPut(CSr,j,CS2rw);
                      SumupCredManSched(CSr,j);
                      j=i+1;
                    end;
                  end;
                end;
                i=0;
              end;
            end else begin
              if(stringtolongint(CSrw.InvoiceNr)==IVr.SerNr)then begin
                if(IVr.CreditPrincipleRule==0)then begin
                  counter = 0;
                  for(j=rwcnt-1;j>i;j=j-1)begin
                    MatRowGet(CSr,j,CS2rw);
                    if(CS2rw.Type==0 and CS2rw.Invoiced==0)then begin
                      counter = counter + 1;
                    end;
                  end;
                  princpart = round(instalmentSum/counter,defaultcurroundoff);
                  intpart = round(rateItemSum/counter,defaultcurroundoff);
                  delta = (princpart*counter)-instalmentSum;
                  intdelta = (intpart*counter)-rateItemSum;
                  for(j=rwcnt-1;j>i;j=j-1)begin
                    MatRowGet(CSr,j,CS2rw);
                    if(CS2rw.Type==0 and CS2rw.Invoiced==0)then begin
                      CS2rw.Principle = CS2rw.Principle - princpart + delta;
                      CS2rw.Interest = CS2rw.Interest - intpart + intdelta;
                      delta = 0;
                      intdelta = 0;
                      MatRowPut(CSr,j,CS2rw);
                      SumupCredManSched(CSr,j);
                    end;
                  end;
                end else begin
                  for(j=rwcnt-1;j>i;j=j-1)begin
                    MatRowGet(CSr,j,CS2rw);
                    if(CS2rw.Type==0 and CS2rw.Invoiced==0)then begin
                      CS2rw.Principle = CS2rw.Principle - instalmentSum;
                      CS2rw.Interest = CS2rw.Interest - rateItemSum;
                      MatRowPut(CSr,j,CS2rw);
                      SumupCredManSched(CSr,j);
                      j = i;
                    end;
                  end;
                end;
                matrowdelete(CSr,i);
                i=0;
              end;
            end;
          end;
          CredManSchedRecalcBalance(CSr);
          RecordUpdate(oldCSr,CSr,false);
        end;
      end;
    end;
  end;

  return;
end; 

procedure AddCredHistToArray(var record ORVc ORr,record CredHistVc prevCredHistr,val balance)
begin
  row ORVc ORrw;
  record IVVc IVr;
  record ARVc ARr;
  record IPVc IPr;
 
  ClearRow(ORr,ORrw,1);
  ORrw.GroupOrdRow = prevCredHistr.RecordNr;
  ORrw.RowOrderType = prevCredHistr.RecordType;
  ORrw.PickingDate = prevCredHistr.PayDate;
  ORrw.PlanShipRowDate = prevCredHistr.TransDate;
  ORrw.InloadingDate = prevCredHistr.CredFromDate;
  ORrw.DespatchRowDate = prevCredHistr.CredToDate;
  ORrw.rowGP = balance;
  ORrw.CUServiceHistNr = prevCredHistr.SerNr;
  if (prevCredHistr.RecordType==kCredHistRecTypeInvoice) then begin
    IVr.SerNr = prevCredHistr.RecordNr;
    if (ReadFirstMain(IVr,1,true)) then begin
      ORrw.Sum = IVr.Sum4;
      ARr.InvoiceNr = IVr.SerNr;
      if (ReadFirstMain(ARr,1,true)) then begin
        ORrw.TAX1Reb = ARr.RVal;
      end;
    end;
  end else begin
    IPr.SerNr = prevCredHistr.RecordNr;
  end;
  MatRowInsert(ORr,0,ORrw);

  return;
end;


global
procedure GetCredManEventList(record CredManVc CredManr,var record ORVc ORr)
begin
  record CredHistVc CredHistr,prevCredHistr;
  Boolean TrHs,firstf;
  val balance;
  Integer int_type;
  
  TrHs = true;
  CredHistr.CredManNr = CredManr.SerNr;
  int_type = GetInterestPaymentType(CredManr);
  if (int_type==2) then begin
    balance = 0;
  end else begin
    balance = CredManr.InvSum4;
  end;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if (CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      //sortrows
      if (firstf==true and (CredHistr.RecordType!=prevCredHistr.RecordType or CredHistr.RecordNr!=prevCredHistr.RecordNr)) then begin
        AddCredHistToArray(ORr,prevCredHistr,balance);
      end;
      if (CredHistr.RecordType==kCredHistRecTypeInvoice and (CredHistr.ChargeType==kEventTypeIssueInstalment or CredHistr.ChargeType==kEventTypeIssueDeposit or CredHistr.ChargeType==kEventTypePartialBuyout)) then begin
        balance = balance - CredHistr.Sum;
      end;
      if (CredHistr.RecordType==4) then begin//partial buyout
        balance = balance - CredHistr.Sum;
      end;
      if (CredHistr.RecordType==5 and int_type==2) then begin//payment
        balance = balance + CredHistr.Sum;
      end;
      firstf = true;
      RecordCopy(prevCredHistr,CredHistr);
    end;
  end;
  if (prevCredHistr.SerNr>-1) then begin
    AddCredHistToArray(ORr,prevCredHistr,balance);
  end;

  SortRows(ORr,"PlanShipRowDate",true);

  return;
end;

global
procedure GetCredManEventList2(Longint credmannr,var record ORVc ORr)
begin
  record CredManVc CredManr;

  CredManr.SerNr = credmannr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    GetCredManEventList(CredManr,ORr);
  end;  

  return;
end;

function Boolean BuyerPaidInvoice(record CredManVc CredManr,var Longint ivnr)
begin
  record CredHistVc CredHistr;
  Boolean res,TrHs;
  
//in first version we will assume this invoice has only one item therefore we can check record history only
  TrHs = true;
  while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,TrHs)) begin
    if (CredHistr.RecordType==0 and CredHistr.PaidFlag==1) then begin
      res = true;
      ivnr = CredHistr.RecordNr;
      TrHs = false;
    end;
  end;

  BuyerPaidInvoice = res;
  return;
end;

function Boolean GetFactoringDays(record CredManVc CredManr,var date paydate,var Integer factdays)
begin
  record CredHistVc CredHistr;
  Boolean res;

  paydate = "";
  while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,true)) begin
    if (CredHistr.RecordType==1) then begin
      if (CredHistr.TransDate>paydate) then begin
        paydate = CredHistr.TransDate;
      end;
    end;
  end;

  if (nonblank(paydate)) then begin
    factdays = DateDiff(paydate,CredManr.startDate);
    res = true;
  end;

  GetFactoringDays = res;
  return;
end; 

global
updating procedure StoreCredManSchedRecord(record CredManSchedVc CSr)
begin
  record CredManSchedVc oldCSr;

  logtext(0,"StoreCredManSchedRecord " & matrowcnt(CSr));
  HALCALLSTACK;

  oldCSr.CredManNr = CSr.CredManNr;
  if (ReadFirstMain(oldCSr,1,true)) then begin
    RecordUpdate(oldCSr,CSr,false);
  end else begin
    RecordInsert(CSr,true);
  end;

  return;
end;

global
procedure GenerateAgreementSchedule(record CredManVc CredManr,Boolean forcef,Boolean fullf)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record SMVc SMr;
  row SMVc SMrw;
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt,rw;
  Boolean updf,intf;
  record CredFeesMatrixVc FMr;
  val bal;
  transaction Boolean gSilenceIVOpenPrepExists;
  Integer int_type;
  
logforadmin(0,"GenerateAgreementSchedule1");
  gSilenceIVOpenPrepExists = true;
  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    RecordCopy(oldCSr,CSr);
    if (blank(CSr.OfficialSerNr)) then begin
      CSr.OfficialSerNr = CredManr.OfficialSerNr;
    end;
    rwcnt = MatRowCnt(CSr);
    if (fullf) then begin
      for (i=rwcnt-1;i>=0;i=i-1) begin
        MatRowDelete(CSr,i);
      end;
    end;
    updf = true;
  end else begin
    RecordNew(CSr);
    CSr.CredManNr = CredManr.SerNr;
    CSr.CustCode = CredManr.CustCode;
    CSr.CustName = CredManr.Addr0;
    CSr.OfficialSerNr = CredManr.OfficialSerNr;
  end;
  if (updf and forcef==false) then begin
    goto lout;
  end;
  CSr.TransDate = CurrentDate;
  CSr.TransTime = CurrentTime;
  BlockLoad(CMb);
  BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
  BuildCredManInfoMatrix(CredManr,CredManPayPlanr,CMb,SMr);
  int_type = GetInterestPaymentType(CredManr);
  if (int_type==2) then begin
    bal = 0;
  end else begin
    bal = CredManr.InvSum4;
  end;
  rwcnt = MatRowCnt(SMr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMr,i,SMrw);
    if (fullf or (intf==false) or updf==false) then begin
      if (fullf) then begin
        ClearRow(CSr,CSrw,1);
      end else begin
        MatRowGet(CSr,i,CSrw);
      end;
      CSrw.InvDate = SMrw.TransDate;
      CSrw.PayDate = SMrw.DueDate;
      CSrw.Type = SMrw.RowSimStat;
      switch (CSrw.Type) begin
        case 4:
          CSrw.Total = SMrw.CurDebVal;
          CSrw.Invoiced = 1;
          bal = bal - CSrw.Total;
          CSrw.Balance = bal;
        case 5:
          CSrw.Principle = SMrw.DebVal;
          bal = bal + CSrw.Principle;
          CSrw.Invoiced = 1;
          CSrw.Balance = bal;
        /*case 6:
          CSrw.Principle = SMrw.DebVal;
          CSrw.Invoiced = 1;
          CSrw.Balance = bal;
          CSrw.Interest = SMrw.CredVal;
          if (nonblank(SMrw.ExtraComment)) then begin
            CSrw.Invoiced = 1;
            CSrw.InvoiceNr = SMrw.ExtraComment;
          end;*/
        otherwise
          CSrw.FromDate = SMrw.Objects;
          CSrw.Principle = SMrw.DebVal - SMrw.ToRateB1;
          CSrw.Deposit = SMrw.ToRateB1;
          bal = bal - CSrw.Principle - CSrw.Deposit;
          CSrw.Balance = bal;
          CSrw.Interest = SMrw.CredVal;
          CSrw.Fees = SMrw.DebVal2;
          UnpackRowFieldMatrix(SMrw,"FeesMatrix",FMr);
          PackRowFieldMatrix(CSrw,"FeesMatrix",FMr);
          CSrw.Total = SMrw.CurDebVal;
          if (fullf) then begin
            CSrw.ToDate = SMrw.Comment;
          end;
          if (nonblank(SMrw.ExtraComment)) then begin
            CSrw.Invoiced = 1;
            CSrw.InvoiceNr = SMrw.ExtraComment;
          end;
      end;
      if (CSrw.Interest>0) then begin
        intf = true;
      end;
      MatRowPut(CSr,rw,CSrw);
      rw = rw + 1;
    end;
  end;
  logtext(0,"StoreCredManSchedRecord  " & matrowcnt(CSr));
  qupdating.StoreCredManSchedRecord(CSr);

lout:;
logforadmin(0,"GenerateAgreementSchedule2");
  gSilenceIVOpenPrepExists = false;
  return;
end;

global procedure GenerateAgreementScheduleTask(record CredManVc CredManr,Boolean forcef,Boolean fullf)
begin
  
  NewTimedTask2("CreateCredManSched" & CredManr.SerNr,"CreateCredManSched","CreateCredManSchedTask1",CredManr.SerNr,CurrentDate,AddSeconds(CurrentTime,1),"","");


return;
end;

global
procedure CreateCredManSchedTask1(string args)
begin
  record CredManVc CredManr;
  
  CredManr.SerNr = StringToLongint(args);
  if (ReadFirstMain(CredManr,1,true)) then begin
    GenerateAgreementSchedule(CredManr,true,true);
  end;

  return;
end;

global
procedure CreateCredManSchedTask(string args)
begin
  record CredManVc CredManr;
  
  CredManr.SerNr = StringToLongint(args);
  if (ReadFirstMain(CredManr,1,true)) then begin
    GenerateAgreementSchedule(CredManr,false,true);
  end;

  return;
end;

global
function Boolean AgreementPaidOut(record CredManVc CredManr,var val paidout)
begin
  Boolean res;
  record CredHistVc CredHistr;
  val calcbal;

  paidout = 0;
  while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,true)) begin
    if (CredHistr.RecordType==5) then begin//payment
      paidout = paidout + CredHistr.Sum;
    end;
  end;
  if (CredManr.InvSum4<=paidout) then begin
    res = true;
  end;

  AgreementPaidOut = res;
  return;
end;

global
function Boolean AgreementPaidOut2(record CredManVc CredManr,var val paidout)
begin
  Boolean res;
  record CredHistVc CredHistr;
  val calcbal;
  record VIVc VIr;
  record APVc APr;

  paidout = 0;
  if (GetInterestPaymentType(CredManr)==2) then begin
    AgreementPaidOut(CredManr,paidout);
  end else begin
    APr.SerNr = CredManr.VINr;
    VIr.SerNr = CredManr.VINr;
    ReadFirstmain(APr,1,true)
    if (ReadFirstmain(VIr,1,true)) then begin
      paidout = paidout + (VIr.PayVal-APr.RVal);
    end;
  end;

  AgreementPaidOut2 = res;
  return;
end;

global 
updating procedure CheckCredManFinished(Longint credmannr,date fdate)
begin
  record CMOrderClassBlock OCb;
  record CredManVc CredManr,oldCredManr;
  record RcVc RepSpec;
  Integer int_type;
  val paidout;
  
  logtext(0,"CheckCredManFinished " & credmannr);
  
  CredManr.SerNr = credmannr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    RepSpec.d1 = CurrentDate;
    int_type = GetInterestPaymentType(CredManr);
    if (int_type!=2 or AgreementPaidOut(CredManr,paidout)) then begin
      
      CheckBuyOutAgreement2(CredManr,RepSpec,true);
      if (RepSpec.vals2==0) then begin
        BlockLoad(OCb);
        RecordCopy(oldCredManr,CredManr);
        CredManr.OrderClass = OCb.FinishCredOrderClass;
        CredManr.Status = 7;
        CredManr.FinishDate = fdate;
        
        RecordUpdate(oldCredManr,CredManr,true);
      end;
    end;
  end;
  

  return;
end;
global 
updating procedure CheckCredManFinished2(record IPVc IPr)
begin
  row IPVc IPrw;
  Integer i,rwcnt;
  vector Boolean vCMr;
  record IVVc IVr;

  rwcnt = MatRowCnt(IPr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IPr,i,IPrw);
    IVr.SerNr = IPrw.InvoiceNr;
    if (IPrw.InvoiceNr>0 and ReadFirstMain(IVr,1,true)) then begin
      if (IVr.CustCredManNr>0) then begin
        if (vCMr[IVr.CustCredManNr]==false) then begin
          CheckCredManFinished(IVr.CustCredManNr,IPr.TransDate);
          vCMr[IVr.CustCredManNr] = true;
        end;
      end;
    end;
  end;
  

  return;
end;

global
function val GetCredManItemValue(record IVVc IVr,string item,Boolean setzerof)
begin
  Integer i,rwcnt;
  val res;
  row IVVc IVrw;

  if (setzerof) then begin
    res = 0;
  end;
  
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVrw.ArtCode==item) then begin
      res = res + IVrw.Sum;
    end;
  end;

  GetCredManItemValue = res;
  return;
end;

global
function string 255 GetReceiptsPayMode(record IVVc IVr)
begin
  Boolean foundf;
  record IPrsVc IPrsr;
  string 255 res;
  record IPVc IPr;
  
  IPrsr.IVNr = IVr.SerNr;
  IPrsr.TransType = kIPrsTransTypeReceipt;
  foundf = true;
  while (LoopKey("IVKey",IPrsr,2,foundf)) begin
    if (IPrsr.IVNr!=IVr.SerNr or IPrsr.TransType!=kIPrsTransTypeReceipt) then begin 
      foundf = false;
    end else begin
      IPr.SerNr = IPrsr.TransNr;
      if (ReadFirstMain(IPr,1,true)) then begin
        res = IPr.PayMode;
        foundf = false;
      end;
    end;
  end;

  GetReceiptsPayMode = res;
  return;
end;

global
updating procedure MakeMoneyRuturnIVVcRemote(record IVVc IVr,var record IPVc IPr)
begin
  row IPVc IPrw;
  Integer rownr;
  val chk;
  Boolean installmentf;
  Longint err;
  record ARVc ARr;
  val sum;
  record IPVc oldIPr;

  sum = IVr.Sum4;
  ARr.InvoiceNr = IVr.SerNr;
  if (ReadFirstMain(ARr,1,true)) then begin
    if (ARr.RVal>=0) then begin
      sum =   IVr.Sum4 - ARr.RVal;
    end;
  end;

  if (sum>0) then begin
    RecordNew(IPr);
    IPr.TransDate = CurrentDate;
    IPr.SerNr = NextSerNr("IPVc",IPr.TransDate,-1,false,"");
    IPr.RegDate = CurrentDate;
    IPr.OKFlag = 0;
    IPr.PayMode = GetReceiptsPayMode(IVr);
    IPPastePayMode(IPr);
    rownr = 0;
    ClearRow(IPr,IPrw,1);
    IPrw.InvoiceNr = IVr.SerNr;
    MatRowPut(IPr,rownr,IPrw);
    PasteInvIn2IPr(IPr,rownr,IPr.TransDate,chk,false,installmentf);
    MatRowGet(IPr,rownr,IPrw);
    IPrw.RecVal = -sum;
    MatRowPut(IPr,rownr,IPrw);
    IPVc_PasteRecVal(IPr,rownr);

    rownr = 1;
    ClearRow(IPr,IPrw,1);
    IPrw.CustCode = IVr.CustCode;
    MatRowPut(IPr,rownr,IPrw);
    IPVc_PasteCustCode(IPr,rownr,err);
    MatRowGet(IPr,rownr,IPrw);
    IPrw.RecVal = sum;
    IPrw.CUPNr = IPr.SerNr;
    MatRowPut(IPr,rownr,IPrw);
    IPVc_PasteRecVal(IPr,rownr);
    
    IPSumup(IPr);
    if (RecordInsert(IPr,true)) then begin
      RecordCopy(oldIPr,IPr);
      IPr.OKFlag = 1;
      RecordUpdate(oldIPr,IPr,true);
    end;
  end;
  return;
end;

global
function boolean CustomerHasAgreement(string cucode,string agreementlist)
begin
  Longint pos2;
  string 255 tmp;
  record CredManVc CredManr;
  boolean testf;
  
  testf = false;
  pos2 = -1;
  while (GetNextSubstring(agreementlist,pos2,",",tmp)) begin
    CredManr.SerNr = StringToLongint(tmp);
    if (ReadFirstMain(CredManr,1,true)) then begin
      if (CredManr.CustCode==cucode) then begin
        testf = true;
        goto LWhile;
      end;
    end;
  end;
  LWhile:;
  CustomerHasAgreement = testf;
  return;
end;

global
function boolean CheckIPCredManNr(longint credmannr,record IPVc IPr)
begin
  record CredHistVc CredHistr;
  boolean res,TrHs;
  
  res = false;
  CredHistr.RecordNr = IPr.SerNr;
  CredHistr.RecordType = kCredHistRecTypeReceipt;
  TrHs = true;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordNr!=IPr.SerNr) or (CredHistr.RecordType!=kCredHistRecTypeReceipt) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      if (CredHistr.CredManNr==credmannr) then begin
        res = true;
        TrHs = false;
      end;
    end;
  end;
  CheckIPCredManNr = res;
  return;
end;

global
function boolean IsCredManNrInvoice(longint credmannr,longint invoicenr)
begin
  record CredHistVc CredHistr;
  boolean res;
  
  res = false;
  if ((invoicenr>-1) and (credmannr>-1)) then begin
    CredHistr.RecordType = kCredHistRecTypeInvoice;
    CredHistr.RecordNr = invoicenr;
    if (ReadFirstKey("RecordNr",CredHistr,2,true)) then begin
      if (CredHistr.CredManNr==credmannr) then begin
        res = true;
      end;
    end;
    if (res==false) then begin
      CredHistr.RecordType = kCredHistRecTypeCreditNote;
      CredHistr.RecordNr = invoicenr;
      if (ReadFirstKey("RecordNr",CredHistr,2,true)) then begin
        if (CredHistr.CredManNr==credmannr) then begin
          res = true;
        end;
      end;
    end;
  end;
  IsCredManNrInvoice = res;
  return;
end;

global
function val GetCredManBalanceOnDate(longint credmannr,date d)
begin
  val res,t;
  record CredManSetBlock CredManSetb;
  record CredManPayPlanVc CredManPayPlanr;
  row CredManPayPlanVc CredManPayPlanrw;
  record CredManVc CredManr;
  record CredHistVc CredHistr;
  boolean TrHs;
  
 /* does not work for periodic statement?
  BlockLoad(CredManSetb);
  CredManr.SerNr = credmannr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    BuildCredManPayPlanCust2(CredManr,CredManPayPlanr,CredManSetb,true,true,false);  
    res = GetBalanceOnDate(CredManPayPlanr,d);
  end;
  */
  CredHistr.CredManNr = credmannr;
  TrHs = true;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if(CredHistr.CredManNr!=credmannr) then begin
      TrHs = false;
    end;
    if (CredHistr.TransDate>d) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      if (CredHistr.RecordType==kCredHistRecTypeInvoice) then begin
        t = GetCredHistOpenValueOnDate(CredHistr.SerNr,d);
        res = res + t;
      end;
    end;
  end;
  logforadmin(0,"GetCredManBalanceOnDate= " & res & " credmannr=" & credmannr & " d=" & d);
  GetCredManBalanceOnDate = res;
  return;
end;

global
function val GetCredManStartBalance(longint credmannr,date d)
begin
  date d1;
  
  d1 = AddDay(d,-1);
  GetCredManStartBalance = GetCredManBalanceOnDate(credmannr,d1);
  return;
end;


//TODO: this does not return agreement's open prepayments...
global 
function val GetCredManOpenPrepaymentsAmount(longint credmannr)
begin
  val res;
  record CredHistVc CredHistr;
  Boolean TrHs;
    
  res = blankval;
  TrHs = true;
  CredHistr.CredManNr = credmannr;
  CredHistr.RecordType = 2;
  while (LoopKey("CredManRecordType",CredHistr,1,TrHs)) begin
    if (CredHistr.CredManNr!=credmannr or CredHistr.RecordType!=2) then begin
        TrHs = false;
      end;
    end;
    if (TrHs) then begin
      res = res + CredHistr.Sum;
    end;
end;

global
function string 255 AddCredManInvoiceMailRecipients(record CUVc CUr,var string mobile)
begin
  record CMInvoicingBlock CIb;
  record CUVc ContactCUr;
  string 255 res;
  vector boolean vmails;
  array string 100 amails;
  record ContactRelVc CRr;
  record EmailRecipVc EmailRecipr;
  row EmailRecipVc EmailReciprw;
  Integer i,rwcnt,mailrow;
  record CUVc CU2r;

  mobile = "";
  res = "";
  
  BlockLoad(CIb);
  if (CIb.SendToMainContact==1) then begin
    if (nonblank(CUr.Person)) then begin
      if (FindCustomerRelation(CUr.Code,CUr.Person,ContactCUr)) then begin
        if (nonblank(ContactCUr.eMail)) then begin
          vmails[ContactCUr.eMail] = true;
        end;
      end;
    end;
  end;
  if (CIb.SendToCompany==1) then begin
    if ((CIb.SendToCompNoContact==0) or (blank(CUr.Person))) then begin
     vmails[CUr.eMail] = true;
    end;
  end;
  if (CIb.SendToAddRecip==1) then begin
    EmailRecipr.MainContactCode = Cur.Code;
    if ReadFirstMain(EmailRecipr,1,true) then begin 
      rwcnt = MatRowCnt(EmailRecipr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(EmailRecipr,i,EmailReciprw);
        if (nonblank(EmailReciprw.ContactCode) and (EmailReciprw.DocType==kMailInvoice)) then begin 
          CU2r.Code = EmailReciprw.ContactCode;
          if (ReadFirstMain(CU2r,1,true)) then begin 
            if (nonblank(CU2r.eMail)) then begin 
              vmails[CU2r.eMail] = true;
            end;   
          end;
        end;
      end;  
    end;
  end;
  if (nonblank(CIb.SendToJobDescr)) then begin
    while (LoopKey("CustContactCode:" & CUr.Code,CRr,1,true)) begin
      if (CRr.Invalid==0) then begin
        ContactCUr.Code = CRr.ContactCode;
        if (ReadFirstMain(ContactCUr,1,true)) then begin
          if(nonblank(ContactCUr.Mobile))then begin
            mobile = ContactCUr.Mobile;
          end;
          if(nonblank(ContactCUr.JobDesc))then begin
            if (SetInSet(ContactCUr.JobDesc,CIb.SendToJobDescr)) then begin
              vmails[ContactCUr.eMail] = true;
            end;
          end;
        end;
      end;
    end;
  end;
  
  if(nonblank(CUr.Mobile))then begin
    mobile = CUr.Mobile;
  end;
  
  getvectortags(vmails,amails);
  for(i=0;i<amails.length;i=i+1)begin
    if(i>0 and nonblank(res) and nonblank(amails[i]))then begin
      res = res & ",";
    end;
    res = res & amails[i];
  end;
  
  AddCredManInvoiceMailRecipients = res;
  return;
end;


global updating procedure FillNewDataToIVRowsMn(record RcVc RepSpec)
begin
  record IVVc IVr;
  row IVVc IVrw;
  integer i,j,rwcnt,priority,itemquant;
  val ppsum,paid,remsum;
  boolean isprepay,needstore;
  val vatprc,vatval,vatexclprc,vatinclprc,rowtax;
  record CredHistVc CredHistr;
  boolean TrHs;
  array record ORVc arrORr;
  record ORVc ORr;
  row ORVc ORrw;
  vector val paidammont;



  IVr.SerNr = -1;
  while(loopmain(IVr,1,true))begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.stp==kInvoiceRowTypeNormal and nonblank(IVrw.ArtCode))then begin
        InvVat(1,IVr.InclVAT,IVr.NoTAXonVAT,IVr.ExportFlag,IVrw.VATCode,IVrw.Sum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);
        IVrw.SumWithVAT = IVrw.Sum + vatval;
        IVrw.SumAfterPrepayment = IVrw.SumWithVAT;
        MatRowPut(IVr,i,IVrw);
      end;
    end;
    recordstore(IVr,true);
  end;
  resetloop(IVr);
  
  IVr.SerNr = -1;
  while(loopmain(IVr,1,true))begin
    isprepay = false;
    ppsum = blankval;
    needstore = false;
    priority = blankval;
    clearvector(paidammont);
    itemquant = 0;
    if(IVr.OKFlag==1)then begin
      rwcnt = matrowcnt(IVr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        if (IVrw.stp==kInvoiceRowTypePrepayment and IVrw.BasePrice>0) then begin
          isprepay = true;
          ppsum = ppsum + IVrw.Sum;
        end;
      end;
      if((IVr.Sum4 - ppsum)==0)then begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          if (IVrw.stp==kInvoiceRowTypeNormal and nonblank(IVrw.ArtCode))then begin
            itemquant = itemquant + 1;
            paidammont[IVrw.CredHistNr] = IVrw.SumWithVAT;
            IVrw.SumAfterPrepayment = 0;
            needstore = true;
            MatRowPut(IVr,i,IVrw);
          end;
        end;
      end else begin
        
      end;
    end;
    
    if(ppsum>0 and (IVr.Sum4 - ppsum)!=0)then begin
      needstore = true;
      CredHistr.RecordNr = IVr.SerNr;
      CredHistr.RecordType = 0;
      cleararray(arrORr);
      TrHs = true;
      while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
        if (CredHistr.RecordNr!=IVr.SerNr or CredHistr.RecordType!=0) then begin
          TrHs = false;
        end else begin
          priority = GetItemPriority(CredHistr.CredManNr,CredHistr.ArtCode);
          InsertCredHistInArray(CredHistr,arrORr,priority,IVr.InvDate);
        end;
      end;
      resetloop(CredHistr);
      SortRecordArray(arrORr,"BuildOn");
      for (i=0;i<arrORr.length;i=i+1) begin
        ORr = arrORr[i];
        rwcnt = MatRowCnt(ORr);
        for (j=0;j<rwcnt;j=j+1) begin
          MatRowGet(ORr,j,ORrw);
          ORrw.Price = 0;
          MatRowPut(ORr,j,ORrw);
        end;
        arrORr[i] = ORr;
      end;
      
      
      
      remsum = ppsum;
      if (remsum>0) then begin
      //we could do this more efficiently 
        for (i=0;i<arrORr.length;i=i+1) begin
          ORr = arrORr[i];
          rwcnt = MatRowCnt(ORr);
          for (j=0;j<rwcnt;j=j+1) begin
            MatRowGet(ORr,j,ORrw);
            paid = ORrw.Sum-ORrw.Price;
            if (paid>0) then begin
              if (remsum<paid) then begin
                paid = remsum;
              end;
              remsum = remsum - paid;
              for (j=0;j<matrowcnt(IVr);j=j+1) begin
                MatRowGet(IVr,j,IVrw);
                if (IVrw.stp==kInvoiceRowTypeNormal and nonblank(IVrw.ArtCode) and (IVrw.CredHistNr==ORrw.CUServiceHistNr or (nonblank(IVrw.ArtCode) and IVrw.ArtCode==ORrw.ArtCode)))then begin
                  IVrw.SumAfterPrepayment = IVrw.SumAfterPrepayment - paid;
                  needstore = true;
                  MatRowPut(IVr,j,IVrw);
                end;
              end;
            end;
            if (remsum<=0) then begin
              goto LFindUnpaidCredHist;
            end;
          end;
        end;
      end;
LFindUnpaidCredHist:;
      
      
    end;
    
    
    if(isprepay)then begin
      if(needstore)then begin
        recordstore(IVr,true);
      end;
    end;
  end;

return;
end;