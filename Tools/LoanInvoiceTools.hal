external procedure BuildCredManPayPlanCust(record CredManVc,var record CredManPayPlanVc,record CredManSetBlock,Boolean,Boolean);
external inner function Boolean PasteCust2InInv(var record IVVc,record LocalMachineBlock,string,Boolean,var string,var string,var string,var string,var string);
remote inner procedure IVVc_PastePayDeal(var record IVVc,string,string);
remote inner procedure IVVc_PasteSalesMan(var record IVVc,string);
external inner function Boolean IVVc_PasteArtCode(var record IVVc,Integer,var string,var string,Boolean,var Integer);
external inner procedure IVDchsum(var record IVVc,Integer);
external inner procedure IVVc_PastePrice(var record IVVc,record IVVc,Integer,var string);
external inner function LongInt DateDiff(Date,Date);
external procedure AddPlannedFees(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,Integer,Integer,Date,var val,var val,Date,Date,Longint,Boolean);
external procedure AddInterest(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,Integer,Date,var val,var val,Date,Date,Longint,Boolean);
external procedure AddInstalmentFixed(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,val,Date,var val,var val,Date,Date);
forward procedure GetCredManEventList2(Longint,var record ORVc);
external inner procedure PasteARPayInIV(record IVVc,row IVVc,Integer);
external updating procedure FindUnpaidCredHist(record IPVc,row IPVc,var array val,Integer);
external inner function Boolean IVVc_PasteSum(var record IVVc,Integer,var Boolean,Integer);
external function Date GetLastInvoiceDate(record CredManVc,Date);
external procedure BuildCredManInfoMatrix(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,var record SMVc);
external inner procedure SumNoDownPay(record IVVc,var val,var val,var val,var val,var val,var val);
external function string 255 GetCredManNr(Longint);
external procedure GetHiddenInvoiceValues(record IVVc,var val,var val);
external inner procedure InvVat(Integer,Integer,Integer,Integer,string,val,var val,var val,var val,var val,var val);
external procedure GenerateAgreementSchedule(record CredManVc,Boolean);
external function Boolean BuildCredManInfoMatrixOnSchedule(record CredManVc,record CredManSetBlock,var record SMVc);
external function Boolean GetCredLegalNrLine(string,string,Date,string,string,var row CredLegalInvNrBlock,Integer);
external inner function string 50 NextLegalSerNr(string,LongInt,Date,string,string,string);
external function Boolean CanCreateSingleAgreementInvoice(record CredManVc,var Date);
external inner procedure IPSumup(var record IPVc);
external inner procedure IPVc_PasteRecVal(var record IPVc,Integer);
external inner function Boolean PasteInvIn2IPr(var record IPVc,Integer,Date,var val,Boolean,var Boolean);
external inner function Boolean IPVc_PasteCustCode(var record IPVc,Integer,var LongInt);
external function val FindInvoicePaidAmount_OP(LongInt,LongInt);
external inner procedure IPPastePayMode(var record IPVc);
external inner updating procedure CreateInvoicePdfFile(record IVVc);
external function Boolean CredManPMCodeMatches2(string,record CredManVc,Boolean);
remote procedure CheckBuyOutAgreementCallBack(record RcVc,Integer);

enum begin
  kCredHistRecTypeInvoice = 0,
  kCredHistRecTypeReceipt = 1,
  kCredHistRecTypePrepayment = 2
end;

enum begin
  kPlannedFeesMonthly = 0,
  kPlannedFeesOneTime = 1
end;

enum begin
  kEventTypeNone = 0,
  kEventTypeCalcInstalment = 1,
  kEventTypeCalcInterest = 2,
  kEventTypeCalcDeposit = 3,
  kEventTypeCalcFees = 4,
  kEventTypeIssueInstalment = 5,
  kEventTypeIssueInterest = 6,
  kEventTypeIssueDeposit = 7,
  kEventTypeIssueFees = 8,
  kEventTypeIssueLateFees = 9
end;

enum begin
  kMonthTypeFirst = 0,
  kMonthTypeRegular = 1,
  kMonthTypeLast = 2
end;

global
function string 255 CM_SetCompanyLanguage()
begin
  record CYBlock CYb;
  string 255 oldlang,newlang;
  Integer langmode;

  BlockLoad(CYb);
  oldlang = CurrentLanguage;
  newlang = CYb.LangCode;

  if (oldlang!=newlang and nonblank(newlang)) then begin
    langmode = SetFromString(619,newlang);
    if (langmode>-1) then begin
      SetLangMode(langmode,newlang,0);
    end;
  end;

  CM_SetCompanyLanguage = oldlang;
  return;
end;

global
procedure CM_ResetCompanyLanguage(string oldlang)
begin
  Integer oldlangmode;

  if (nonblank(oldlang) and CurrentLanguage!=oldlang) then begin
    oldlangmode = SetFromString(619,oldlang);
    if (oldlangmode>-1) then begin
      SetLangMode(oldlangmode,oldlang,0);
    end;
  end;

  return;
end;

updating procedure LinkCredManAndInvoice(record IVVc IVr,record CredManVc CredManr)
begin
  
  CreateRecordLink(IVr,CurrentCompany,CredManr,CurrentCompany);

  return;
end;

function Boolean FindInvLegalNrLine(Date sd,Date ed,string serie,var row LegalInvNrBlock tLINrbrw)
begin
  record LegalInvNrBlock LINrb;
  row LegalInvNrBlock LINrbrw;
  Integer i,rwcnt;
  Boolean res;

  BlockLoad(LINrb);
  rwcnt = MatRowCnt(LINrb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LINrb,i,LINrbrw);
    if (LINrbrw.PurchDate==sd and LINrbrw.EndDate==ed and LINrbrw.Serie==serie) then begin
      CopyRow(LINrb,LINrbrw,tLINrbrw);
      i = rwcnt;
      res = true;
    end;
  end;

  FindInvLegalNrLine = res;
  return;
end;

function string 255 GetCredManOfficialSerNr(record IVVc IVr,record CredManVc CredManr,Integer rectype)
begin
  row CredLegalInvNrBlock LegalInvNrrw;
  row LegalInvNrBlock LINrbrw;
  string 255 serie,res;
  
  if (nonblank(CredManr.OfficialSerNr)) then begin
    GetCredLegalNrLine("CredManVc",CredManr.SerNr,CredManr.startDate,CredManr.Type,CredManr.Classifications,LegalInvNrrw,-1);
    ;
    switch (rectype) begin
      case 0:serie = LegalInvNrrw.FirstInvSerie;
      case 1:serie = LegalInvNrrw.RegularInvSerie;
      case 2:serie = LegalInvNrrw.OverdueInvSerie;
    end;
    if (FindInvLegalNrLine(LegalInvNrrw.StartDate,LegalInvNrrw.EndDate,serie,LINrbrw)) then begin

      res = NextLegalSerNr("IVVc",IVr.SerNr,IVr.InvDate,LINrbrw.Serie,LINrbrw.TSerStart,LINrbrw.TSerEnd);
    end;
  end;


  GetCredManOfficialSerNr = res;
  return;
end;

function Integer GetInvoiceType(record CredManVc CredManr,Date invdate)
begin
  Integer res;
  
  if (invdate==CredManr.startDate) then begin
    res = 0;
  end else begin
    res = 1;
  end;

  GetInvoiceType = res;
  return;
end;

global
procedure SetupLoanInvoice(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Date invdate,Date fromdate,Date todate,Boolean sernrf,Boolean forcecustf,string ivno,Integer invtype,Boolean fullf)
begin
  record LocalMachineBlock LMb;
  string 255 warning,errstr,prepstr,invdatewarn,transdatewarn;
  row IVVc IVrw;
  string 255 oldlang;
  record CMInvoicingBlock CIb;
  string 255 del;

  BlockLoad(LMb);
  BlockLoad(CIb);
  if (fullf) then begin
    oldlang = CM_SetCompanyLanguage;
  end;

  RecordNew(IVr);
  IVr.CustCredManNr = CredManr.SerNr;
  IVr.TransDate = invdate;//or current date?
  IVr.InvDate = invdate;//from seting?
  IVr.CustCode = CredManr.CustCode;
  PasteCust2InInv(IVr,LMb,"",false,warning,errstr,prepstr,invdatewarn,transdatewarn);
  IVr.PayDeal = CredManr.PayDeal;
  IVVc_PastePayDeal(IVr,"",LMb.DefReturnLocation);
  IVr.SalesMan = CredManr.SalesMan;
  IVVc_PasteSalesMan(IVr,"");
  IVr.CredFromDate = fromdate;
  IVr.CredToDate = todate; 
  if (fullf) then begin
    if (nonblank(ivno)) then begin
      IVr.OfficialSerNr = ivno;
    end else begin
      IVr.OfficialSerNr = GetCredManOfficialSerNr(IVr,CredManr,invtype);
    end;
  end;
  if (sernrf) then begin
    IVr.SerNr = NextSerNr("IVVc",IVr.InvDate,-1,false,"");
  end;

  IVr.CredFromDate = fromdate;
  IVr.CredToDate = todate;
  if (invdate<CredManr.FirstInvDate and blank(fromdate)) then begin//First invoice language
    IVr.LangCode = CredManr.LangCode2;
    if (nonblank(CIb.FirstInvPayDeal)) then begin
      IVr.PayDeal = CIb.FirstInvPayDeal;
      IVVc_PastePayDeal(IVr,"",LMb.DefReturnLocation);
    end;
  end else begin
    IVr.LangCode = CredManr.LangCode;
  end;

  //we should always have in the plan first row instalment or interest where we have start and end date
  if (CIb.DetailedInvoice==1) then begin
    ClearRow(IVr,IVrw,1);
    if (nonblank(CredManr.OfficialSerNr)) then begin
      IVrw.Spec = CIb.InvoiceCommentStr & USetStr(200080) & CredManr.OfficialSerNr;
    end else begin
      IVrw.Spec = CIb.InvoiceCommentStr & USetStr(200080) & CredManr.SerNr;
    end;
    MatRowPut(IVr,0,IVrw);
    if (nonblank(fromdate)) then begin
      ClearRow(IVr,IVrw,1);
      del = ":";
      if (nonblank(CIb.PeriodDelimiter)) then begin
        del = CIb.PeriodDelimiter;
      end;

      IVrw.Spec = CIb.InvoiceCommentStr & USetStr(200081) & fromdate & del & todate;
      MatRowPut(IVr,1,IVrw);
    end else begin
      ClearRow(IVr,IVrw,1);
      IVrw.Spec = " ";
      MatRowPut(IVr,1,IVrw);      
    end;
    ClearRow(IVr,IVrw,1);
    IVrw.Spec = " ";
    MatRowPut(IVr,MatRowCnt(IVr),IVrw);
  end;
  CM_ResetCompanyLanguage(oldlang);

  return;
end;

global
procedure SetupInvoiceRowAndAdd(record CredManVc CredManr,var record IVVc IVr,string item,string itemname,val quant,val price,val reb,Integer chargetype,Longint factinv)
begin
  row IVVc IVrw;
  string 255 inwarning,warning;
  Integer sernrf,rw;
  record IVVc IV2r;
  val bval;
  record CredManAccVc CMAr;
  row CredManAccVc CMArw;
  Integer i,rwcnt;
  

  
  if (price>0 and nonblank(item)) then begin
    rw = MatRowCnt(IVr);
    ClearRow(IVr,IVrw,1);
    IVrw.ArtCode = item;
    IVrw.Quant = quant;
    IVrw.ChargeType = chargetype;
    IVrw.FactoringInvoice = factinv;
    MatRowPut(IVr,rw,IVrw);
    if (IVVc_PasteArtCode(IVr,rw,inwarning,warning,false,sernrf)) then begin    
      IVDchsum(IVr,rw);
    end;
    MatRowGet(IVr,rw,IVrw);
    IVrw.Price = price;
    if (reb>0) then begin
      IVrw.vRebate = reb;
    end else begin
      IVrw.vRebate = bval;//should it be like that? what about discount matrix?
    end;
    MatRowPut(IVr,rw,IVrw);
    IVVc_PastePrice(IVr,IV2r,rw,warning);
    if (nonblank(itemname)) then begin
      MatRowGet(IVr,rw,IVrw);
      IVrw.Spec = itemname;
      MatRowPut(IVr,rw,IVrw);
    end;

    CMAr.CredManType = CredManr.Type;
    if (ReadFirstMain(CMAr,1,true)) then begin
      rwcnt = MatRowCnt(CMAr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CMAr,i,CMArw);
        if (CMArw.ArtCode==IVrw.ArtCode) then begin
          MatRowGet(IVr,rw,IVrw);
          IVrw.PeriodCode = CMArw.PeriodCode;
          MatRowPut(IVr,rw,IVrw);
          i = rwcnt;
        end;
      end;
    end;
  end;

  return;
end;

function Boolean InvoiceHasHiddenLine(record IVVc IVr)
begin
  Integer i,rwcnt;
  row IVVc IVrw;
  Boolean res;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVrw.stp==kInvoiceRowTypeHidden) then begin
      res = true;
      i = rwcnt;
    end;
  end;

  InvoiceHasHiddenLine = res;
  return;
end;

procedure AddOverdueComments(var record IVVc IVr,array string lateformula)
begin
  Integer i,rwcnt;
  Boolean hiddenf;
  row IVVc IVrw,hiddenIVrw;
  
  if (!InvoiceHasHiddenLine(IVr)) then begin
    ClearRow(IVr,hiddenIVrw,kInvoiceRowTypeHidden);
    MatRowPut(IVr,MatRowCnt(IVr),hiddenIVrw);
  end;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<lateformula.length;i=i+1) begin
    ClearRow(IVr,IVrw,1);
    IVrw.Spec = lateformula[i];
    MatRowPut(IVr,rwcnt,IVrw);
    rwcnt = rwcnt + 1;
  end;

  return;
end;

global
procedure SetupOverdueLangCode(var record IVVc IVr,string type)
begin
  record CredManTypeVc CMTr;

  CMTr.Code = type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if (nonblank(CMTr.OverdueLangCode)) then begin
      IVr.LangCode = CMTr.OverdueLangCode;
    end;
  end;
  

  return;
end;

global
procedure AddLateFees(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Integer latedays,val lateamount,array string lateformula)
begin
  val laterate;
  record CMInvoicingBlock CIb;
  Boolean addf;
  record CredManTypeVc CMTr;
  
  if (lateamount>0) then begin
    addf = true;
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      if (CMTr.MinOverdueFee>0 and lateamount<CMTr.MinOverdueFee) then begin
        addf = false;
      end;
    end;
    if (addf) then begin
      SetupInvoiceRowAndAdd(CredManr,IVr,CMb.LateFeeItem,"",1,0,0,kEventTypeIssueLateFees,-1);
      SetupInvoiceRowAndAdd(CredManr,IVr,CMb.LateRateItem,"",1,lateamount,0,kEventTypeIssueLateFees,-1);
      BlockLoad(CIb);
      if (CIb.AddOverdueDetails==1) then begin
        AddOverdueComments(IVr,lateformula);
      end;
    end;
  end;

  return;
end;

function Integer GetMonthDays(Date td)
begin
  Integer res;

  res = DaysInMonth(GetYear(td),GetMonth(td));

  GetMonthDays = res;
  return;
end;

procedure GetLatePaymentPlan(record CredManVc CredManr,record CredHistVc CredHistr,Date sd,Date ed,Date overduetd,var array val amounts,var array Integer daycnt)
begin
  Date tempsd,tempsd2;
  record CredHistVc CredPayr;//CredPayr - same credhistvc register, just for payments
  Integer i,daydiff,daydiff2;
  Boolean TrHs;
  val paysum;
  
  paysum = CredHistr.Sum;
  tempsd = sd;//this is the start date when this item should have been paid since
  if (nonblank(overduetd)) then begin
    tempsd = AddDay(overduetd,1);
  end;
  if (tempsd<=CredHistr.PayDate) then begin
    tempsd = AddDay(CredHistr.PayDate,1);
  end;
  tempsd2 = tempsd;

  /*
  if (CredManr.LateFeeDays>0) then begin
    tempsd = AddDay(tempsd,CredManr.LateFeeDays);
  end;
  */

  ClearArray(amounts);
  TrHs = true;
  CredPayr.PreviousNr = CredHistr.SerNr;
  while (LoopKey("PreviousNr",CredPayr,1,TrHs)) begin
    if (CredPayr.PreviousNr!=CredHistr.SerNr) then begin
      TrHs = false;
    end else begin
      if (CredPayr.TransDate>CredHistr.PayDate) then begin
        if (CredPayr.TransDate>tempsd and CredPayr.TransDate<=ed) then begin
          daydiff = DateDiff(CredPayr.TransDate,tempsd)+1;//or DateDiff2 to get daydiff+1 days
          daydiff2 = DateDiff(CredPayr.TransDate,CredHistr.PayDate);//or DateDiff2 to get daydiff+1 days
          if (CredManr.LateFeeDays<daydiff2) then begin
            for (i=0;i<daydiff;i=i+1) begin
              amounts[amounts.length] = paysum;
              daycnt[daycnt.length] = GetMonthDays(AddDay(CredPayr.TransDate,i));
            end;
          end;
        end;
        if (CredPayr.TransDate>ed) then begin//no need to continue for later payments
          TrHs = false;
        end else begin
          if (tempsd<CredPayr.TransDate) then begin
            tempsd = CredPayr.TransDate;
          end;
        end;
      end;
      if (CredPayr.TransDate<=ed) then begin
        paysum = paysum - CredPayr.Sum;
      end;
    end;
  end;
  if (paysum>0 and tempsd<=ed) then begin
    daydiff = DateDiff(ed,tempsd)+1;
    daydiff2 = DateDiff(ed,CredHistr.PayDate);
    if (CredManr.LateFeeDays<daydiff2) then begin
      for (i=0;i<daydiff;i=i+1) begin
        amounts[amounts.length] = paysum;
        daycnt[daycnt.length] = GetMonthDays(AddDay(ed,i));
      end;
    end;
  end;

  return;
end;

global
procedure CheckOverdueInvoicesForItem(record CredManVc CredManr,record CredManSetBlock CMb,val maxmonths,Date invdate,Date prevtd,var Integer latedays,var val lateamount,string item,Date overduetd,var array string lateformula,Integer ratetype)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  array val amounts;
  array Integer daycnt;
  val latefee;
  Integer i,odays,lastdaycnt;
  val overdueprc,lastamount;
  Date mindate;

  if (maxmonths>0) then begin
    mindate = AddMonth(invdate,-maxmonths);
  end;

  overdueprc = CredManr.OverduePercentage;
  if (CredManr.AnnualRate==1) then begin
    //overdueprc = overdueprc/12; overdues should not be affected by annual
  end;
  TrHs = true;
  CredHistr.ArtCode = item;
  CredHistr.CredManNr = CredManr.SerNr;
  while (LoopKey("ArtCode",CredHistr,2,TrHs)) begin
    if (CredHistr.ArtCode!=item or CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      if (blank(mindate) or CredHistr.TransDate>=mindate) then begin
        //Construct an array of days with amount that is over due starting with the first day of period
        GetLatePaymentPlan(CredManr,CredHistr,AddDay(prevtd,1),invdate,overduetd,amounts,daycnt);
        lastamount = 0;
        odays = 0;
        for (i=0;i<amounts.length;i=i+1) begin
          if (ratetype==0) then begin //as default
            latefee = latefee + (amounts[i]*(overdueprc/100));
          end else begin
            latefee = latefee + (amounts[i]*(overdueprc/100)/lastdaycnt);
          end;
          if ((lastamount!=amounts[i] and lastamount>0) or (ratetype==1 and lastdaycnt!=daycnt[i])) then begin
            if (ratetype==0) then begin //as default
              lateformula[lateformula.length] = odays & " Days " &  " - " & item & " - " & lastamount & " * " & ValToString((overdueprc/100),M45Val,"",",",0) & "=" & (lastamount*(overdueprc/100) * odays);
            end else begin
              lateformula[lateformula.length] = odays & " Days " &  " - " & item & " - " & lastamount & " * " & ValToString((overdueprc/100),M45Val,"",",",0) & "/" & lastdaycnt & "=" & (lastamount * odays*(overdueprc/100)/lastdaycnt);
            end;
            odays = 0;
          end;
          odays = odays + 1;
          lastamount = amounts[i];
          lastdaycnt = daycnt[i];
        end;
        if (odays>0) then begin
          if (ratetype==0) then begin //as default
            lateformula[lateformula.length] = odays & " Days " &  " - " & item & " - " & lastamount & " * " & ValToString((overdueprc/100),M45Val,"",",",0) & "=" & (lastamount*(overdueprc/100) * odays);
          end else begin
            lateformula[lateformula.length] = odays & " Days " &  " - " & item & " - " & lastamount & " * " & ValToString((overdueprc/100),M45Val,"",",",0) & "/" & lastdaycnt & "=" & (lastamount * odays*(overdueprc/100)/lastdaycnt);
          end;
        end;
      end;
    end;
  end;

  lateamount = lateamount + latefee;

  return;
end;

function Date GetInvoiceEndPeriod(Longint ivnr)
begin
  record IVVc IVr;
  Date res;

  IVr.SerNr = ivnr;
  if (ReadFirstMain(IVr,1,true)) then begin
    res = IVr.CredToDate;
  end;

  if (blank(res)) then begin
    res = IVr.InvDate;
  end;
  
  GetInvoiceEndPeriod = res;
  return;
end;

function Date GetLastOverdueInvoiceDate(Longint sernr,string item)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  Date res,td;

  TrHs = true;
  CredHistr.ArtCode = item;
  CredHistr.CredManNr = sernr;
  while (LoopKey("ArtCode",CredHistr,2,TrHs)) begin
    if (CredHistr.ArtCode!=item or CredHistr.CredManNr!=sernr) then begin
      TrHs = false;
    end else begin
      td = GetInvoiceEndPeriod(CredHistr.RecordNr);
      if (td>res) then begin
        res = td;
      end;
    end;
  end;

  GetLastOverdueInvoiceDate = res;
  return;
end;

global
function Integer GetRateType(record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  record CMInvoicingBLock CIb;
  Integer res;

  res = -1;
  
  if (CredManr.OverdueRateType>0) then begin
    res = CredManr.OverdueRateType - 1;
  end else begin
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      if (CMTr.OverdueRateType>0) then begin
        res = CMTr.OverdueRateType - 1;
      end;
    end;
  end;
  if (res==-1) then begin
    BlockLoad(CIb);
    res = CIb.OverdueRateType;
  end;

  GetRateType = res;
  return;
end;

global
procedure GetCredManOverdueInvoices(record CredManVc CredManr,record CredManSetBlock CMb,Date invdate,Date prevtd,var Integer latedays,var val lateamount,var array string lateformula,Boolean paidf,Boolean ignorelastoverduef)
begin
  record CMInvoicingBlock CIb;
  record INVc INr;
  Date overduetd,temp_td;
  record CUVc CUr;
  Integer ratetype;

  ClearStringArray(lateformula);
  latedays = 0;
  lateamount = 0;
  CUr.Code = CredManr.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin
    if (CUr.InterestFlag==1) then begin
      BlockLoad(CIb);
      temp_td = prevtd;
      if (!paidf) then begin
        temp_td = AddDay(temp_td,1);
      end;

      if (ignorelastoverduef==false) then begin
        overduetd = GetLastOverdueInvoiceDate(CredManr.SerNr,CMb.LateFeeItem);
      end;
      //we should go through the history and check for late payments
      if (nonblank(CIb.OverdueItemClass)) then begin
        ratetype = GetRateType(CredManr);
        while (LoopKey("DICode:" & CIb.OverdueItemClass,INr,1,true)) begin
          CheckOverdueInvoicesForItem(CredManr,CMb,CIb.OverdueMonths,invdate,prevtd,latedays,lateamount,INr.Code,overduetd,lateformula,ratetype);
        end;
      end;
    end;
  end;
  return;
end;

procedure MergeItemsInInvoice(var record IVVc IVr,record CredManVc CredManr)
begin
  Integer i,rwcnt,chargetype;
  row IVVc IVrw;
  vector val vRows;
  array string 255 arr;
  val quant,reb;
  Longint pos,factinv;
  string 255 index,tstr,item;

  
  rwcnt = MatRowCnt(IVr);
  for (i=rwcnt-1;i>=0;i=i-1) begin
    MatRowGet(IVr,i,IVrw);
    if (nonblank(IVrw.ArtCode)) then begin
      index = IVrw.ArtCode & ":" & IVrw.Quant & ":" & IVrw.vRebate & ":" & IVrw.ChargeType & ":" & IVrw.FactoringInvoice;
      vRows[index] = vRows[index] + IVrw.Price;
      MatRowDelete(IVr,i);
    end;
  end;
  GetVectorTags(vRows,arr);
  for (i=0;i<arr.length;i=i+1) begin
    pos = -1;
    GetNextSubstring(arr[i],pos,":",item);
    GetNextSubstring(arr[i],pos,":",tstr);
    quant = StringToVal(tstr,M4Val);
    GetNextSubstring(arr[i],pos,":",tstr);
    reb = StringToVal(tstr,M4Val);
    GetNextSubstring(arr[i],pos,":",tstr);
    chargetype = StringToInt(tstr);
    GetNextSubstring(arr[i],pos,":",tstr);
    factinv = StringToLongint(tstr);
    SetupInvoiceRowAndAdd(CredManr,IVr,item,"",quant,vRows[arr[i]],reb,chargetype,factinv);
  end;

  return;
end;

function Boolean GetNextInvoicableDate(var Date td,var Date prevtd,Date ed,record CredManVc CredManr)
begin
  Boolean res;
  
  prevtd = td;
  td = AddMonth(td,1);
  td.Day = DaysInMonth(td.Year,td.Month);
  if (td<=ed and td<=CredManr.endDate) begin //deal with all the other invoices
    res = true;
  end;

  GetNextInvoicableDate = res;
  return;
end;

function Boolean PMCodeMatches(record CredManVc CredManr,Longint cupnr)
begin
  Boolean res;
  record IPVc IPr;
  record ARPayHistVc ARPayHistr;

  ARPayHistr.CUPNr = cupnr;
  ARPayHistr.FileName = "IPVc";
  if (ReadFirstKey("MainKey",ARPayHistr,2,true)) then begin
    IPr.SerNr = ARPayHistr.SerNr;
    if (ReadFirstMain(IPr,1,true)) then begin
      if (CredManPMCodeMatches2(IPr.PayMode,CredManr,true)) then begin
        res = true;
      end;
    end else begin
      res = true;
    end;
  end else begin
    res = true;
  end;

  PMCodeMatches = res;
  return;
end;

global
procedure CM_AddPrepayments(var record IVVc IVr,record CredManVc CredManr,record CMInvoicingBlock CIb)
begin
  record ARPayVc ARPayr;
  val remval;
  Boolean TrHs;
  row IVVc IVrw;
  record IVVc IV2r;
  string 255 warning;
  Boolean chsum;
  
  if (CIb.AddPrepayments) then begin
    remval = IVr.Sum4;
    TrHs = true;
    ARPayr.CustCode = IVr.CustCode;
    while (LoopKey("CustCode",ARPayr,1,TrHs) and remval>0) begin
      if (ARPayr.CustCode!=IVr.CustCode) then begin
        TrHs = false;
      end else begin
        if (ARPayr.PayDate<=IVr.TransDate) then begin
          if (PMCodeMatches(CredManr,ARPayr.CUPNr)) then begin
            ClearRow(IVr,IVrw,kInvoiceRowTypePrepayment);
            IVrw.Spec = USetStr(1288);
            IVrw.CUPNr = ARPayr.CUPNr;
            PasteARPayInIV(IVr,IVrw,-1);
            MatRowInsert(IVr,0,IVrw);
            if IVVc_PasteSum(IVr,0,chsum,1) then begin 
              if (chsum) then begin
                IVDchsum(IVr,0);
              end;
            end;  
            remval = remval - IVrw.BasePrice;
          end;
        end;
      end;
    end;
  end;

  return;
end;

global
updating procedure StoreLoanInvoice(var record IVVc IVr,record CredManVc CredManr)
begin
  record IVVc oldIVr;
  
  if (IVr.Sum4>0) then begin
    IVr.SerNr = NextSerNr("IVVc",IVr.InvDate,-1,false,"");
    if (RecordInsert(IVr,true)) then begin
      RecordCopy(oldIVr,IVr);
      IVr.OKFlag = 1;
      LinkCredManAndInvoice(IVr,CredManr);
      if (RecordUpdate(oldIVr,IVr,true)==0) then begin
        CreateInvoicePdfFile(IVr);
      end;
    end;
  end;

  return;
end;

procedure CheckAndAddHiddenPrinciple(var record IVVc IVr,record CMInvoicingBlock CIb)
begin
  row IVVc IVrw,hiddenIVrw;
  Integer i,rwcnt;
  Boolean foundf;
  
  if (CIb.HiddenPrinciple==1) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.ChargeType>0 and IVrw.ChargeType!=kEventTypeCalcInstalment) then begin
        foundf = true;
        i = rwcnt;
      end;
    end;
    if (foundf) then begin
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        if (IVrw.ChargeType==kEventTypeCalcInstalment) then begin
          MatRowDelete(IVr,i);
          if (InvoiceHasHiddenLine(IVr)==false) then begin
            ClearRow(IVr,hiddenIVrw,kInvoiceRowTypeHidden);
            MatRowPut(IVr,MatRowCnt(IVr),hiddenIVrw);
          end;
          MatRowPut(IVr,MatRowCnt(IVr),IVrw);
          goto LCheckAndAddHiddenPrinciple;
        end;
      end;
    end;
  end;

LCheckAndAddHiddenPrinciple:;
  return;
end;

function val GetPaidAmountRatio(record CredManVc CredManr,Date td)
begin
  val res;
  record OPrsVc OPrsr;
  Boolean TrHs;
  val paid;
  
  res = 1;

  if (CredManr.VINr>0) then begin
    OPrsr.TransType = kOPrsTransTypePayment;
    OPrsr.TransDate = CredManr.startDate;
    OPrsr.VINr = CredManr.VINr;
    TrHs = true;
    while (LoopKey("VIKey",OPrsr,3,TrHs)) begin
      if (OPrsr.TransDate>td or OPrsr.VINr!=CredManr.VINr or OPrsr.TransType!=kOPrsTransTypePayment) then begin
        TrHs = false;
      end else begin
        paid = paid + FindInvoicePaidAmount_OP(OPrsr.VINr,OPrsr.TransNr);
      end;
    end;
    res = paid/CredManr.InvSum4;
    
  end;

  GetPaidAmountRatio = res;
  return;
end;

function Boolean CanInvoiceDate(record CredManVc CredManr,Integer invtype)
begin
  Boolean res;
  
  if (invtype==1 and CredManr.OKFlag==1) then begin
    res = true;
  end else begin
    if (invtype==0) then begin
      res = true;
    end;
  end;

  CanInvoiceDate = res;
  return;
end;  

updating procedure CreateInvoicesFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date ed,var record IVVc firstIVr,string ivno)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  Date lastd,lastd2;
  record IVVc IVr,oldIVr,oIVr;
  Boolean firstf;
  Integer latedays;
  val lateamount;
  record CMInvoicingBlock CIb;
  array string 255 lateformula;
  
  BlockLoad(CIb);
  lastd2 = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.PlanType<=4 and CredManPayPlanrw.TransDate<=ed and CanInvoiceDate(CredManr,CredManPayPlanrw.InvType)) then begin
      if (lastd!=CredManPayPlanrw.TransDate) then begin
        //Setup new invoice
        if (nonblank(lastd)) then begin
          //if (IVr.InvDate==CredManr.startDate) then begin
            MergeItemsInInvoice(IVr,CredManr);
          //end;
          GetCredManOverdueInvoices(CredManr,CMb,lastd,lastd2,latedays,lateamount,lateformula,false,false);
          switch (CIb.OverdueIVType) begin
            case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
            case 1: 
              SetupLoanInvoice(CredManr,CMb,oIVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno,2,true);
              SetupOverdueLangCode(IVr,CredManr.Type);
              AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
              StoreLoanInvoice(oIVr,CredManr);
          end;
          CM_AddPrepayments(IVr,CredManr,CIb);
          if (IVr.SerNr>-1) then begin
            CheckAndAddHiddenPrinciple(IVr,CIb);
            StoreLoanInvoice(IVr,CredManr);
            if (firstf==false) then begin
              RecordCopy(firstIVr,IVr);
              firstf = true;
            end;
          end else begin
            LogText(0,"Failed to store Invoice. No Serial Number. Check Number Series. Not continuing to generate invoices");  
            goto lout;    
          end;
        end;
        lastd2 = AddDay(lastd,1);//to get the start date for penalty calculation.
        lastd = CredManPayPlanrw.TransDate;
        SetupLoanInvoice(CredManr,CMb,IVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno,GetInvoiceType(CredManr,lastd),true);
        logtext(0,"ddd2 " & IVr.SerNr);

      end;
      if (CredManPayPlanrw.PlanType==kEventTypeCalcInterest) then begin
        if (CredManr.RealInterestFlag==1) then begin
          CredManPayPlanrw.Sum = CredManPayPlanrw.Sum*GetPaidAmountRatio(CredManr,IVr.InvDate);
        end;
      end;
      SetupInvoiceRowAndAdd(CredManr,IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);

    end;
    if (CredManPayPlanrw.TransDate>ed) then begin
      i = rwcnt;
    end;
  end;
  if (nonblank(lastd)) then begin
    MergeItemsInInvoice(IVr,CredManr);
    GetCredManOverdueInvoices(CredManr,CMb,lastd,lastd2,latedays,lateamount,lateformula,false,false);
    switch (CIb.OverdueIVType) begin
      case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
      case 1: 
        SetupLoanInvoice(CredManr,CMb,oIVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno,2,true);
        AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
        SetupOverdueLangCode(IVr,CredManr.Type);
        StoreLoanInvoice(oIVr,CredManr);
    end;
    CM_AddPrepayments(IVr,CredManr,CIb);
    if (IVr.SerNr>-1) then begin
      CheckAndAddHiddenPrinciple(IVr,CIb);
      StoreLoanInvoice(IVr,CredManr);
      if (firstf==false) then begin
        RecordCopy(firstIVr,IVr);
      end;
    end else begin
      LogText(0,"Failed to store Invoice. No Serial Number. Check Number Series");
    end;
  end;

lout:;
  return;
end;

global
procedure TestCredManInvoicesFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date ed,var array record IVVc aIVr)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  Date lastd,lastd2;
  record IVVc IVr;
  Boolean firstf;
  Integer latedays;
  val lateamount;
  array string 255 lateformula;
  
  lastd2 = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.PlanType<=4) then begin// and CredManPayPlanrw.TransDate<=ed
      if (lastd!=CredManPayPlanrw.TransDate) then begin
        //Setup new invoice
        if (nonblank(lastd)) then begin
          //if (IVr.InvDate==CredManr.startDate) then begin
          //  MergeItemsInInvoice(IVr);
          //end;
          //GetCredManOverdueInvoices(CredManr,CMb,lastd,lastd2,latedays,lateamount,lateformula,false,false);
          aIVr[aIVr.length] = IVr;
        end;
        lastd2 = AddDay(lastd,1);//to get the start date for penalty calculation.
        lastd = CredManPayPlanrw.TransDate;
        SetupLoanInvoice(CredManr,CMb,IVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,false,false,"",-1,false);

      end;
      //skip late fees here?? 
      if (CredManPayPlanrw.PlanType!=9) then begin
        SetupInvoiceRowAndAdd(CredManr,IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);
      end;

    end;
    if (CredManPayPlanrw.TransDate>ed) then begin
      i = rwcnt;
    end;
  end;
  if (nonblank(lastd)) then begin
    aIVr[aIVr.length] = IVr;
  end;

  return;
end;


procedure GetItemName(string code,var string spec)
begin
  record INVc INr;

  INr.Code = code;
  ReadFirstMain(INr,1,true);
  spec = INr.Name;

  return;
end;

procedure BuildInvoiceBasedOnSchedule(record CredManVc CredManr,row CredManSchedVc CSrw,record CredManSetBlock CMb,record CMApplicationSetBlock ASb,Date lastd,var record IVVc IVr,Boolean updf,Boolean addfeesf)
begin
  Integer latedays;
  val lateamount;
  string 255 spec;
  record CMInvoicingBlock CIb;
  record IVVc oIVr;
  array string 255 lateformula;
  record CredFeesMatrixVc FMr;
  row CredFeesMatrixVc FMrw;
  Integer i,rwcnt;

  BlockLoad(CIb);
  RecordClear(IVr);
  RecordNew(IVr);
  SetupLoanInvoice(CredManr,CMb,IVr,CSrw.InvDate,CSrw.FromDate,CSrw.ToDate,true,false,"",GetInvoiceType(CredManr,CSrw.InvDate),updf);
  if (CSrw.Principle>0) then begin
    GetItemName(CMb.RateItem,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CMb.InstalmentItem,spec,1,CSrw.Principle,blankval,kEventTypeCalcInstalment,-1);
  end;
  if (CSrw.Deposit>0) then begin
    GetItemName(CMb.DepositItem,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CMb.DepositItem,spec,1,CSrw.Deposit,blankval,kEventTypeCalcInstalment,-1);
  end;
  if (CSrw.Interest>0) then begin
    GetItemName(CMb.RateItem,spec);
    if (CredManr.RealInterestFlag==1) then begin
      CSrw.Interest = CSrw.Interest*GetPaidAmountRatio(CredManr,IVr.InvDate);
    end;

    SetupInvoiceRowAndAdd(CredManr,IVr,CMb.RateItem,spec,1,CSrw.Interest,blankval,kEventTypeCalcInterest,-1);
  end;
  if (CSrw.Fees>0) then begin
    UnpackRowFieldMatrix(CSrw,"FeesMatrix",FMr);
    rwcnt = MatRowCnt(FMr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(FMr,i,FMrw);
      GetItemName(FMrw.ArtCode,spec);
      SetupInvoiceRowAndAdd(CredManr,IVr,FMrw.ArtCode,spec,1,FMrw.Sum,blankval,kEventTypeCalcFees,-1);
    end;
  end;
  MergeItemsInInvoice(IVr,CredManr);
  if (addfeesf) then begin
    GetCredManOverdueInvoices(CredManr,CMb,CSrw.InvDate,lastd,latedays,lateamount,lateformula,false,false);
    switch (CIb.OverdueIVType) begin
      case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
      case 1: 
        SetupLoanInvoice(CredManr,CMb,oIVr,CSrw.InvDate,CSrw.FromDate,CSrw.ToDate,true,false,"",2,true);
        SetupOverdueLangCode(IVr,CredManr.Type);
        AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
        if (updf) then begin
          qupdating.StoreLoanInvoice(oIVr,CredManr);
        end;
    end;
  end;
  
  if (updf) then begin
    CM_AddPrepayments(IVr,CredManr,CIb);
  end;
  CheckAndAddHiddenPrinciple(IVr,CIb);

  return;
end;

function Integer InvoiceTypeFromSchedule(record CredManVc CredManr,row CredManSchedVc CSrw)
begin
  Integer res;

  res = 1;
  if (CredManr.FirstInvDate<CSrw.InvDate) then begin
    if (CSrw.Deposit==0 and CSrw.Interest==0 and CSrw.Principle==0 and CSrw.Fees!=0) then begin
      res = 0;
    end;
  end;

  InvoiceTypeFromSchedule = res;
  return;
end;

updating function Boolean CreateInvoiceBasedOnSchedule(record CredManVc CredManr,Date ed,var record IVVc firstIVr)
begin
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt,rw;
  record IVVc IVr,oldIVr;
  record CredManSetBlock CMb;
  record CMApplicationSetBlock ASb;
  record CMInvoicingBlock CIb;
  Date lastd;
  Boolean firstf;
  Boolean res;
  record CredManTypeVc CMTr;

  Date ted,sd,invdat2;
  Integer latedays;
  val lateamount;
  Boolean addf;
  array string 255 lateformula;
  
  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    res = true;
    BlockLoad(CMb);
    BlockLoad(ASb);
    BlockLoad(CIb);
    lastd = CredManr.FirstInvDate;
    rwcnt = MatRowCnt(CSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CSr,i,CSrw);
      if (CSrw.InvDate<=ed and CSrw.Invoiced==0 and CanInvoiceDate(CredManr,InvoiceTypeFromSchedule(CredManr,CSrw))) then begin
        BuildInvoiceBasedOnSchedule(CredManr,CSrw,CMb,ASb,lastd,IVr,true,true);
        if (IVr.SerNr>-1) then begin
          StoreLoanInvoice(IVr,CredManr);

          if (firstf==false) then begin
            RecordCopy(firstIVr,IVr);
            firstf = true;
          end;
        end;
      end else begin
        if (CSrw.InvDate>ed) then begin
          i = rwcnt;
        end;
      end;
      lastd = AddDay(CSrw.InvDate,1);
    end;
    if (CIb.OverdueIVType==2 and GetDay(CurrentDate)==CIb.OverdueIVDay) then begin
      ted = CurrentDate;
      ted.Day = 1;
      sd = AddMonth(ted,-1);
      ted = AddDay(ted,-1);
      invdat2 = CurrentDate;
      GetCredManOverdueInvoices(CredManr,CMb,ted,sd,latedays,lateamount,lateformula,false,false);
      addf = true;
      CMTr.Code = CredManr.Type;
      if (ReadFirstMain(CMTr,1,true)) then begin
        if (CMTr.MinOverdueFee>0 and lateamount<CMTr.MinOverdueFee) then begin
          addf = false;
        end;
      end;
      if (addf) then begin
        SetupLoanInvoice(CredManr,CMb,IVr,invdat2,sd,ted,true,false,"",2,true);
        SetupOverdueLangCode(IVr,CredManr.Type);
        AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
        StoreLoanInvoice(IVr,CredManr);
        if (firstf==false) then begin
          RecordCopy(firstIVr,IVr);
          firstf = true;
        end;
      end;
    end;
  end;
  CreateInvoiceBasedOnSchedule = res;
  return;
end;

global
procedure TestInvoiceBasedOnSchedule(record CredManVc CredManr,record CredManSchedVc CSr,Date ed,var array record IVVc aIVr)
begin
  row CredManSchedVc CSrw;
  Integer i,rwcnt,rw;
  record IVVc IVr,oldIVr;
  record CredManSetBlock CMb;
  record CMApplicationSetBlock ASb;
  Date lastd;
  Boolean firstf;
  Boolean res;
  
  BlockLoad(CMb);
  BlockLoad(ASb);
  lastd = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CSr,i,CSrw);
    if (CSrw.InvDate<=ed and CSrw.Invoiced==0) then begin
      BuildInvoiceBasedOnSchedule(CredManr,CSrw,CMb,ASb,lastd,IVr,false,false);
      aIVr[aIVr.length] = IVr;
    end else begin
      if (CSrw.InvDate>ed) then begin
        i = rwcnt;
      end;
    end;
    lastd = AddDay(CSrw.InvDate,1);
  end;

  return;
end;

global
procedure TestInvoiceBasedOnScheduleRow(record CredManSchedVc CSr,row CredManSchedVc CSrw,var record IVVc IVr)
begin
  record CredManSetBlock CMb;
  record CMApplicationSetBlock ASb;
  Date lastd;
  Boolean firstf;
  Boolean res;
  record CredManVc CredManr;
  transaction Boolean gSilenceIVOpenPrepExists;
  
  BlockLoad(CMb);
  BlockLoad(ASb);
  CredManr.SerNr = CSr.CredManNr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    gSilenceIVOpenPrepExists = true;
    BuildInvoiceBasedOnSchedule(CredManr,CSrw,CMb,ASb,"",IVr,false,false);
    gSilenceIVOpenPrepExists = false;
  end;

  return;
end;


global
updating procedure CreateSingleAgreementInvoice(record CredManVc CredManr,Date ed,var record IVVc IVr,string ivno)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  string 255 oldlang;

  //if (CredManr.OKFlag==1 and CredManr.Approved==1) then begin
  if (CanCreateSingleAgreementInvoice(CredManr,ed)) then begin
    oldlang = CM_SetCompanyLanguage;
    if (CreateInvoiceBasedOnSchedule(CredManr,ed,IVr)==false) then begin
      BlockLoad(CMb);
      BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
      CreateInvoicesFromPlan(CredManr,CMb,CredManPayPlanr,ed,IVr,ivno);
    end;
    CM_ResetCompanyLanguage(oldlang);
  end;

  return;
end;

function val GetBuyOutFee(record CredManVc CredManr,Date td)
begin
  val res;
  val rate;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt,cnt;
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record SMVc SMr;
  row SMVc SMrw;

  rate = CredManr.BuyoutFeePrc;
  res = (CredManr.InvSum4 - CredManr.DepositSum) *(rate/100);
  res = res + CredManr.BuyoutFeeFixed;

  if (CredManr.BuyoutFeeMonths>0) then begin
    CSr.CredManNr = CredManr.SerNr;
    if (ReadFirstMain(CSr,1,true)) then begin
      rwcnt = MatRowCnt(CSr);
      cnt = CredManr.BuyoutFeeMonths;
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CSr,i,CSrw);
        if (CSrw.InvDate>td and cnt>0) then begin
          res = res + CSrw.Interest;
          cnt = cnt - 1;
        end;
        if (cnt<=0) then begin
          i = rwcnt;
        end;
      end;

    end else begin
      BlockLoad(CMb);
      BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
      BuildCredManInfoMatrix(CredManr,CredManPayPlanr,CMb,SMr);
      rwcnt = MatRowCnt(SMr);
      cnt = CredManr.BuyoutFeeMonths;
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(SMr,i,SMrw);
        if (SMrw.TransDate>td and cnt>0) then begin
          res = res + SMrw.CredVal;
          cnt = cnt - 1;
        end;
        if (cnt<=0) then begin
          i = rwcnt;
        end;
      end;
    end;
  end;

  GetBuyOutFee = res;
  return;
end;

procedure AddBuyOutFee(record CredManVc CredManr,var record IVVc IVr)
begin
  record CMInvoicingBlock CIb;
  string 255 spec;
  val buyoutfee;
  
  BlockLoad(CIb);
  buyoutfee = GetBuyOutFee(CredManr,IVr.InvDate);
  GetItemName(CIb.BuyOutItem,spec);
  if (nonblank(CIb.BuyOutItem) and buyoutfee>0) then begin
    SetupInvoiceRowAndAdd(CredManr,IVr,CIb.BuyOutItem,spec,1,buyoutfee,blankval,15,-1);
  end;

  return;
end;

global
procedure CreateBuyOutInvoiceFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date td,var record IVVc IVr)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  record CredManPayPlanVc CredManPayPlan2r;
  val balance;
  Date lastinv;
  Integer latedays;
  val lateamount;
  val cumint,calcbal;
  record CredHistVc CredHistr;
  array string 255 lateformula;
  record CredManVc tCredManr;
  Boolean foundf;

/*
1. Get the last invoice date and the balance
2. Set up and create an invoice
*/ 
  lastinv = CredManr.startDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.PlanType<=4) then begin
      i = rwcnt;
    end else begin
      CredHistr.SerNr = CredManPayPlanrw.IssuedNr;
      if (ReadFirstMain(CredHistr,1,true)) then begin
        if (CredManPayPlanrw.ArtCode!=CMb.LateFeeItem and CredManPayPlanrw.ArtCode!=CMb.LateRateItem and (CredHistr.RecordType==0 or CredHistr.RecordType==4)) then begin
          if (CredManPayPlanrw.Bal<balance or balance==0) then begin
            balance = CredManPayPlanrw.Bal;
            foundf = true;
          end;
          if (CredHistr.RecordType==0 and CredManPayPlanrw.TransDate>lastinv) then begin
            lastinv = AddDay(CredManPayPlanrw.TransDate,1);
          end;
        end;
      end;
    end;
  end;
  if (!foundf) then begin
    balance = CredManr.InvSum4;
  end;
  
  if (balance>0) then begin
    SetupLoanInvoice(CredManr,CMb,IVr,td,lastinv,td,true,false,"",1,true);
    AddInstalmentFixed(CredManr,CredManPayPlan2r,CMb,balance,td,cumint,calcbal,lastinv,td);
    RecordCopy(tCredManr,CredManr);
    tCredManr.InvSum4 = balance;
    tCredManr.DepositSum = 0;
    AddInterest(tCredManr,CredManPayPlan2r,CMb,kMonthTypeFirst,td,cumint,balance,lastinv,td,-1,true);
    AddPlannedFees(CredManr,CredManPayPlan2r,CMb,kPlannedFeesMonthly,kMonthTypeFirst,td,cumint,balance,lastinv,td,-1,false);
    rwcnt = MatRowCnt(CredManPayPlan2r);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CredManPayPlan2r,i,CredManPayPlanrw);
      SetupInvoiceRowAndAdd(CredManr,IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);
    end;
    AddBuyOutFee(CredManr,IVr);
    GetCredManOverdueInvoices(CredManr,CMb,td,AddDay(lastinv,1),latedays,lateamount,lateformula,false,false);
    AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
  end;

  return;
end;


global
procedure CreateBuyOutInvoiceFromSchedule(record CredManVc CredManr,record CredManSetBlock CMb,record CredManSchedVc CSr,Date td,var record IVVc IVr)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  record CredManPayPlanVc CredManPayPlan2r;
  row CredManSchedVc CSrw;
  val balance;
  Date lastinv;
  Integer latedays;
  val lateamount;
  val cumint,calcbal;
  record CredHistVc CredHistr;
  array string 255 lateformula;
  record CredManVc tCredManr;

/*
1. Get the last invoice date and the balance
2. Set up and create an invoice
*/ 
  lastinv = CredManr.startDate;
  balance = CredManr.InvSum4;
  rwcnt = MatRowCnt(CSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CSr,i,CSrw);
    if (CSrw.Invoiced==0) then begin
      i = rwcnt;
    end else begin
      if (CSrw.Type==4) then begin
        balance = balance - CSrw.Total;
      end else begin
        balance = balance - CSrw.Principle - CSrw.Deposit;
        lastinv = AddDay(CSrw.InvDate,1);
      end;
    end;
  end;
  
  if (balance>0) then begin
    SetupLoanInvoice(CredManr,CMb,IVr,td,lastinv,td,true,false,"",1,true);
    AddInstalmentFixed(CredManr,CredManPayPlan2r,CMb,balance,td,cumint,calcbal,lastinv,td);
    RecordCopy(tCredManr,CredManr);
    tCredManr.InvSum4 = balance;
    tCredManr.DepositSum = 0;
    AddInterest(tCredManr,CredManPayPlan2r,CMb,kMonthTypeFirst,td,cumint,balance,lastinv,td,-1,true);
    AddPlannedFees(CredManr,CredManPayPlan2r,CMb,kPlannedFeesMonthly,kMonthTypeFirst,td,cumint,balance,lastinv,td,-1,false);
    rwcnt = MatRowCnt(CredManPayPlan2r);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CredManPayPlan2r,i,CredManPayPlanrw);
      SetupInvoiceRowAndAdd(CredManr,IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);
    end;
    AddBuyOutFee(CredManr,IVr);
    GetCredManOverdueInvoices(CredManr,CMb,td,AddDay(lastinv,1),latedays,lateamount,lateformula,false,false);
    AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
  end;

  return;
end;

global
updating procedure CreateProlongInvoice(record CredManVc CredManr,var record IVVc nIVr)
begin
  record CMInvoicingBlock CIb;
  record CredManSetBlock CMb;
  record IVVc IVr,oldIVr;
  val rate,sum;
  string 255 spec;

  BlockLoad(CIb);
  BlockLoad(CMb);

  SetupLoanInvoice(CredManr,CMb,IVr,CurrentDate,"","",true,false,"",1,true);
  rate = CredManr.StdProlongPrc;
  if (CredManr.AnnualRate==1) then begin
    rate = rate/12;
  end;
  sum = (CredManr.InvSum4 - CredManr.DepositSum) *(rate/100);
  sum = sum + CredManr.StdProlongFee;
  GetItemName(CIb.ProlongItem,spec);
  SetupInvoiceRowAndAdd(CredManr,IVr,CIb.ProlongItem,spec,1,sum,blankval,14,-1);
  CM_AddPrepayments(IVr,CredManr,CIb);

  StoreLoanInvoice(IVr,CredManr);
  if (IVr.SerNr>0) then begin
    RecordCopy(nIVr,IVr);
  end;

  return;
end;


global
updating procedure CreateManualExtraInvoice(record RcVc RepSpec,var record IVVc IVr)
begin
  record CMInvoicingBlock CIb;
  record CredManSetBlock CMb;
  record IVVc oldIVr;
  val rate,sum;
  string 255 spec;
  record CredManVc CredManr;

  CredManr.SerNr = RepSpec.long1;
  if (ReadFirstMain(CredManr,1,true)) then begin
    BlockLoad(CIb);
    BlockLoad(CMb);

    SetupLoanInvoice(CredManr,CMb,IVr,RepSpec.d1,"","",true,false,"",1,true);
    GetItemName(RepSpec.f1,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,RepSpec.f1,spec,1,RepSpec.vals0,blankval,15,-1);
    CM_AddPrepayments(IVr,CredManr,CIb);

    StoreLoanInvoice(IVr,CredManr);
  end;

  return;
end;

global
updating procedure DoBuyOutAgreement(record CredManVc CredManr,var record IVVc firstIVr)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record IVVc IVr,oldIVr;
  record CMInvoicingBlock CIb;

  if (CredManr.OKFlag==1 and CredManr.Approved==1) then begin
    BlockLoad(CMb);
    BlockLoad(CIb);
    BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
    CreateBuyOutInvoiceFromPlan(CredManr,CMb,CredManPayPlanr,CurrentDate,IVr);
    CM_AddPrepayments(IVr,CredManr,CIb);
    if (IVr.SerNr>-1) then begin
      if (IVr.Sum4>0) then begin
        if (RecordInsert(IVr,true)) then begin
          RecordCopy(oldIVr,IVr);
          IVr.OKFlag = 1;
          RecordUpdate(oldIVr,IVr,true);
          LinkCredManAndInvoice(IVr,CredManr);
          GenerateAgreementSchedule(CredManr,true);
        end;
        RecordCopy(firstIVr,IVr);
      end else begin
        LogText(0,"Failed to store Invoice. Sum is 0");
      end;
    end else begin
      LogText(0,"Failed to store Invoice. No Serial Number. Check Number Series");
    end;
  end;

  return;
end;

procedure CheckUnpaidInvoices(record CredManVc CredManr,var val dueamount,var val openamount)
begin
  record ARVc ARr;
  record IVVc IVr;
  Boolean TrHs;

  dueamount = 0;
  openamount = 0;
  //didn't add a new index in order to save db size. This won't be so expensive.
  
  TrHs = true;
  IVr.CustCode = CredManr.CustCode;
  while (LoopKey("CustCode",IVr,1,TrHs)) begin
    if (IVr.CustCode!=CredManr.CustCode) then begin
      TrHs = false;
    end else begin
      if (IVr.CustCredManNr==CredManr.SerNr) then begin
        ARr.InvoiceNr = IVr.SerNr;
        if (ReadFirstMain(ARr,1,true)) then begin
          if (ARr.DueDate<CurrentDate) then begin
            dueamount = dueamount + ARr.RVal;
          end;
          openamount = openamount + ARr.RVal;
        end;
      end;
    end;
  end;

  return;
end;

function val GetActualBalance(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,Boolean openf)
begin
  val res;
	row CredManPayPlanVc CredManPayrw;
	Integer rwcnt,i;
  val openamount;

	res = CredManr.InvSum4;
	rwcnt = MatRowCnt(CredManPayPlanr);
	for (i=0;i<rwcnt;i=i+1) begin
		MatRowGet(CredManPayPlanr,i,CredManPayrw);
    if (CredManPayrw.PlanType>=5) then begin
      if (res>CredManPayrw.Bal) then begin
        res = CredManPayrw.Bal;
      end;
      if (CredManPayrw.PlanType==kEventTypeIssueInstalment) then begin
        openamount = openamount + CredManPayrw.OpenAmount;
      end;
    end;
    if (CredManPayrw.PlanType<5) then begin
      i = rwcnt;
    end;
    /*
    if (CredManPayrw.TransDate>=CurrentDate) then begin
      i = rwcnt;
    end;
    */
	end;

  if (openf) then begin
    res = res + openamount;
  end;

	GetActualBalance = res;
	return;
end;

function val GetPrepaymentValue(record CredManVc CredManr)
begin
  record ARPayVc ARPayr;
  Boolean TrHs;
  val res;

  ARPayr.CustCode = CredManr.CustCode;
  TrHs = true;
  while (LoopKey("CustCode",ARPayr,1,TrHs)) begin
    if (ARPayr.CustCode!=CredManr.CustCode) then begin
      TrHs = false;
    end else begin
      if (PMCodeMatches(CredManr,ARPayr.CUPNr)) then begin
        res = res + ARPayr.RVal;
      end;
    end;
  end;

  GetPrepaymentValue = res;
  return;
end;

function val GetActualBalanceSched(record CredManVc CredManr,record CredManSchedVc CSr)
begin
  val bal;
  Integer i,rwcnt;
  row CredManSchedVc CSrw;
  
  bal = CredManr.InvSum4;
  rwcnt = MatRowCnt(CSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CSr,i,CSrw);
    if (CSrw.Invoiced==1) then begin
      if (CSrw.Type==4) then begin
        bal = bal - CSrw.Total;
      end else begin
        bal = bal - CSrw.Principle - CSrw.Deposit;
      end;
    end else begin
      i = rwcnt;
    end;
  end;

  GetActualBalanceSched = bal;
  return;
end;

global
procedure CheckBuyOutAgreement(record CredManVc CredManr,var record RcVc RepSpec)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record CredManSchedVc CSr;
  record IVVc IVr;
  val dueamount,openamount,lateamount,prepayval,buyoutfee;
  Integer latedays;
  Date sd;
  transaction Boolean gSilenceIVOpenPrepExists;
  array string 255 lateformula;
  Boolean schedf;
logtext(0,"CheckBuyOutAgreement start");
  gSilenceIVOpenPrepExists = true;
  BlockLoad(CMb);
/* why should be base this on schedule. we should always take "actual" data
  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    CreateBuyOutInvoiceFromSchedule(CredManr,CMb,CSr,RepSpec.d1,IVr);
    schedf = true;
  end else begin
*/
    BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,false);
    CreateBuyOutInvoiceFromPlan(CredManr,CMb,CredManPayPlanr,RepSpec.d1,IVr);
//  end;
  CheckUnpaidInvoices(CredManr,dueamount,openamount);
  sd = GetLastInvoiceDate(CredManr,RepSpec.d1);
  GetCredManOverdueInvoices(CredManr,CMb,RepSpec.d1,sd,latedays,lateamount,lateformula,false,false);

  prepayval = GetPrepaymentValue(CredManr);
  buyoutfee = GetBuyOutFee(CredManr,RepSpec.d1);
  RepSpec.vals1 = IVr.Sum4;
  RepSpec.vals0 = dueamount;//should this be openamount?
  RepSpec.vals2 = openamount + IVr.Sum4 - prepayval;
  RepSpec.f14 = buyoutfee;
  if (prepayval>0 and RepSpec.vals2<0) then begin
    RepSpec.vals2 = 0;
  end;
  RepSpec.vals4 = dueamount;
  RepSpec.f12 = lateamount;//(RepSpec.vals2-RepSpec.vals3-RepSpec.vals4);
  
  //BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,false);
  
  RepSpec.vals3 = GetActualBalance(CredManr,CredManPayPlanr,false);
  RepSpec.f13 = GetActualBalance(CredManr,CredManPayPlanr,true);
  gSilenceIVOpenPrepExists = false;

logtext(0,"CheckBuyOutAgreement end");

  return;
end;

global
procedure CheckBuyOutAgreementAsync(record CredManVc CredManr,Date td,Integer wn)
begin
  record RcVc RepSpec;

  RepSpec.d1 = CurrentDate;
  CheckBuyOutAgreement(CredManr,RepSpec);
  clientremoteasync.CheckBuyOutAgreementCallBack(RepSpec,wn);

  return;
end;


//very sad that I have to map these now. Adding each new type needs an exception now
function Integer MapChargeTypes(Integer type)
begin
  Integer res;
  
  switch (type) begin
    case 9:  res = type;
    case 10: res = type;
    case 11: res = type;
    case 14: res = type;//prolong fee
    case 15: res = type;//extra fee
    otherwise
      res = type + 4;
  end;

  MapChargeTypes = res;
  return;
end;

global
updating procedure CreateCredHist(Longint recnr,Integer chargetype,string custcode,val sum,Integer rectype,string item,Date duedate,Longint agreementnr,Date invdate,var Longint histnr,Date perfrom,Date perto,Integer mainf,Longint previousnr,val invsum,Longint factinv,val paidval)
begin
  record CredHistVc CredHistr;
  
  histnr = -1;

  RecordNew(CredHistr);
  CredHistr.SerNr = NextSerNr("CredHistVc",CurrentDate,-1,false,"");
  CredHistr.TransDate = invdate;
  CredHistr.RecordNr = recnr;
  CredHistr.ChargeType = MapChargeTypes(chargetype);//from calc type to issued type
  CredHistr.CustCode = custcode;
  CredHistr.RecordType = rectype;
  CredHistr.ArtCode = item;
  CredHistr.PayDate = duedate;
  CredHistr.CredManNr = agreementnr;
  CredHistr.CredFromDate = perfrom;
  CredHistr.CredToDate = perto;
  CredHistr.MainRecord = mainf;
  CredHistr.PreviousNr = previousnr;
  CredHistr.InvSum = invsum;
  CredHistr.FactoringInvoice = factinv;
  if (nonblank(CredHistr.CredFromDate)) then begin
    CredHistr.Comment2 = CredHistr.CredFromDate & ":" & CredHistr.CredToDate;
  end;
  if (paidval>0) then begin
    CredHistr.PaidSum = paidval;
    if (CredHistr.PaidSum==CredHistr.InvSum) then begin
      CredHistr.PaidFlag = 1;
    end;
  end;

  CredHistr.Sum = sum;
  if (RecordInsert(CredHistr,true)) then begin
    histnr = CredHistr.SerNr;
  end;

  return;
end;

updating procedure RemoveCredHist(Longint recnr,Integer rectype)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  
  TrHs = true;
  CredHistr.RecordNr = recnr;
  CredHistr.RecordType = rectype;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordType!=rectype or CredHistr.RecordNr!=recnr) then begin
      TrHs = false;
    end else begin
      RecordRemove(CredHistr);
      StepBack(CredHistr);
    end;
  end;

  return;
end;

function val CalculateRowSumWithVAT(record IVVc IVr,row IVVc IVrw)
begin
  val res;
  val vatprc,vatval,vatexclprc,vatinclprc,rowtax;

//first version is just row sum. We should include VAT to match with payments
  res = IVrw.Sum;
  InvVat(1,IVr.InclVAT,IVr.NoTAXonVAT,IVr.ExportFlag,IVrw.VATCode,IVrw.Sum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);

  if (IVr.InclVAT==0) then begin
    res = res + vatval;
  end;



  CalculateRowSumWithVAT = res;
  return;
end;

updating procedure UpdateCredHistBalance(Longint credmannr,Longint invnr)
begin
  record ORVc ORr;
  Integer i,rwcnt;
  record CredHistVc CredHistr,oldCredHistr;
  row ORVc ORrw;
  Boolean TrHs;
  val bal;
  
  GetCredManEventList2(credmannr,ORr);
  rwcnt = MatRowCnt(ORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORr,i,ORrw);
    if (ORrw.GroupOrdRow==invnr) then begin
      bal = ORrw.rowGP;
      i = rwcnt;
    end;
  end;
  TrHs = true;
  CredHistr.RecordNr = invnr;
  CredHistr.RecordType = 0;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordNr!=invnr or CredHistr.RecordType!=0) then begin
      TrHs = false;
    end else begin
      RecordCopy(oldCredHistr,CredHistr);
      CredHistr.Balance = bal;
      RecordUpdate(oldCredHistr,CredHistr,true);
    end;
  end;

  return;
end;

global
updating procedure UpdateCredHistBalancePartialBuyout(Longint credmannr,Longint credhistnr)
begin
  record ORVc ORr;
  Integer i,rwcnt;
  record CredHistVc CredHistr,oldCredHistr;
  row ORVc ORrw;
  Boolean TrHs;
  val bal;
  
  GetCredManEventList2(credmannr,ORr);
  rwcnt = MatRowCnt(ORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORr,i,ORrw);
    if (ORrw.CUServiceHistNr==credhistnr) then begin
      bal = ORrw.rowGP;
      i = rwcnt;
    end;
  end;
  TrHs = true;
  CredHistr.SerNr = credhistnr;
  if (ReadFirstMain(CredHistr,1,true)) begin
    RecordCopy(oldCredHistr,CredHistr);
    CredHistr.Balance = bal;
    RecordUpdate(oldCredHistr,CredHistr,true);
  end;

  return;
end;

updating procedure MakeFakeReceiptHist(record IVVc IVr,row IVVc IVrw)
begin
  Boolean TrHs;
  row IPVc IPrw;
  array val arrCredManr;
  record IPVc IPr;

  IPr.SerNr = IVr.SerNr;
  IPr.TransDate = IVr.InvDate;
  ClearRow(IPr,IPrw,1);
  IPrw.InvoiceNr = IVr.SerNr;
  IPrw.RecVal = IVrw.BasePrice;
  arrCredManr[IVr.CustCredManNr] = IVrw.BasePrice;
  MatRowPut(IPr,0,IPrw);
  FindUnpaidCredHist(IPr,IPrw,arrCredManr,2);

  return;
end;

function Boolean FindMatchingRow(record IVVc credIVr,Longint histnr,var row IVVc tIVrw)
begin
  Integer i,rwcnt;
  row IVVc IVrw;
  Boolean res;
  
  rwcnt = MatRowCnt(credIVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(credIVr,i,IVrw);
    if (IVrw.CredHistNr==histnr) then begin
      res = true;
      MatRowGet(credIVr,i,tIVrw);
      i = rwcnt;
    end;
  end;

  FindMatchingRow = res;
  return;
end;

global
updating procedure UpdateCredHistInvoice(var record IVVc IVr,record IVVc IV2r)
begin
  row IVVc IVrw,tIVrw,prepIVrw;
  Integer i,rwcnt;
  Boolean prepayf;
  Longint histnr;
  Integer firstf;
  record IVVc credIVr;

  firstf = 1;
  if (IVr.InvType==kInvoiceTypeCredit) then begin
    //Currently remove only whole invoice. it's too much work now for checking each row separately
    if (IVr.OKFlag==1 and IV2r.OKFlag!=1) then begin
      if (IVr.CredInv>0) then begin
        credIVr.SerNr = IVr.CredInv;
        if (ReadFirstMain(credIVr,1,true)) then begin
          //RemoveCredHist(IVr.CredInv,kCredHistRecTypeInvoice);
          rwcnt = MatRowCnt(IVr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(IVr,i,IVrw);
            if (IVrw.ChargeType>0) then begin
              if (FindMatchingRow(credIVr,IVrw.CredHistNr,tIVrw)) then begin
                CreateCredHist(IVr.SerNr,10,IVr.CustCode,tIVrw.Sum,3,"",IVr.TransDate,IVr.CustCredManNr,IVr.TransDate,histnr,"","",0,tIVrw.CredHistNr,IVrw.Sum,-1,0);

                IVrw.CredHistNr = histnr;
                MatRowPut(IVr,i,IVrw);
                firstf = 0;
              end;
            end;
          end;
        end;
      end;
    end;
  end else begin
    if (IVr.OKFlag==0 and IV2r.OKFlag!=0) then begin
      RemoveCredHist(IVr.SerNr,kCredHistRecTypeInvoice);
      RemoveCredHist(IVr.SerNr,kCredHistRecTypePrepayment);
    end;
    
    if (IVr.OKFlag==1 and IV2r.OKFlag!=1) then begin
      rwcnt = MatRowCnt(IVr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        if (IVrw.ChargeType>0) then begin
          CreateCredHist(IVr.SerNr,IVrw.ChargeType,IVr.CustCode,CalculateRowSumWithVAT(IVr,IVrw),kCredHistRecTypeInvoice,IVrw.ArtCode,IVr.PayDate,IVr.CustCredManNr,IVr.InvDate,histnr,IVr.CredFromDate,IVr.CredToDate,firstf,-1,IVr.Sum4,IVrw.FactoringInvoice,0);
          IVrw.CredHistNr = histnr;
          MatRowPut(IVr,i,IVrw);
          firstf = 0;
        end;
        if (IVrw.stp==kInvoiceRowTypePrepayment) then begin
          if (IVrw.BasePrice>0) then begin
            MatRowGet(IVr,i,prepIVrw);
            prepayf = true;
          end;
        end;
      end;
      if (prepayf) then begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          if (IVrw.stp==kInvoiceRowTypePrepayment and IVrw.BasePrice>0) then begin
            MakeFakeReceiptHist(IVr,IVrw);
          end;
        end;
      end;
    end;
  end;

  UpdateCredHistBalance(IVr.CustCredManNr,IVr.SerNr);

  return;
end;

global
updating procedure UpdateCredManScheduleFromInvoice(record IVVc IVr,Boolean setf)
begin
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw;
  Integer rwcnt,i;

  if (IVr.CustCredManNr>0) then begin
    CSr.CredManNr = IVr.CustCredManNr;
    if (ReadFirstMain(CSr,1,true)) then begin
      RecordCopy(oldCSr,CSr);
      rwcnt = MatRowCnt(CSr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CSr,i,CSrw);
        if (CSrw.InvDate==IVr.InvDate) then begin
          if (setf) then begin
            CSrw.Invoiced = 1;
            CSrw.InvoiceNr = IVr.SerNr;
          end else begin
            CSrw.Invoiced = 0;
            CSrw.InvoiceNr = "";
          end;
          MatRowPut(CSr,i,CSrw);
          i = rwcnt;
        end;
      end;
      RecordUpdate(oldCSr,CSr,false);
    end;
  end;

  return;
end; 

procedure AddCredHistToArray(var record ORVc ORr,record CredHistVc prevCredHistr,val balance)
begin
  row ORVc ORrw;
  record IVVc IVr;
  record ARVc ARr;
  record IPVc IPr;
 
  ClearRow(ORr,ORrw,1);
  ORrw.GroupOrdRow = prevCredHistr.RecordNr;
  ORrw.RowOrderType = prevCredHistr.RecordType;
  ORrw.PickingDate = prevCredHistr.PayDate;
  ORrw.PlanShipRowDate = prevCredHistr.TransDate;
  ORrw.InloadingDate = prevCredHistr.CredFromDate;
  ORrw.DespatchRowDate = prevCredHistr.CredToDate;
  ORrw.rowGP = balance;
  ORrw.CUServiceHistNr = prevCredHistr.SerNr;
  if (prevCredHistr.RecordType==kCredHistRecTypeInvoice) then begin
    IVr.SerNr = prevCredHistr.RecordNr;
    if (ReadFirstMain(IVr,1,true)) then begin
      ORrw.Sum = IVr.Sum4;
      ARr.InvoiceNr = IVr.SerNr;
      if (ReadFirstMain(ARr,1,true)) then begin
        ORrw.TAX1Reb = ARr.RVal;
      end;
    end;
  end else begin
    IPr.SerNr = prevCredHistr.RecordNr;
  end;
  MatRowInsert(ORr,0,ORrw);

  return;
end;

function Integer GetInterestPaymentType(record CredManVc CredManr)
begin
  record CMInvoicingBlock CIb;
  record CredManTypeVc CMTr;
  Integer res;

  res = CredManr.InterestPaymentType-1;
  if (res==-1) then begin
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      res = CMTr.InterestPaymentType-1;
    end;
  end;

  if (res==-1) then begin
    BlockLoad(CIb);
    res = CIb.InterestPaymentType;
  end;
  GetInterestPaymentType = res;
  return;
end;

global
procedure GetCredManEventList(record CredManVc CredManr,var record ORVc ORr)
begin
  record CredHistVc CredHistr,prevCredHistr;
  Boolean TrHs,firstf;
  val balance;
  
  TrHs = true;
  CredHistr.CredManNr = CredManr.SerNr;
  int_type = GetInterestPaymentType(CredManr);
  if (int_type==1) then begin
    balance = 0;
  end else begin
    balance = CredManr.InvSum4;
  end;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if (CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      //sortrows
      if (firstf==true and (CredHistr.RecordType!=prevCredHistr.RecordType or CredHistr.RecordNr!=prevCredHistr.RecordNr)) then begin
        AddCredHistToArray(ORr,prevCredHistr,balance);
      end;
      if (CredHistr.RecordType==kCredHistRecTypeInvoice and (CredHistr.ChargeType==kEventTypeIssueInstalment or CredHistr.ChargeType==kEventTypeIssueDeposit)) then begin
        balance = balance - CredHistr.Sum;
      end;
      if (CredHistr.RecordType==4) then begin//partial buyout
        balance = balance - CredHistr.Sum;
      end;
      if (CredHistr.RecordType==5 and int_type==1) then begin//payment
        balance = balance + CredHistr.Sum;
      end;
      firstf = true;
      RecordCopy(prevCredHistr,CredHistr);
    end;
  end;
  if (prevCredHistr.SerNr>-1) then begin
    AddCredHistToArray(ORr,prevCredHistr,balance);
  end;

  SortRows(ORr,"PlanShipRowDate",true);

  return;
end;

global
procedure GetCredManEventList2(Longint credmannr,var record ORVc ORr)
begin
  record CredManVc CredManr;

  CredManr.SerNr = credmannr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    GetCredManEventList(CredManr,ORr);
  end;  

  return;
end;

function Boolean BuyerPaidInvoice(record CredManVc CredManr,var Longint ivnr)
begin
  record CredHistVc CredHistr;
  Boolean res,TrHs;
  
//in first version we will assume this invoice has only one item therefore we can check record history only
  TrHs = true;
  while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,TrHs)) begin
    if (CredHistr.RecordType==0 and CredHistr.PaidFlag==1) then begin
      res = true;
      ivnr = CredHistr.RecordNr;
      TrHs = false;
    end;
  end;

  BuyerPaidInvoice = res;
  return;
end;

function Boolean GetFactoringDays(record CredManVc CredManr,var date paydate,var Integer factdays)
begin
  record CredHistVc CredHistr;
  Boolean res;

  paydate = "";
  while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,true)) begin
    if (CredHistr.RecordType==1) then begin
      if (CredHistr.TransDate>paydate) then begin
        paydate = CredHistr.TransDate;
      end;
    end;
  end;

  if (nonblank(paydate)) then begin
    factdays = DateDiff(paydate,CredManr.startDate);
    res = true;
  end;

  GetFactoringDays = res;
  return;
end; 

global
updating procedure StoreCredManSchedRecord(record CredManSchedVc CSr)
begin
  record CredManSchedVc oldCSr;

  oldCSr.CredManNr = CSr.CredManNr;
  if (ReadFirstMain(oldCSr,1,true)) then begin
    RecordUpdate(oldCSr,CSr,false);
  end else begin
    RecordInsert(CSr,true);
  end;

  return;
end;

global
procedure GenerateAgreementSchedule(record CredManVc CredManr,Boolean forcef)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record SMVc SMr;
  row SMVc SMrw;
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt,rw;
  Boolean updf;
  record CredFeesMatrixVc FMr;
  val bal;
  transaction Boolean gSilenceIVOpenPrepExists;
  
logtext(0,"GenerateAgreementSchedule1");
  gSilenceIVOpenPrepExists = true;
  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    RecordCopy(oldCSr,CSr);
    rwcnt = MatRowCnt(CSr);
    for (i=rwcnt-1;i>=0;i=i-1) begin
      MatRowDelete(CSr,i);
    end;
    updf = true;
  end else begin
    RecordNew(CSr);
    CSr.CredManNr = CredManr.SerNr;
    CSr.CustCode = CredManr.CustCode;
    CSr.CustName = CredManr.Addr0;
  end;
  if (updf and forcef==false) then begin
    goto lout;
  end;
  CSr.TransDate = CurrentDate;
  CSr.TransTime = CurrentTime;
  BlockLoad(CMb);
  BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
  BuildCredManInfoMatrix(CredManr,CredManPayPlanr,CMb,SMr);
  bal = CredManr.InvSum4;
  rwcnt = MatRowCnt(SMr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMr,i,SMrw);
    ClearRow(CSr,CSrw,1);
    CSrw.InvDate = SMrw.TransDate;
    CSrw.PayDate = SMrw.DueDate;
    CSrw.Type = SMrw.RowSimStat;
    if (CSrw.Type==4) then begin
      CSrw.Total = SMrw.CurDebVal;
      CSrw.Invoiced = 1;
      bal = bal - CSrw.Total;
      CSrw.Balance = bal;
//      CSrw.Principle = SMrw.CurDebVal;
    end else begin
      CSrw.FromDate = SMrw.Objects;
      CSrw.ToDate = SMrw.Comment;
      CSrw.Principle = SMrw.DebVal - SMrw.ToRateB1;
      CSrw.Deposit = SMrw.ToRateB1;
      bal = bal - CSrw.Principle - CSrw.Deposit;
      CSrw.Balance = bal;
      CSrw.Interest = SMrw.CredVal;
      CSrw.Fees = SMrw.DebVal2;
      UnpackRowFieldMatrix(SMrw,"FeesMatrix",FMr);
      PackRowFieldMatrix(CSrw,"FeesMatrix",FMr);
      CSrw.Total = SMrw.CurDebVal;
      if (nonblank(SMrw.ExtraComment)) then begin
        CSrw.Invoiced = 1;
        CSrw.InvoiceNr = SMrw.ExtraComment;
      end;
    end;
    MatRowPut(CSr,rw,CSrw);
    rw = rw + 1;
  end;
  qupdating.StoreCredManSchedRecord(CSr);

lout:;
logtext(0,"GenerateAgreementSchedule2");
  gSilenceIVOpenPrepExists = false;
  return;
end;

global 
updating procedure CheckCredManFinished(Longint credmannr)
begin
  record CMOrderClassBlock OCb;
  record CredManVc CredManr,oldCredManr;
  record RcVc RepSpec;

  CredManr.SerNr = credmannr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    RepSpec.d1 = CurrentDate;
    CheckBuyOutAgreement(CredManr,RepSpec);
    if (RepSpec.vals2==0) then begin
      BlockLoad(OCb);
      RecordCopy(oldCredManr,CredManr);
      CredManr.OrderClass = OCb.FinishCredOrderClass;
      CredManr.Status = 7;
      RecordUpdate(oldCredManr,CredManr,true);
    end;
  end;
  

  return;
end;
global 
updating procedure CheckCredManFinished2(record IPVc IPr)
begin
  row IPVc IPrw;
  Integer i,rwcnt;
  vector Boolean vCMr;
  record IVVc IVr;

  rwcnt = MatRowCnt(IPr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IPr,i,IPrw);
    IVr.SerNr = IPrw.InvoiceNr;
    if (IPrw.InvoiceNr>0 and ReadFirstMain(IVr,1,true)) then begin
      if (IVr.CustCredManNr>0) then begin
        if (vCMr[IVr.CustCredManNr]==false) then begin
          CheckCredManFinished(IVr.CustCredManNr);
          vCMr[IVr.CustCredManNr] = true;
        end;
      end;
    end;
  end;
  

  return;
end;

global
function val GetCredManItemValue(record IVVc IVr,string item,Boolean setzerof)
begin
  Integer i,rwcnt;
  val res;
  row IVVc IVrw;

  if (setzerof) then begin
    res = 0;
  end;
  
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVrw.ArtCode==item) then begin
      res = res + IVrw.Sum;
    end;
  end;

  GetCredManItemValue = res;
  return;
end;

function string 255 GetReceiptsPayMode(record IVVc IVr)
begin
  Boolean foundf;
  record IPrsVc IPrsr;
  string 255 res;
  record IPVc IPr;
  
  IPrsr.IVNr = IVr.SerNr;
  IPrsr.TransType = kIPrsTransTypeReceipt;
  foundf = true;
  while (LoopKey("IVKey",IPrsr,2,foundf)) begin
    if (IPrsr.IVNr!=IVr.SerNr or IPrsr.TransType!=kIPrsTransTypeReceipt) then begin 
      foundf = false;
    end else begin
      IPr.SerNr = IPrsr.TransNr;
      if (ReadFirstMain(IPr,1,true)) then begin
        res = IPr.PayMode;
        foundf = false;
      end;
    end;
  end;

  GetReceiptsPayMode = res;
  return;
end;

global
updating procedure MakeMoneyRuturnIVVcRemote(record IVVc IVr,var record IPVc IPr)
begin
  row IPVc IPrw;
  Integer rownr;
  val chk;
  Boolean installmentf;
  Longint err;
  record ARVc ARr;
  val sum;
  record IPVc oldIPr;

  sum = IVr.Sum4;
  ARr.InvoiceNr = IVr.SerNr;
  if (ReadFirstMain(ARr,1,true)) then begin
    if (ARr.RVal>=0) then begin
      sum =   IVr.Sum4 - ARr.RVal;
    end;
  end;

  if (sum>0) then begin
    RecordNew(IPr);
    IPr.TransDate = CurrentDate;
    IPr.SerNr = NextSerNr("IPVc",IPr.TransDate,-1,false,"");
    IPr.RegDate = CurrentDate;
    IPr.OKFlag = 0;
    IPr.PayMode = GetReceiptsPayMode(IVr);
    IPPastePayMode(IPr);
    rownr = 0;
    ClearRow(IPr,IPrw,1);
    IPrw.InvoiceNr = IVr.SerNr;
    MatRowPut(IPr,rownr,IPrw);
    PasteInvIn2IPr(IPr,rownr,IPr.TransDate,chk,false,installmentf);
    MatRowGet(IPr,rownr,IPrw);
    IPrw.RecVal = -sum;
    MatRowPut(IPr,rownr,IPrw);
    IPVc_PasteRecVal(IPr,rownr);

    rownr = 1;
    ClearRow(IPr,IPrw,1);
    IPrw.CustCode = IVr.CustCode;
    MatRowPut(IPr,rownr,IPrw);
    IPVc_PasteCustCode(IPr,rownr,err);
    MatRowGet(IPr,rownr,IPrw);
    IPrw.RecVal = sum;
    IPrw.CUPNr = IPr.SerNr;
    MatRowPut(IPr,rownr,IPrw);
    IPVc_PasteRecVal(IPr,rownr);
    
    IPSumup(IPr);
    if (RecordInsert(IPr,true)) then begin
      RecordCopy(oldIPr,IPr);
      IPr.OKFlag = 1;
      RecordUpdate(oldIPr,IPr,true);
    end;
  end;
  return;
end;