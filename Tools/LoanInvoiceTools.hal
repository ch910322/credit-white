external procedure BuildCredManPayPlanCust(record CredManVc,var record CredManPayPlanVc,record CredManSetBlock,Boolean,Boolean);
remote inner function Boolean PasteCust2InInv(var record IVVc,record LocalMachineBlock,string,Boolean,var string,var string,var string,var string,var string);
remote inner procedure IVVc_PastePayDeal(var record IVVc,string,string);
remote inner procedure IVVc_PasteSalesMan(var record IVVc,string);
external inner function Boolean IVVc_PasteArtCode(var record IVVc,Integer,var string,var string,Boolean,var Integer);
external inner procedure IVDchsum(var record IVVc,Integer);
external inner procedure IVVc_PastePrice(var record IVVc,record IVVc,Integer,var string);
external inner function LongInt DateDiff(Date,Date);
external procedure AddPlannedFees(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,Integer,Integer,Date,var val,var val,Date,Date,Longint);
external procedure AddInterest(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,Integer,Date,var val,var val,Date,Date,Longint);
external procedure AddInstalmentFixed(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,val,Date,var val,var val,Date,Date);
forward procedure GetCredManEventList2(Longint,var record ORVc);
external inner procedure PasteARPayInIV(record IVVc,row IVVc,Integer);
external updating procedure FindUnpaidCredHist(record ItemPriorityBlock,record IPVc,row IPVc,var array val,Integer);
external inner function Boolean IVVc_PasteSum(var record IVVc,Integer,var Boolean,Integer);
external function Date GetLastInvoiceDate(record CredManVc,Date);
external procedure BuildCredManInfoMatrix(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,var record SMVc);
external inner procedure SumNoDownPay(record IVVc,var val,var val,var val,var val,var val,var val);
external function string 255 GetCredManNr(Longint);
external procedure GetHiddenInvoiceValues(record IVVc,var val,var val);
external inner procedure InvVat(Integer,Integer,Integer,Integer,string,val,var val,var val,var val,var val,var val);

enum begin
  kCredHistRecTypeInvoice = 0,
  kCredHistRecTypeReceipt = 1,
  kCredHistRecTypePrepayment = 2
end;

enum begin
  kPlannedFeesMonthly = 0,
  kPlannedFeesOneTime = 1
end;

enum begin
  kEventTypeNone = 0,
  kEventTypeCalcInstalment = 1,
  kEventTypeCalcInterest = 2,
  kEventTypeCalcDeposit = 3,
  kEventTypeCalcFees = 4,
  kEventTypeIssueInstalment = 5,
  kEventTypeIssueInterest = 6,
  kEventTypeIssueDeposit = 7,
  kEventTypeIssueFees = 8,
  kEventTypeIssueLateFees = 9
end;

enum begin
  kMonthTypeFirst = 0,
  kMonthTypeRegular = 1,
  kMonthTypeLast = 2
end;

function string 255 SetCompanyLanguage()
begin
  record CYBlock CYb;
  string 255 oldlang,newlang;
  Integer langmode;

  BlockLoad(CYb);
  oldlang = CurrentLanguage;
  newlang = CYb.LangCode;

  if (oldlang!=newlang and nonblank(newlang)) then begin
    langmode = SetFromString(619,newlang);
    if (langmode>-1) then begin
      SetLangMode(langmode,newlang,0);
    end;
  end;

  SetCompanyLanguage = oldlang;
  return;
end;

procedure ResetCompanyLanguage(string oldlang)
begin
  Integer oldlangmode;

  if (CurrentLanguage!=oldlang) then begin
    oldlangmode = SetFromString(619,oldlang);
    if (oldlangmode>-1) then begin
      SetLangMode(oldlangmode,oldlang,0);
    end;
  end;

  return;
end;

updating procedure LinkCredManAndInvoice(record IVVc IVr,record CredManVc CredManr)
begin
  
  CreateRecordLink(IVr,CurrentCompany,CredManr,CurrentCompany);

  return;
end;

global
procedure SetupLoanInvoice(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Date invdate,Date fromdate,Date todate,Boolean sernrf,Boolean forcecustf,string ivno)
begin
  record LocalMachineBlock LMb;
  string 255 warning,errstr,prepstr,invdatewarn,transdatewarn;
  row IVVc IVrw;
  string 255 oldlang;
  record CMInvoicingBlock CIb;

  BlockLoad(LMb);
  BlockLoad(CIb);
  oldlang = SetCompanyLanguage;

  RecordNew(IVr);
  IVr.CustCredManNr = CredManr.SerNr;
  IVr.TransDate = invdate;//or current date?
  IVr.InvDate = invdate;//from seting?
  IVr.CustCode = CredManr.CustCode;
  PasteCust2InInv(IVr,LMb,"",false,warning,errstr,prepstr,invdatewarn,transdatewarn);
  IVr.PayDeal = CredManr.PayDeal;
  IVVc_PastePayDeal(IVr,"",LMb.DefReturnLocation);
  IVr.SalesMan = CredManr.SalesMan;
  IVVc_PasteSalesMan(IVr,"");
  IVr.CredFromDate = fromdate;
  IVr.CredToDate = todate; 
  if (nonblank(ivno)) then begin
    IVr.OfficialSerNr = ivno;
  end;
  if (sernrf) then begin
    IVr.SerNr = NextSerNr("IVVc",IVr.InvDate,-1,false,"");
  end;

  IVr.CredFromDate = fromdate;
  IVr.CredToDate = todate;
  if (CredManr.startDate==invdate) then begin
    IVr.LangCode = CredManr.LangCode2;
  end else begin
    IVr.LangCode = CredManr.LangCode;
  end;

  //we should always have in the plan first row instalment or interest where we have start and end date
  if (CIb.DetailedInvoice==1) then begin
    ClearRow(IVr,IVrw,1);
    if (nonblank(CredManr.OfficialSerNr)) then begin
      IVrw.Spec = CIb.InvoiceCommentStr & USetStr(200080) & CredManr.OfficialSerNr;
    end else begin
      IVrw.Spec = CIb.InvoiceCommentStr & USetStr(200080) & CredManr.SerNr;
    end;
    MatRowPut(IVr,0,IVrw);
    if (nonblank(fromdate)) then begin
      ClearRow(IVr,IVrw,1);
      IVrw.Spec = CIb.InvoiceCommentStr & USetStr(200081) & fromdate & ":" & todate;
      MatRowPut(IVr,1,IVrw);
    end else begin
      ClearRow(IVr,IVrw,1);
      IVrw.Spec = " ";
      MatRowPut(IVr,1,IVrw);      
    end;
    ClearRow(IVr,IVrw,1);
    IVrw.Spec = " ";
    MatRowPut(IVr,MatRowCnt(IVr),IVrw);
  end;
  ResetCompanyLanguage(oldlang);

  return;
end;

procedure SetupInvoiceRowAndAdd(var record IVVc IVr,string item,string itemname,val quant,val price,val reb,Integer chargetype,Longint factinv)
begin
  row IVVc IVrw;
  string 255 inwarning,warning;
  Integer sernrf,rw;
  record IVVc IV2r;
  val bval;

  
  if (price>0 and nonblank(item)) then begin
    rw = MatRowCnt(IVr);
    ClearRow(IVr,IVrw,1);
    IVrw.ArtCode = item;
    IVrw.Quant = quant;
    IVrw.ChargeType = chargetype;
    IVrw.FactoringInvoice = factinv;
    MatRowPut(IVr,rw,IVrw);
    if (IVVc_PasteArtCode(IVr,rw,inwarning,warning,false,sernrf)) then begin    
      IVDchsum(IVr,rw);
    end;
    MatRowGet(IVr,rw,IVrw);
    IVrw.Price = price;
    if (reb>0) then begin
      IVrw.vRebate = reb;
    end else begin
      IVrw.vRebate = bval;//should it be like that? what about discount matrix?
    end;
    MatRowPut(IVr,rw,IVrw);
    IVVc_PastePrice(IVr,IV2r,rw,warning);
    if (nonblank(itemname)) then begin
      MatRowGet(IVr,rw,IVrw);
      IVrw.Spec = itemname;
      MatRowPut(IVr,rw,IVrw);
    end;
  end;

  return;
end;

function Boolean InvoiceHasHiddenLine(record IVVc IVr)
begin
  Integer i,rwcnt;
  row IVVc IVrw;
  Boolean res;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVrw.stp==kInvoiceRowTypeHidden) then begin
      res = true;
      i = rwcnt;
    end;
  end;

  InvoiceHasHiddenLine = res;
  return;
end;

procedure AddOverdueComments(var record IVVc IVr,array string lateformula)
begin
  Integer i,rwcnt;
  Boolean hiddenf;
  row IVVc IVrw,hiddenIVrw;
  
  if (!InvoiceHasHiddenLine(IVr)) then begin
    ClearRow(IVr,hiddenIVrw,kInvoiceRowTypeHidden);
    MatRowPut(IVr,MatRowCnt(IVr),hiddenIVrw);
  end;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<lateformula.length;i=i+1) begin
    ClearRow(IVr,IVrw,1);
    IVrw.Spec = lateformula[i];
    MatRowPut(IVr,rwcnt,IVrw);
    rwcnt = rwcnt + 1;
  end;

  return;
end;

global
procedure SetupOverdueLangCode(var record IVVc IVr,string type)
begin
  record CredManTypeVc CMTr;

  CMTr.Code = type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if (nonblank(CMTr.OverdueLangCode)) then begin
      IVr.LangCode = CMTr.OverdueLangCode;
    end;
  end;
  

  return;
end;

global
procedure AddLateFees(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Integer latedays,val lateamount,array string lateformula)
begin
  val laterate;
  record CMInvoicingBlock CIb;
  
  if (lateamount>0) then begin
    SetupInvoiceRowAndAdd(IVr,CMb.LateFeeItem,"",1,0,0,kEventTypeIssueLateFees,-1);
    SetupInvoiceRowAndAdd(IVr,CMb.LateRateItem,"",1,lateamount,0,kEventTypeIssueLateFees,-1);
    BlockLoad(CIb);
    if (CIb.AddOverdueDetails==1) then begin
      AddOverdueComments(IVr,lateformula);
    end;
  end;

  return;
end;

function Integer GetMonthDays(Date td)
begin
  Integer res;

  res = DaysInMonth(GetYear(td),GetMonth(td));

  GetMonthDays = res;
  return;
end;

procedure GetLatePaymentPlan(record CredManVc CredManr,record CredHistVc CredHistr,Date sd,Date ed,Date overduetd,var array val amounts,var array Integer daycnt)
begin
  Date tempsd,tempsd2;
  record CredHistVc CredPayr;//CredPayr - same credhistvc register, just for payments
  Integer i,daydiff,daydiff2;
  Boolean TrHs;
  val paysum;
  
  paysum = CredHistr.Sum;
  tempsd = sd;//this is the start date when this item should have been paid since
  if (nonblank(overduetd)) then begin
    tempsd = overduetd;
  end;
  if (tempsd<=CredHistr.PayDate) then begin
    tempsd = AddDay(CredHistr.PayDate,1);
  end;
  tempsd2 = tempsd;

  /*
  if (CredManr.LateFeeDays>0) then begin
    tempsd = AddDay(tempsd,CredManr.LateFeeDays);
  end;
  */

  ClearArray(amounts);
  TrHs = true;
  CredPayr.PreviousNr = CredHistr.SerNr;
  while (LoopKey("PreviousNr",CredPayr,1,TrHs)) begin
    if (CredPayr.PreviousNr!=CredHistr.SerNr) then begin
      TrHs = false;
    end else begin
      if (CredPayr.TransDate>CredHistr.PayDate) then begin
        if (CredPayr.TransDate>sd and CredPayr.TransDate<=ed) then begin
          daydiff = DateDiff(CredPayr.TransDate,tempsd);//or DateDiff2 to get daydiff+1 days
          daydiff2 = DateDiff(CredPayr.TransDate,CredHistr.PayDate);//or DateDiff2 to get daydiff+1 days
          if (CredManr.LateFeeDays<daydiff2) then begin
            for (i=0;i<daydiff;i=i+1) begin
              amounts[amounts.length] = paysum;
              daycnt[daycnt.length] = GetMonthDays(AddDay(CredPayr.TransDate,i));
            end;
          end;
        end;
        if (CredPayr.TransDate>ed) then begin//no need to continue for later payments
          TrHs = false;
        end;
        tempsd = CredPayr.TransDate;
      end;
      paysum = paysum - CredPayr.Sum;
    end;
  end;
  if (paysum>0 and tempsd<ed) then begin
    daydiff = DateDiff(ed,tempsd);
    daydiff2 = DateDiff(ed,CredHistr.PayDate);
    if (CredManr.LateFeeDays<daydiff2) then begin
      for (i=0;i<daydiff;i=i+1) begin
        amounts[amounts.length] = paysum;
        daycnt[daycnt.length] = GetMonthDays(AddDay(ed,i));
      end;
    end;
  end;

  return;
end;

global
procedure CheckOverdueInvoicesForItem(record CredManVc CredManr,record CredManSetBlock CMb,val maxmonths,Date invdate,Date prevtd,var Integer latedays,var val lateamount,string item,Date overduetd,var array string lateformula,Integer ratetype)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  array val amounts;
  array Integer daycnt;
  val latefee;
  Integer i;
  val overdueprc;
  Date mindate;

  if (maxmonths>0) then begin
    mindate = AddMonth(invdate,-maxmonths);
  end;
  
  overdueprc = CredManr.OverduePercentage;
  if (CredManr.AnnualRate==1) then begin
    overdueprc = overdueprc/12;
  end;
  TrHs = true;
  CredHistr.ArtCode = item;
  CredHistr.CredManNr = CredManr.SerNr;
  while (LoopKey("ArtCode",CredHistr,2,TrHs)) begin
    if (CredHistr.ArtCode!=item or CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      if (blank(mindate) or CredHistr.TransDate>=mindate) then begin
        //Construct an array of days with amount that is over due starting with the first day of period
        GetLatePaymentPlan(CredManr,CredHistr,AddDay(prevtd,1),invdate,overduetd,amounts,daycnt);
        for (i=0;i<amounts.length;i=i+1) begin
          if (ratetype==0) then begin //as default
            latefee = latefee + (amounts[i]*(overdueprc/100));
            lateformula[lateformula.length] = "Day " & i & " - " & item & " - " & amounts[i] & " * " & ValToString((overdueprc/100),M45Val,"",",",0) & "=" & (amounts[i]*(overdueprc/100));
          end else begin
            latefee = latefee + (amounts[i]*(overdueprc/100)/daycnt[i]);
            lateformula[lateformula.length] = "Day " & i & " - " & item & " - " & amounts[i] & " * " & ValToString((overdueprc/100),M45Val,"",",",0) & "/" & daycnt[i] & "=" & (amounts[i]*(overdueprc/100)/daycnt[i]);
          end;
        end;
      end;
    end;
  end;

  lateamount = lateamount + latefee;

  return;
end;

function Date GetLastOverdueInvoiceDate(Longint sernr,string item)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  Date res;

  TrHs = true;
  CredHistr.ArtCode = item;
  CredHistr.CredManNr = sernr;
  while (LoopKey("ArtCode",CredHistr,2,TrHs)) begin
    if (CredHistr.ArtCode!=item or CredHistr.CredManNr!=sernr) then begin
      TrHs = false;
    end else begin
      if (CredHistr.TransDate>res) then begin
        res = CredHistr.TransDate;
      end;
    end;
  end;

  GetLastOverdueInvoiceDate = res;
  return;
end;

function Integer GetRateType(string type)
begin
  record CredManTypeVc CMTr;
  record CMInvoicingBLock CIb;
  Integer res;

  res = -1;
  CMTr.Code = type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if (CMTr.OverdueRateType>0) then begin
      res = CMTr.OverdueRateType - 1;
    end else begin
      BlockLoad(CIb);
      res = CIb.OverdueRateType;
    end;
  end;
  if (res==-1) then begin
    BlockLoad(CIb);
    res = CIb.OverdueRateType;
  end;

  GetRateType = res;
  return;
end;

global
procedure GetCredManOverdueInvoices(record CredManVc CredManr,record CredManSetBlock CMb,Date invdate,Date prevtd,var Integer latedays,var val lateamount,var array string lateformula)
begin
  record CMInvoicingBlock CIb;
  record INVc INr;
  Date overduetd;
  record CUVc CUr;
  Integer ratetype;

  CUr.Code = CredManr.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin
    if (CUr.InterestFlag==1) then begin
      BlockLoad(CIb);

      ClearStringArray(lateformula);
      latedays = 0;
      lateamount = 0;
      overduetd = GetLastOverdueInvoiceDate(CredManr.SerNr,CMb.LateFeeItem);
      //we should go through the history and check for late payments
      if (nonblank(CIb.OverdueItemClass)) then begin
        ratetype = GetRateType(CredManr.Type);
        while (LoopKey("DICode:" & CIb.OverdueItemClass,INr,1,true)) begin
          CheckOverdueInvoicesForItem(CredManr,CMb,CIb.OverdueMonths,invdate,prevtd,latedays,lateamount,INr.Code,overduetd,lateformula,ratetype);
        end;
      end;
    end;
  end;
  return;
end;

procedure MergeItemsInInvoice(var record IVVc IVr)
begin
  Integer i,rwcnt,chargetype;
  row IVVc IVrw;
  vector val vRows;
  array string 255 arr;
  val quant,reb;
  Longint pos,factinv;
  string 255 index,tstr,item;
  
  rwcnt = MatRowCnt(IVr);
  for (i=rwcnt-1;i>=0;i=i-1) begin
    MatRowGet(IVr,i,IVrw);
    if (nonblank(IVrw.ArtCode)) then begin
      index = IVrw.ArtCode & ":" & IVrw.Quant & ":" & IVrw.vRebate & ":" & IVrw.ChargeType & ":" & IVrw.FactoringInvoice;
      vRows[index] = vRows[index] + IVrw.Price;
      MatRowDelete(IVr,i);
    end;
  end;
  GetVectorTags(vRows,arr);
  for (i=0;i<arr.length;i=i+1) begin
    pos = -1;
    GetNextSubstring(arr[i],pos,":",item);
    GetNextSubstring(arr[i],pos,":",tstr);
    quant = StringToVal(tstr,M4Val);
    GetNextSubstring(arr[i],pos,":",tstr);
    reb = StringToVal(tstr,M4Val);
    GetNextSubstring(arr[i],pos,":",tstr);
    chargetype = StringToInt(tstr);
    GetNextSubstring(arr[i],pos,":",tstr);
    factinv = StringToLongint(tstr);
    SetupInvoiceRowAndAdd(IVr,item,"",quant,vRows[arr[i]],reb,chargetype,factinv);
  end;

  return;
end;

function Boolean GetNextInvoicableDate(var Date td,var Date prevtd,Date ed,record CredManVc CredManr)
begin
  Boolean res;
  
  prevtd = td;
  td = AddMonth(td,1);
  td.Day = DaysInMonth(td.Year,td.Month);
  if (td<=ed and td<=CredManr.endDate) begin //deal with all the other invoices
    res = true;
  end;

  GetNextInvoicableDate = res;
  return;
end;

procedure AddPrepayments(var record IVVc IVr,record CMInvoicingBlock CIb)
begin
  record ARPayVc ARPayr;
  val remval;
  Boolean TrHs;
  row IVVc IVrw;
  record IVVc IV2r;
  string 255 warning;
  Boolean chsum;
  
  if (CIb.AddPrepayments) then begin
    remval = IVr.Sum4;
    TrHs = true;
    ARPayr.CustCode = IVr.CustCode;
    while (LoopKey("CustCode",ARPayr,1,TrHs) and remval>0) begin
      if (ARPayr.CustCode!=IVr.CustCode) then begin
        TrHs = false;
      end else begin
//        if (ARPayr.PayDate<IVr.TransDate) then begin
          ClearRow(IVr,IVrw,kInvoiceRowTypePrepayment);
          IVrw.Spec = USetStr(1288);
          IVrw.CUPNr = ARPayr.CUPNr;
          PasteARPayInIV(IVr,IVrw,-1);
          MatRowInsert(IVr,0,IVrw);
          if IVVc_PasteSum(IVr,0,chsum,1) then begin 
            if (chsum) then begin
              IVDchsum(IVr,0);
            end;
          end;  
          remval = remval - IVrw.BasePrice;
//        end;
      end;
    end;
  end;

  return;
end;

global
updating procedure StoreLoanInvoice(var record IVVc IVr,record CredManVc CredManr)
begin
  record IVVc oldIVr;
  
  IVr.SerNr = NextSerNr("IVVc",IVr.InvDate,-1,false,"");
  if (RecordInsert(IVr,true)) then begin
    RecordCopy(oldIVr,IVr);
    IVr.OKFlag = 1;
    RecordUpdate(oldIVr,IVr,true);
    LinkCredManAndInvoice(IVr,CredManr);
  end;

  return;
end;

procedure CheckAndAddHiddenPrinciple(var record IVVc IVr,record CMInvoicingBlock CIb)
begin
  row IVVc IVrw,hiddenIVrw;
  Integer i,rwcnt;
  Boolean foundf;
  
  if (CIb.HiddenPrinciple==1) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.ChargeType>0 and IVrw.ChargeType!=kEventTypeCalcInstalment) then begin
        foundf = true;
        i = rwcnt;
      end;
    end;
    if (foundf) then begin
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        if (IVrw.ChargeType==kEventTypeCalcInstalment) then begin
          MatRowDelete(IVr,i);
          if (InvoiceHasHiddenLine(IVr)==false) then begin
            ClearRow(IVr,hiddenIVrw,kInvoiceRowTypeHidden);
            MatRowPut(IVr,MatRowCnt(IVr),hiddenIVrw);
          end;
          MatRowPut(IVr,MatRowCnt(IVr),IVrw);
          goto LCheckAndAddHiddenPrinciple;
        end;
      end;
    end;
  end;

LCheckAndAddHiddenPrinciple:;
  return;
end;

updating procedure CreateInvoicesFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date ed,var record IVVc firstIVr,string ivno)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  Date lastd,lastd2;
  record IVVc IVr,oldIVr,oIVr;
  Boolean firstf;
  Integer latedays;
  val lateamount;
  record CMInvoicingBlock CIb;
  array string 255 lateformula;
  
  BlockLoad(CIb);
  lastd2 = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.PlanType<=4 and CredManPayPlanrw.TransDate<=ed) then begin
      if (lastd!=CredManPayPlanrw.TransDate) then begin
        //Setup new invoice
        if (nonblank(lastd)) then begin
          //if (IVr.InvDate==CredManr.startDate) then begin
            MergeItemsInInvoice(IVr);
          //end;
          GetCredManOverdueInvoices(CredManr,CMb,lastd,lastd2,latedays,lateamount,lateformula);
          switch (CIb.OverdueIVType) begin
            case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
            case 1: 
              SetupLoanInvoice(CredManr,CMb,oIVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno);
              SetupOverdueLangCode(IVr,CredManr.Type);
              AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
              StoreLoanInvoice(oIVr,CredManr);
          end;
          AddPrepayments(IVr,CIb);
          if (IVr.SerNr>-1) then begin
            CheckAndAddHiddenPrinciple(IVr,CIb);
            StoreLoanInvoice(IVr,CredManr);
            if (firstf==false) then begin
              RecordCopy(firstIVr,IVr);
              firstf = true;
            end;
          end else begin
            LogText(0,"Failed to store Invoice. No Serial Number. Check Number Series. Not continuing to generate invoices");  
            goto lout;    
          end;
        end;
        lastd2 = AddDay(lastd,1);//to get the start date for penalty calculation.
        lastd = CredManPayPlanrw.TransDate;
        SetupLoanInvoice(CredManr,CMb,IVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno);

      end;
      SetupInvoiceRowAndAdd(IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);

    end;
    if (CredManPayPlanrw.TransDate>ed) then begin
      i = rwcnt;
    end;
  end;
  if (nonblank(lastd)) then begin
    MergeItemsInInvoice(IVr);
    GetCredManOverdueInvoices(CredManr,CMb,lastd,lastd2,latedays,lateamount,lateformula);
    switch (CIb.OverdueIVType) begin
      case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
      case 1: 
        SetupLoanInvoice(CredManr,CMb,oIVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno);
        AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
        SetupOverdueLangCode(IVr,CredManr.Type);
        StoreLoanInvoice(oIVr,CredManr);
    end;
    AddPrepayments(IVr,CIb);
    if (IVr.SerNr>-1) then begin
      CheckAndAddHiddenPrinciple(IVr,CIb);
      StoreLoanInvoice(IVr,CredManr);
      if (firstf==false) then begin
        RecordCopy(firstIVr,IVr);
      end;
    end else begin
      LogText(0,"Failed to store Invoice. No Serial Number. Check Number Series");
    end;
  end;

lout:;
  return;
end;

global
procedure TestCredManInvoicesFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date ed,var array record IVVc aIVr)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  Date lastd,lastd2;
  record IVVc IVr;
  Boolean firstf;
  Integer latedays;
  val lateamount;
  array string 255 lateformula;
  
  lastd2 = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.PlanType<=4) then begin// and CredManPayPlanrw.TransDate<=ed
      if (lastd!=CredManPayPlanrw.TransDate) then begin
        //Setup new invoice
        if (nonblank(lastd)) then begin
          //if (IVr.InvDate==CredManr.startDate) then begin
            MergeItemsInInvoice(IVr);
          //end;
          GetCredManOverdueInvoices(CredManr,CMb,lastd,lastd2,latedays,lateamount,lateformula);
          aIVr[aIVr.length] = IVr;
        end;
        lastd2 = AddDay(lastd,1);//to get the start date for penalty calculation.
        lastd = CredManPayPlanrw.TransDate;
        SetupLoanInvoice(CredManr,CMb,IVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,false,false,"");

      end;
      //skip late fees here?? 
      if (CredManPayPlanrw.PlanType!=9) then begin
        SetupInvoiceRowAndAdd(IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);
      end;

    end;
    if (CredManPayPlanrw.TransDate>ed) then begin
      i = rwcnt;
    end;
  end;
  if (nonblank(lastd)) then begin
    aIVr[aIVr.length] = IVr;
  end;

  return;
end;

global
function string 255 SetCompanyLanguage()
begin
  record CYBlock CYb;
  string 255 oldlang,newlang;
  Integer langmode;

  BlockLoad(CYb);
  oldlang = CurrentLanguage;
  newlang = CYb.LangCode;

  if (oldlang!=newlang and nonblank(newlang)) then begin
    langmode = SetFromString(619,newlang);
    if (langmode>-1) then begin
      SetLangMode(langmode,newlang,0);
    end;
  end;

  SetCompanyLanguage = oldlang;
  return;
end;

global
procedure ResetCompanyLanguage(string oldlang)
begin
  Integer oldlangmode;

  if (CurrentLanguage!=oldlang) then begin
    oldlangmode = SetFromString(619,oldlang);
    if (oldlangmode>-1) then begin
      SetLangMode(oldlangmode,oldlang,0);
    end;
  end;

  return;
end;

procedure GetItemName(string code,var string spec)
begin
  record INVc INr;

  INr.Code = code;
  ReadFirstMain(INr,1,true);
  spec = INr.Name;

  return;
end;

procedure BuildInvoiceBasedOnSchedule(record CredManVc CredManr,row CredManSchedVc CSrw,record CredManSetBlock CMb,record CMApplicationSetBlock ASb,Date lastd,var record IVVc IVr,Boolean updf,Boolean addfeesf)
begin
  Integer latedays;
  val lateamount;
  string 255 spec;
  record CMInvoicingBlock CIb;
  record IVVc oIVr;
  array string 255 lateformula;
  record CredFeesMatrixVc FMr;
  row CredFeesMatrixVc FMrw;
  Integer i,rwcnt;

  BlockLoad(CIb);
  RecordClear(IVr);
  RecordNew(IVr);
  SetupLoanInvoice(CredManr,CMb,IVr,CSrw.InvDate,CSrw.FromDate,CSrw.ToDate,true,false,"");
  if (CSrw.Principle>0) then begin
    GetItemName(CMb.RateItem,spec);
    SetupInvoiceRowAndAdd(IVr,CMb.InstalmentItem,spec,1,CSrw.Principle,blankval,kEventTypeCalcInstalment,-1);
  end;
  if (CSrw.Interest>0) then begin
    GetItemName(CMb.RateItem,spec);
    SetupInvoiceRowAndAdd(IVr,CMb.RateItem,spec,1,CSrw.Interest,blankval,kEventTypeCalcInterest,-1);
  end;
  if (CSrw.Fees>0) then begin
    UnpackRowFieldMatrix(CSrw,"FeesMatrix",FMr);
    rwcnt = MatRowCnt(FMr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(FMr,i,FMrw);
      GetItemName(FMrw.ArtCode,spec);
      SetupInvoiceRowAndAdd(IVr,FMrw.ArtCode,spec,1,FMrw.Sum,blankval,kEventTypeCalcFees,-1);
    end;
  end;
  MergeItemsInInvoice(IVr);
  if (addfeesf) then begin
    GetCredManOverdueInvoices(CredManr,CMb,CSrw.InvDate,lastd,latedays,lateamount,lateformula);
    switch (CIb.OverdueIVType) begin
      case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
      case 1: 
        SetupLoanInvoice(CredManr,CMb,oIVr,CSrw.InvDate,CSrw.FromDate,CSrw.ToDate,true,false,"");
        AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
        if (updf) then begin
          qupdating.StoreLoanInvoice(oIVr,CredManr);
        end;
    end;
  end;
  if (updf) then begin
    AddPrepayments(IVr,ASb);
  end;

  return;
end;

updating function Boolean CreateInvoiceBasedOnSchedule(record CredManVc CredManr,Date ed,var record IVVc firstIVr)
begin
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt,rw;
  record IVVc IVr,oldIVr;
  record CredManSetBlock CMb;
  record CMApplicationSetBlock ASb;
  Date lastd;
  Boolean firstf;
  Boolean res;
  
  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    res = true;
    BlockLoad(CMb);
    BlockLoad(ASb);
    lastd = CredManr.FirstInvDate;
    rwcnt = MatRowCnt(CSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CSr,i,CSrw);
      if (CSrw.InvDate<=ed and CSrw.Invoiced==0) then begin
        BuildInvoiceBasedOnSchedule(CredManr,CSrw,CMb,ASb,lastd,IVr,true,true);
        if (IVr.SerNr>-1) then begin
          if (RecordInsert(IVr,true)) then begin
            RecordCopy(oldIVr,IVr);
            IVr.OKFlag = 1;
            RecordUpdate(oldIVr,IVr,true);
            LinkCredManAndInvoice(IVr,CredManr);
          end;

          if (firstf==false) then begin
            RecordCopy(firstIVr,IVr);
            firstf = true;
          end;
        end;
      end else begin
        if (CSrw.InvDate>ed) then begin
          i = rwcnt;
        end;
      end;
      lastd = AddDay(CSrw.InvDate,1);
    end;
  end;
  CreateInvoiceBasedOnSchedule = res;
  return;
end;

global
procedure TestInvoiceBasedOnSchedule(record CredManVc CredManr,record CredManSchedVc CSr,Date ed,var array record IVVc aIVr)
begin
  row CredManSchedVc CSrw;
  Integer i,rwcnt,rw;
  record IVVc IVr,oldIVr;
  record CredManSetBlock CMb;
  record CMApplicationSetBlock ASb;
  Date lastd;
  Boolean firstf;
  Boolean res;
  
  BlockLoad(CMb);
  BlockLoad(ASb);
  lastd = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CSr,i,CSrw);
    if (CSrw.InvDate<=ed and CSrw.Invoiced==0) then begin
      BuildInvoiceBasedOnSchedule(CredManr,CSrw,CMb,ASb,lastd,IVr,false,false);
      aIVr[aIVr.length] = IVr;
    end else begin
      if (CSrw.InvDate>ed) then begin
        i = rwcnt;
      end;
    end;
    lastd = AddDay(CSrw.InvDate,1);
  end;

  return;
end;

global
updating procedure CreateSingleAgreementInvoice(record CredManVc CredManr,Date ed,var record IVVc IVr,string ivno)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  string 255 oldlang;

  if (CredManr.OKFlag==1 and CredManr.Approved==1) then begin
    oldlang = SetCompanyLanguage;
    if (CreateInvoiceBasedOnSchedule(CredManr,ed,IVr)==false) then begin
      BlockLoad(CMb);
      BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,false);
      CreateInvoicesFromPlan(CredManr,CMb,CredManPayPlanr,ed,IVr,ivno);
    end;
    ResetCompanyLanguage(oldlang);
  end;

  return;
end;

global
procedure CreateBuyOutInvoiceFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date td,var record IVVc IVr)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  record CredManPayPlanVc CredManPayPlan2r;
  val balance;
  Date lastinv;
  Integer latedays;
  val lateamount;
  val cumint,calcbal;
  record CredHistVc CredHistr;
  array string 255 lateformula;

/*
1. Get the last invoice date and the balance
2. Set up and create an invoice
*/ 
  lastinv = CredManr.startDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.PlanType<=4) then begin
      i = rwcnt;
    end else begin
      CredHistr.SerNr = CredManPayPlanrw.IssuedNr;
      if (ReadFirstMain(CredHistr,1,true)) then begin
        if (CredManPayPlanrw.ArtCode!=CMb.LateFeeItem and CredManPayPlanrw.ArtCode!=CMb.LateRateItem and CredHistr.RecordType==0) then begin
          if (CredManPayPlanrw.Bal<balance or balance==0) then begin
            balance = CredManPayPlanrw.Bal;
            lastinv = AddDay(CredManPayPlanrw.TransDate,1);
          end;
        end;
      end;
    end;
  end;
  
  if (balance>0) then begin
    SetupLoanInvoice(CredManr,CMb,IVr,td,lastinv,td,true,false,"");
    AddInstalmentFixed(CredManr,CredManPayPlan2r,CMb,balance,td,cumint,calcbal,lastinv,td);
    AddInterest(CredManr,CredManPayPlan2r,CMb,kMonthTypeFirst,td,cumint,balance,lastinv,td,-1);
    AddPlannedFees(CredManr,CredManPayPlan2r,CMb,kPlannedFeesMonthly,kMonthTypeFirst,td,cumint,balance,lastinv,td,-1);
    rwcnt = MatRowCnt(CredManPayPlan2r);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CredManPayPlan2r,i,CredManPayPlanrw);
      SetupInvoiceRowAndAdd(IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);
    end;
    GetCredManOverdueInvoices(CredManr,CMb,td,AddDay(lastinv,1),latedays,lateamount,lateformula);
    AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
  end;

  return;
end;

global
updating procedure CreateProlongInvoice(record CredManVc CredManr)
begin
  record CMInvoicingBlock CIb;
  record CredManSetBlock CMb;
  record IVVc IVr,oldIVr;
  val rate,sum;
  string 255 spec;

  BlockLoad(CIb);
  BlockLoad(CMb);

  SetupLoanInvoice(CredManr,CMb,IVr,CurrentDate,"","",true,false,"");
  rate = CredManr.StdProlongPrc;
  if (CredManr.AnnualRate==1) then begin
    rate = rate/12;
  end;
  sum = (CredManr.InvSum4 - CredManr.DepositSum) *(rate/100);
  sum = sum + CredManr.StdProlongFee;
  GetItemName(CIb.ProlongItem,spec);
  SetupInvoiceRowAndAdd(IVr,CIb.ProlongItem,spec,1,sum,blankval,14,-1);
  AddPrepayments(IVr,CIb);

  IVr.SerNr = NextSerNr("IVVc",IVr.InvDate,-1,false,"");
  if (IVr.SerNr>-1) then begin
    if (RecordInsert(IVr,true)) then begin
      RecordCopy(oldIVr,IVr);
      IVr.OKFlag = 1;
      RecordUpdate(oldIVr,IVr,true);
      LinkCredManAndInvoice(IVr,CredManr);
    end;  
  end;

  return;
end;


global
updating procedure CreateManualExtraInvoice(record RcVc RepSpec,var record IVVc IVr)
begin
  record CMInvoicingBlock CIb;
  record CredManSetBlock CMb;
  record IVVc oldIVr;
  val rate,sum;
  string 255 spec;
  record CredManVc CredManr;

  CredManr.SerNr = RepSpec.long1;
  if (ReadFirstMain(CredManr,1,true)) then begin
    BlockLoad(CIb);
    BlockLoad(CMb);

    SetupLoanInvoice(CredManr,CMb,IVr,RepSpec.d1,"","",true,false,"");
    GetItemName(RepSpec.f1,spec);
    SetupInvoiceRowAndAdd(IVr,RepSpec.f1,spec,1,RepSpec.vals0,blankval,15,-1);
    AddPrepayments(IVr,CIb);

    IVr.SerNr = NextSerNr("IVVc",IVr.InvDate,-1,false,"");
    if (IVr.SerNr>-1) then begin
      if (RecordInsert(IVr,true)) then begin
        RecordCopy(oldIVr,IVr);
        IVr.OKFlag = 1;
        RecordUpdate(oldIVr,IVr,true);
        LinkCredManAndInvoice(IVr,CredManr);
      end;  
    end;
  end;

  return;
end;

global
updating procedure DoBuyOutAgreement(record CredManVc CredManr,var record IVVc firstIVr)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record IVVc IVr,oldIVr;
  record CMInvoicingBlock CIb;

  if (CredManr.OKFlag==1 and CredManr.Approved==1) then begin
    BlockLoad(CMb);
    BlockLoad(CIb);
    BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,false);
    CreateBuyOutInvoiceFromPlan(CredManr,CMb,CredManPayPlanr,CurrentDate,IVr);
    AddPrepayments(IVr,CIb);
    if (IVr.SerNr>0) then begin
      if (IVr.SerNr>-1) then begin
        if (RecordInsert(IVr,true)) then begin
          RecordCopy(oldIVr,IVr);
          IVr.OKFlag = 1;
          RecordUpdate(oldIVr,IVr,true);
          LinkCredManAndInvoice(IVr,CredManr);
        end;
        RecordCopy(firstIVr,IVr);
      end;
    end else begin
      LogText(0,"Failed to store Invoice. No Serial Number. Check Number Series");
    end;
  end;

  return;
end;

procedure CheckUnpaidInvoices(record CredManVc CredManr,var val dueamount,var val openamount)
begin
  record ARVc ARr;
  record IVVc IVr;
  Boolean TrHs;

  dueamount = 0;
  openamount = 0;
  //didn't add a new index in order to save db size. This won't be so expensive.
  
  TrHs = true;
  IVr.CustCode = CredManr.CustCode;
  while (LoopKey("CustCode",IVr,1,TrHs)) begin
    if (IVr.CustCode!=CredManr.CustCode) then begin
      TrHs = false;
    end else begin
      if (IVr.CustCredManNr==CredManr.SerNr) then begin
        ARr.InvoiceNr = IVr.SerNr;
        if (ReadFirstMain(ARr,1,true)) then begin
          if (ARr.DueDate<CurrentDate) then begin
            dueamount = dueamount + ARr.RVal;
          end;
          openamount = openamount + ARr.RVal;
        end;
      end;
    end;
  end;

  return;
end;

function val GetActualBalance(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,Boolean openf)
begin
  val res;
	row CredManPayPlanVc CredManPayrw;
	Integer rwcnt,i;
  val openamount;

	res = CredManr.InvSum4;
	rwcnt = MatRowCnt(CredManPayPlanr);
	for (i=0;i<rwcnt;i=i+1) begin
		MatRowGet(CredManPayPlanr,i,CredManPayrw);
    if (CredManPayrw.PlanType>=5) then begin
      res = CredManPayrw.Bal;
      openamount = openamount + CredManPayrw.OpenAmount;
    end;
    if (CredManPayrw.PlanType<5) then begin
      i = rwcnt;
    end;
    /*
    if (CredManPayrw.TransDate>=CurrentDate) then begin
      i = rwcnt;
    end;
    */
	end;

  if (openf) then begin
    res = res + openamount;
  end;

	GetActualBalance = res;
	return;
end;

global
procedure CheckBuyOutAgreement(record CredManVc CredManr,var record RcVc RepSpec)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record IVVc IVr;
  val dueamount,openamount,lateamount;
  Integer latedays;
  Date sd;
  transaction Boolean gSilenceIVOpenPrepExists;
  array string 255 lateformula;

  gSilenceIVOpenPrepExists = true;
  BlockLoad(CMb);
  BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,false);
  CreateBuyOutInvoiceFromPlan(CredManr,CMb,CredManPayPlanr,RepSpec.d1,IVr);
  CheckUnpaidInvoices(CredManr,dueamount,openamount);
  sd = GetLastInvoiceDate(CredManr,RepSpec.d1);
  GetCredManOverdueInvoices(CredManr,CMb,RepSpec.d1,sd,latedays,lateamount,lateformula);
  RepSpec.vals1 = IVr.Sum4;
  RepSpec.vals0 = dueamount;//should this be openamount?
  RepSpec.vals2 = dueamount + IVr.Sum4;
  RepSpec.vals3 = GetActualBalance(CredManr,CredManPayPlanr,false);
  RepSpec.vals4 = dueamount;
  RepSpec.f12 = lateamount;//(RepSpec.vals2-RepSpec.vals3-RepSpec.vals4);
  RepSpec.f13 = GetActualBalance(CredManr,CredManPayPlanr,true);
  gSilenceIVOpenPrepExists = false;


  return;
end;

//very sad that I have to map these now. Adding each new type needs an exception now
function Integer MapChargeTypes(Integer type)
begin
  Integer res;
  
  switch (type) begin
    case 9:  res = type;
    case 10: res = type;
    case 11: res = type;
    case 14: res = type;//prolong fee
    case 15: res = type;//extra fee
    otherwise
      res = type + 4;
  end;

  MapChargeTypes = res;
  return;
end;

global
updating procedure CreateCredHist(Longint recnr,Integer chargetype,string custcode,val sum,Integer rectype,string item,Date duedate,Longint agreementnr,Date invdate,var Longint histnr,Date perfrom,Date perto,Integer mainf,Longint previousnr,val invsum,Longint factinv,val paidval)
begin
  record CredHistVc CredHistr;
  
  histnr = -1;

  RecordNew(CredHistr);
  CredHistr.SerNr = NextSerNr("CredHistVc",CurrentDate,-1,false,"");
  CredHistr.TransDate = invdate;
  CredHistr.RecordNr = recnr;
  CredHistr.ChargeType = MapChargeTypes(chargetype);//from calc type to issued type
  CredHistr.CustCode = custcode;
  CredHistr.RecordType = rectype;
  CredHistr.ArtCode = item;
  CredHistr.PayDate = duedate;
  CredHistr.CredManNr = agreementnr;
  CredHistr.CredFromDate = perfrom;
  CredHistr.CredToDate = perto;
  CredHistr.MainRecord = mainf;
  CredHistr.PreviousNr = previousnr;
  CredHistr.InvSum = invsum;
  CredHistr.FactoringInvoice = factinv;
  if (nonblank(CredHistr.CredFromDate)) then begin
    CredHistr.Comment2 = CredHistr.CredFromDate & ":" & CredHistr.CredToDate;
  end;
  if (paidval>0) then begin
    CredHistr.PaidSum = paidval;
    if (CredHistr.PaidSum==CredHistr.InvSum) then begin
      CredHistr.PaidFlag = 1;
    end;
  end;

  CredHistr.Sum = sum;
  if (RecordInsert(CredHistr,true)) then begin
    histnr = CredHistr.SerNr;
  end;

  return;
end;

updating procedure RemoveCredHist(Longint recnr,Integer rectype)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  
  TrHs = true;
  CredHistr.RecordNr = recnr;
  CredHistr.RecordType = rectype;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordType!=rectype or CredHistr.RecordNr!=recnr) then begin
      TrHs = false;
    end else begin
      RecordRemove(CredHistr);
      StepBack(CredHistr);
    end;
  end;

  return;
end;

function val CalculateRowSumWithVAT(record IVVc IVr,row IVVc IVrw)
begin
  val res;
  val vatprc,vatval,vatexclprc,vatinclprc,rowtax;

//first version is just row sum. We should include VAT to match with payments
  res = IVrw.Sum;
  InvVat(1,IVr.InclVAT,IVr.NoTAXonVAT,IVr.ExportFlag,IVrw.VATCode,IVrw.Sum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);

  if (IVr.InclVAT==0) then begin
    res = res + vatval;
  end;



  CalculateRowSumWithVAT = res;
  return;
end;

updating procedure UpdateCredHistBalance(Longint credmannr,Longint invnr)
begin
  record ORVc ORr;
  Integer i,rwcnt;
  record CredHistVc CredHistr,oldCredHistr;
  row ORVc ORrw;
  Boolean TrHs;
  val bal;
  
  GetCredManEventList2(credmannr,ORr);
  rwcnt = MatRowCnt(ORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORr,i,ORrw);
    if (ORrw.GroupOrdRow==invnr) then begin
      bal = ORrw.rowGP;
      i = rwcnt;
    end;
  end;
  TrHs = true;
  CredHistr.RecordNr = invnr;
  CredHistr.RecordType = 0;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordNr!=invnr or CredHistr.RecordType!=0) then begin
      TrHs = false;
    end else begin
      RecordCopy(oldCredHistr,CredHistr);
      CredHistr.Balance = bal;
      RecordUpdate(oldCredHistr,CredHistr,true);
    end;
  end;

  return;
end;

global
updating procedure UpdateCredHistBalancePartialBuyout(Longint credmannr,Longint credhistnr)
begin
  record ORVc ORr;
  Integer i,rwcnt;
  record CredHistVc CredHistr,oldCredHistr;
  row ORVc ORrw;
  Boolean TrHs;
  val bal;
  
  GetCredManEventList2(credmannr,ORr);
  rwcnt = MatRowCnt(ORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORr,i,ORrw);
    if (ORrw.CUServiceHistNr==credhistnr) then begin
      bal = ORrw.rowGP;
      i = rwcnt;
    end;
  end;
  TrHs = true;
  CredHistr.SerNr = credhistnr;
  if (ReadFirstMain(CredHistr,1,true)) begin
    RecordCopy(oldCredHistr,CredHistr);
    CredHistr.Balance = bal;
    RecordUpdate(oldCredHistr,CredHistr,true);
  end;

  return;
end;

updating procedure MakeFakeReceiptHist(record IVVc IVr,row IVVc IVrw)
begin
  record ItemPriorityBlock IPb;
  Boolean TrHs;
  row IPVc IPrw;
  array val arrCredManr;
  record IPVc IPr;

  BlockLoad(IPb);
  IPr.SerNr = IVr.SerNr;
  IPr.TransDate = IVr.InvDate;
  ClearRow(IPr,IPrw,1);
  IPrw.InvoiceNr = IVr.SerNr;
  IPrw.RecVal = IVrw.BasePrice;
  arrCredManr[IVr.CustCredManNr] = IVrw.BasePrice;
  MatRowPut(IPr,0,IPrw);
  FindUnpaidCredHist(IPb,IPr,IPrw,arrCredManr,2);

  return;
end;

function Boolean FindMatchingRow(record IVVc credIVr,Longint histnr,var row IVVc tIVrw)
begin
  Integer i,rwcnt;
  row IVVc IVrw;
  Boolean res;
  
  rwcnt = MatRowCnt(credIVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(credIVr,i,IVrw);
    if (IVrw.CredHistNr==histnr) then begin
      res = true;
      MatRowGet(credIVr,i,tIVrw);
      i = rwcnt;
    end;
  end;

  FindMatchingRow = res;
  return;
end;

global
updating procedure UpdateCredHistInvoice(var record IVVc IVr,record IVVc IV2r)
begin
  row IVVc IVrw,tIVrw,prepIVrw;
  Integer i,rwcnt;
  Boolean prepayf;
  Longint histnr;
  Integer firstf;
  record IVVc credIVr;

  firstf = 1;
  if (IVr.InvType==kInvoiceTypeCredit) then begin
    //Currently remove only whole invoice. it's too much work now for checking each row separately
    if (IVr.OKFlag==1 and IV2r.OKFlag!=1) then begin
      if (IVr.CredInv>0) then begin
        credIVr.SerNr = IVr.CredInv;
        if (ReadFirstMain(credIVr,1,true)) then begin
          //RemoveCredHist(IVr.CredInv,kCredHistRecTypeInvoice);
          rwcnt = MatRowCnt(IVr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(IVr,i,IVrw);
            if (IVrw.ChargeType>0) then begin
              if (FindMatchingRow(credIVr,IVrw.CredHistNr,tIVrw)) then begin
                CreateCredHist(IVr.SerNr,10,IVr.CustCode,tIVrw.Sum,3,"",IVr.TransDate,IVr.CustCredManNr,IVr.TransDate,histnr,"","",0,tIVrw.CredHistNr,IVrw.Sum,-1,0);

                IVrw.CredHistNr = histnr;
                MatRowPut(IVr,i,IVrw);
                firstf = 0;
              end;
            end;
          end;
        end;
      end;
    end;
  end else begin
    if (IVr.OKFlag==0 and IV2r.OKFlag!=0) then begin
      RemoveCredHist(IVr.SerNr,kCredHistRecTypeInvoice);
      RemoveCredHist(IVr.SerNr,kCredHistRecTypePrepayment);
    end;
    
    if (IVr.OKFlag==1 and IV2r.OKFlag!=1) then begin
      rwcnt = MatRowCnt(IVr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        if (IVrw.ChargeType>0) then begin
          CreateCredHist(IVr.SerNr,IVrw.ChargeType,IVr.CustCode,CalculateRowSumWithVAT(IVr,IVrw),kCredHistRecTypeInvoice,IVrw.ArtCode,IVr.PayDate,IVr.CustCredManNr,IVr.InvDate,histnr,IVr.CredFromDate,IVr.CredToDate,firstf,-1,IVr.Sum4,IVrw.FactoringInvoice,0);
          IVrw.CredHistNr = histnr;
          MatRowPut(IVr,i,IVrw);
          firstf = 0;
        end;
        if (IVrw.stp==kInvoiceRowTypePrepayment) then begin
          if (IVrw.BasePrice>0) then begin
            MatRowGet(IVr,i,prepIVrw);
            prepayf = true;
          end;
        end;
      end;
      if (prepayf) then begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          if (IVrw.stp==kInvoiceRowTypePrepayment and IVrw.BasePrice>0) then begin
            MakeFakeReceiptHist(IVr,IVrw);
          end;
        end;
      end;
    end;
  end;

  UpdateCredHistBalance(IVr.CustCredManNr,IVr.SerNr);

  return;
end;

global
updating procedure UpdateCredManScheduleFromInvoice(record IVVc IVr,Boolean setf)
begin
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw;
  Integer rwcnt,i;

  if (IVr.CustCredManNr>0) then begin
    CSr.CredManNr = IVr.CustCredManNr;
    if (ReadFirstMain(CSr,1,true)) then begin
      RecordCopy(oldCSr,CSr);
      rwcnt = MatRowCnt(CSr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CSr,i,CSrw);
        if (CSrw.InvDate==IVr.InvDate) then begin
          if (setf) then begin
            CSrw.Invoiced = 1;
            CSrw.InvoiceNr = IVr.SerNr;
          end else begin
            CSrw.Invoiced = 0;
            CSrw.InvoiceNr = "";
          end;
          MatRowPut(CSr,i,CSrw);
          i = rwcnt;
        end;
      end;
      RecordUpdate(oldCSr,CSr,true);
    end;
  end;

  return;
end; 

procedure AddCredHistToArray(var record ORVc ORr,record CredHistVc prevCredHistr,val balance)
begin
  row ORVc ORrw;
  record IVVc IVr;
  record ARVc ARr;
  record IPVc IPr;
 
  ClearRow(ORr,ORrw,1);
  ORrw.GroupOrdRow = prevCredHistr.RecordNr;
  ORrw.RowOrderType = prevCredHistr.RecordType;
  ORrw.PickingDate = prevCredHistr.PayDate;
  ORrw.PlanShipRowDate = prevCredHistr.TransDate;
  ORrw.InloadingDate = prevCredHistr.CredFromDate;
  ORrw.DespatchRowDate = prevCredHistr.CredToDate;
  ORrw.rowGP = balance;
  ORrw.CUServiceHistNr = prevCredHistr.SerNr;
  if (prevCredHistr.RecordType==kCredHistRecTypeInvoice) then begin
    IVr.SerNr = prevCredHistr.RecordNr;
    if (ReadFirstMain(IVr,1,true)) then begin
      ORrw.Sum = IVr.Sum4;
      ARr.InvoiceNr = IVr.SerNr;
      if (ReadFirstMain(ARr,1,true)) then begin
        ORrw.TAX1Reb = ARr.RVal;
      end;
    end;
  end else begin
    IPr.SerNr = prevCredHistr.RecordNr;
  end;
  MatRowInsert(ORr,0,ORrw);

  return;
end;

global
procedure GetCredManEventList(record CredManVc CredManr,var record ORVc ORr)
begin
  record CredHistVc CredHistr,prevCredHistr;
  Boolean TrHs,firstf;
  val balance;
  
  TrHs = true;
  CredHistr.CredManNr = CredManr.SerNr;
  balance = CredManr.InvSum4;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if (CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      //sortrows
      if (firstf==true and (CredHistr.RecordType!=prevCredHistr.RecordType or CredHistr.RecordNr!=prevCredHistr.RecordNr)) then begin
        AddCredHistToArray(ORr,prevCredHistr,balance);
      end;
      if (CredHistr.RecordType==kCredHistRecTypeInvoice and (CredHistr.ChargeType==kEventTypeIssueInstalment or CredHistr.ChargeType==kEventTypeIssueDeposit)) then begin
        balance = balance - CredHistr.Sum;
      end;
      if (CredHistr.RecordType==4) then begin//partial buyout
        balance = balance - CredHistr.Sum;
      end;
      firstf = true;
      RecordCopy(prevCredHistr,CredHistr);
    end;
  end;
  if (prevCredHistr.SerNr>-1) then begin
    AddCredHistToArray(ORr,prevCredHistr,balance);
  end;

  SortRows(ORr,"PlanShipRowDate",true);

  return;
end;

global
procedure GetCredManEventList2(Longint credmannr,var record ORVc ORr)
begin
  record CredManVc CredManr;

  CredManr.SerNr = credmannr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    GetCredManEventList(CredManr,ORr);
  end;  

  return;
end;

function Boolean BuyerPaidInvoice(record CredManVc CredManr,var Longint ivnr)
begin
  record CredHistVc CredHistr;
  Boolean res,TrHs;
  
//in first version we will assume this invoice has only one item therefore we can check record history only
  TrHs = true;
  while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,TrHs)) begin
    if (CredHistr.RecordType==0 and CredHistr.PaidFlag==1) then begin
      res = true;
      ivnr = CredHistr.RecordNr;
      TrHs = false;
    end;
  end;

  BuyerPaidInvoice = res;
  return;
end;

function Boolean GetFactoringDays(record CredManVc CredManr,var date paydate,var Integer factdays)
begin
  record CredHistVc CredHistr;
  Boolean res;

  paydate = "";
  while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,true)) begin
    if (CredHistr.RecordType==1) then begin
      if (CredHistr.TransDate>paydate) then begin
        paydate = CredHistr.TransDate;
      end;
    end;
  end;

  if (nonblank(paydate)) then begin
    factdays = DateDiff(paydate,CredManr.startDate);
    res = true;
  end;

  GetFactoringDays = res;
  return;
end; 


global
updating procedure GenerateAgreementSchedule(record CredManVc CredManr)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record SMVc SMr;
  row SMVc SMrw;
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt,rw;
  Boolean updf;
  record CredFeesMatrixVc FMr;
  
  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    RecordCopy(oldCSr,CSr);
    rwcnt = MatRowCnt(CSr);
    for (i=rwcnt-1;i>=0;i=i-1) begin
      MatRowDelete(CSr,i);
    end;
    updf = true;
  end else begin
    RecordNew(CSr);
    CSr.CredManNr = CredManr.SerNr;
    CSr.CustCode = CredManr.CustCode;
    CSr.CustName = CredManr.Addr0;
  end;
  CSr.TransDate = CurrentDate;
  CSr.TransTime = CurrentTime;
  BlockLoad(CMb);
  BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,false);

  BuildCredManInfoMatrix(CredManr,CredManPayPlanr,CMb,SMr);

  rwcnt = MatRowCnt(SMr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMr,i,SMrw);
    ClearRow(CSr,CSrw,1);
    CSrw.InvDate = SMrw.TransDate;
    CSrw.PayDate = SMrw.DueDate;
    CSrw.Type = SMrw.RowSimStat;
    if (CSrw.Type==4) then begin
      CSrw.Total = SMrw.CurDebVal;
    end else begin
      CSrw.FromDate = SMrw.Objects;
      CSrw.ToDate = SMrw.Comment;
      CSrw.Principle = SMrw.DebVal;
      CSrw.Interest = SMrw.CredVal;
      CSrw.Fees = SMrw.DebVal2;
      UnpackRowFieldMatrix(SMrw,"FeesMatrix",FMr);
      PackRowFieldMatrix(CSrw,"FeesMatrix",FMr);
      CSrw.Total = CSrw.Principle + CSrw.Interest + CSrw.Fees;
      if (nonblank(SMrw.ExtraComment)) then begin
        CSrw.Invoiced = 1;
        CSrw.InvoiceNr = SMrw.ExtraComment;
      end;
    end;
    MatRowPut(CSr,rw,CSrw);
    rw = rw + 1;
  end;

  if (updf) then begin
    RecordUpdate(oldCSr,CSr,true);
  end else begin
    RecordInsert(CSr,true);
  end;

  return;
end;

global 
updating procedure CheckCredManFinished(Longint credmannr)
begin
  record CMOrderClassBlock OCb;
  record CredManVc CredManr,oldCredManr;
  record RcVc RepSpec;

  CredManr.SerNr = credmannr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    CheckBuyOutAgreement(CredManr,RepSpec);
    if (RepSpec.vals2==0) then begin
      BlockLoad(OCb);
      RecordCopy(oldCredManr,CredManr);
      CredManr.OrderClass = OCb.FinishCredOrderClass;
      RecordUpdate(oldCredManr,CredManr,true);
    end;
  end;
  

  return;
end;
global 
updating procedure CheckCredManFinished2(record IPVc IPr)
begin
  row IPVc IPrw;
  Integer i,rwcnt;
  vector Boolean vCMr;
  record IVVc IVr;

  rwcnt = MatRowCnt(IPr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IPr,i,IPrw);
    IVr.SerNr = IPrw.InvoiceNr;
    if (IPrw.InvoiceNr>0 and ReadFirstMain(IVr,1,true)) then begin
      if (IVr.CustCredManNr>0) then begin
        if (vCMr[IVr.CustCredManNr]==false) then begin
          CheckCredManFinished(IVr.CustCredManNr);
          vCMr[IVr.CustCredManNr] = true;
        end;
      end;
    end;
  end;
  

  return;
end;

global
function val GetCredManItemValue(record IVVc IVr,string item,Boolean setzerof)
begin
  Integer i,rwcnt;
  val res;
  row IVVc IVrw;

  if (setzerof) then begin
    res = 0;
  end;
  
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVrw.ArtCode==item) then begin
      res = res + IVrw.Sum;
    end;
  end;

  GetCredManItemValue = res;
  return;
end;

procedure FillInvoiceData(record IVVc IVr,var record RcVc RepSpec)
begin
  record CYBlock CompYear;
  record CredManSetBlock CMb;
  val t,v,t1,t2,t3,t4;
  val abovehiddenbase,abovehiddenvat;

  BlockLoad(CompYear);

  SumNoDownPay(IVr,t,v,t1,t2,t3,t4);
  GetHiddenInvoiceValues(IVr,abovehiddenbase,abovehiddenvat);

  RepSpec.sStartDate = CurrentDate;//F_DATUM
  RepSpec.f8 = GetCredManNr(IVr.CustCredManNr);//F_NUMMER
  RepSpec.f9 = IVr.OfficialSerNr;
  RepSpec.vals0 = t2;//F_ORGATTBETALA
  RepSpec.f1 = IVr.CurncyCode;//F_VALUTA
  RepSpec.long2 = IVr.SerNr;//F_FAKTURANUMMER
  RepSpec.f2 = CompYear.emailAddr;//F_EGENEMAIL
  RepSpec.f3 = CompYear.Phone;//F_EGENTEL
  RepSpec.f4 = CompYear.CompName;//F_EGETNAMN
  RepSpec.f5 = CompYear.OrgNr;//F_EGETORGNR
  RepSpec.f6 = CompYear.VATNr;//F_EGETMOMSNR
  RepSpec.f7 = CompYear.Addr0;//F_EGENADRESS
  RepSpec.vals4 = abovehiddenbase + abovehiddenvat;
  RepSpec.f10 = IVr.Sum4;

  BlockLoad(CMb);
  RepSpec.vals1 = GetCredManItemValue(IVr,CMb.RateItem,true);
  RepSpec.vals2 = GetCredManItemValue(IVr,CMb.InstalmentItem,true);
  RepSpec.vals3 = GetCredManItemValue(IVr,CMb.LateFeeItem,true);

  return;
end;


global
updating function Boolean Ext_CreateInvoiceText(record IVVc IVr,row MailTextVc MTrw,var record MailVc IVMailr,record Mailr oldMailr)
begin
  record LTxtVc LTxtr;
  Longint pos,l;
  string 255 tstr;
  record RcVc RepSpec;
  area a;
  record Attach2Vc Attachr;
  record RLinkVc RLr;

  FillInvoiceData(IVr,RepSpec);
  
  if (IVMailr.HtmlFlag==0) then begin
    LTxtr.Code = MTrw.FirstTxt;
    if (ReadFirstMain(LTxtr,1,true)) then begin
      ParseTextField(a,LTxtr,RepSpec,"InvLtxtVcReplaceToken");
      l = GetAreaLength(a);
      pos = 0;
      while (pos<l) begin
        tstr = GetStringFromArea(a,pos,255);
        AddToText(tstr,IVMailr); 
        pos = pos+255;
      end;
    end;
  end else begin
    LTxtr.Code = MTrw.FirstTxt;
    if (ReadFirstMain(LTxtr,1,true)) then begin
    if (ReadRecordLink(IVMailr,1,Attachr,RLr)) begin
      RecordRemove(RLr);
    end;
     CopyRecordLinks(LTxtr,IVMailr);
     if (LTxtr.HtmlFlag==1) then begin
        ParseHtmlField(IVMailr,RepSpec,"InvMailVcReplaceToken");
      end;
    end;
  end;

  SetAreaZeroSize(a);
  RecordClear(LTxtr);
  AddToText(MTrw.Header,LTxtr);
  ParseTextField(a,LTxtr,RepSpec,"InvLtxtVcReplaceToken");
  l = GetAreaLength(a);
  pos = 0;
  tstr = "";
  while (pos<l) begin
    tstr = GetStringFromArea(a,pos,255);
    pos = pos+255;
  end;
  IVMailr.Header = tstr;

  RecordUpdate(oldMailr,IVMailr,false);

  Ext_CreateInvoiceText = true;
  return;
end;