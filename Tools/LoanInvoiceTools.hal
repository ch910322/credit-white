external procedure BuildCredManPayPlanCust(record CredManVc,var record CredManPayPlanVc,record CredManSetBlock,Boolean,Boolean);
external procedure BuildCredManPayPlanCust2(record CredManVc,var record CredManPayPlanVc,record CredManSetBlock,Boolean,Boolean,Boolean);
external inner function Boolean PasteCust2InInv(var record IVVc,record LocalMachineBlock,string,Boolean,var string,var string,var string,var string,var string);
remote inner procedure IVVc_PastePayDeal(var record IVVc,string,string);
remote inner procedure IVVc_PasteSalesMan(var record IVVc,string);
external inner function Boolean IVVc_PasteArtCode(var record IVVc,Integer,var string,var string,Boolean,var Integer);
external inner procedure IVDchsum(var record IVVc,Integer);
external inner procedure IVVc_PastePrice(var record IVVc,record IVVc,Integer,var string);
external inner function LongInt DateDiff(Date,Date);
external procedure AddPlannedFees(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,Integer,Integer,Date,var val,var val,Date,Date,Longint,Boolean);
external procedure AddInterest(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,Integer,Date,var val,var val,Date,Date,Longint,Boolean);
external procedure AddInstalmentFixed(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,val,Date,var val,var val,Date,Date);
forward procedure GetCredManEventList2(Longint,var record ORVc);
external inner procedure PasteARPayInIV(record IVVc,row IVVc,Integer);
external updating procedure FindUnpaidCredHist(record IPVc,row IPVc,var array val,Integer);
external inner function Boolean IVVc_PasteSum(var record IVVc,Integer,var Boolean,Integer);
external function Date GetLastInvoiceDate(record CredManVc,Date);
external procedure BuildCredManInfoMatrix(record CredManVc,record CredManPayPlanVc,record CredManSetBlock,var record SMVc);
external inner procedure SumNoDownPay(record IVVc,var val,var val,var val,var val,var val,var val);
external function string 255 GetCredManNr(Longint);
external procedure GetHiddenInvoiceValues(record IVVc,var val,var val);
external inner procedure InvVat(Integer,Integer,Integer,Integer,string,val,var val,var val,var val,var val,var val);
external procedure GenerateAgreementSchedule(record CredManVc,Boolean,Boolean);
external function Boolean BuildCredManInfoMatrixOnSchedule(record CredManVc,record CredManSetBlock,var record SMVc);
external function Boolean GetCredLegalNrLine(string,string,Date,string,string,var row CredLegalInvNrBlock,Integer);
external inner function string 50 NextLegalSerNr(string,LongInt,Date,string,string,string);
external function Boolean CanCreateSingleAgreementInvoice(record CredManVc,var Date);
external inner procedure IPSumup(var record IPVc);
external inner procedure IPVc_PasteRecVal(var record IPVc,Integer);
external inner function Boolean PasteInvIn2IPr(var record IPVc,Integer,Date,var val,Boolean,var Boolean);
external inner function Boolean IPVc_PasteCustCode(var record IPVc,Integer,var LongInt);
external function val FindInvoicePaidAmount_OP(LongInt,LongInt);
external inner procedure IPPastePayMode(var record IPVc);
external inner updating procedure CreateInvoicePdfFile(record IVVc);
external function Boolean CredManPMCodeMatches2(string,record CredManVc,Boolean);
remote procedure CheckBuyOutAgreementCallBack(record RcVc,Integer);
external function Boolean TypeAffectsBalance(Integer);
external function val GetAgreementAmount(record CredManVc);
external inner procedure IVVc_PastePayDeal2(var record IVVc,string,string,Boolean);
external function Boolean FindCredManAcc(record CredManVc,var record CredManAccVc);
external function Boolean IsPartialBuyoutType(Integer);
external function Boolean CredManCanInvoiceOverdues(record CredManVc);
external function val GetCredHistOpenAmount(record CredHistVc,Integer);
external inner function string 60 AddObjectToObjectList(string,string);
external inner function string 255 StrReplace(string,string,string);
external function val GetCredHistOpenValueOnDate(Longint,Date);

enum begin
  kCredHistRecTypeInvoice = 0,
  kCredHistRecTypeReceipt = 1,
  kCredHistRecTypePrepayment = 2,
  kCredHistRecTypeCreditNote = 3
end;

enum begin
  kPlannedFeesMonthly = 0,
  kPlannedFeesOneTime = 1
end;

enum begin
  kEventTypeNone = 0,
  kEventTypeCalcInstalment = 1,
  kEventTypeCalcInterest = 2,
  kEventTypeCalcDeposit = 3,
  kEventTypeCalcFees = 4,
  kEventTypeIssueInstalment = 5,
  kEventTypeIssueInterest = 6,
  kEventTypeIssueDeposit = 7,
  kEventTypeIssueFees = 8,
  kEventTypeIssueLateFees = 9,
  kEventTypePaidInterest = 13,
  kEventTypePaidInstalment = 14,
  kEventTypePaidDeposit = 15,
  kEventTypePaidFees = 16,
  kEventTypeSoldAgreement = 17,
  kEventTypePayout = 18,
  kEventTypePartialBuyout = 19,
end;

enum begin
  kMonthTypeFirst = 0,
  kMonthTypeRegular = 1,
  kMonthTypeLast = 2
end;

function longint MAXLongint(longint a,longint b)
begin
  if (a>b) then begin
    MAXLongint = a;
  end else begin
    MAXLongint = b;
  end;
  return;
end;

global
function string 255 CM_SetCompanyLanguage()
begin
  record CYBlock CYb;
  string 255 oldlang,newlang;
  Integer langmode;

  BlockLoad(CYb);
  oldlang = CurrentLanguage;
  newlang = CYb.LangCode;

  if (oldlang!=newlang and nonblank(newlang)) then begin
    langmode = SetFromString(619,newlang);
    if (langmode>-1) then begin
      SetLangMode(langmode,newlang,0);
    end;
  end;

  CM_SetCompanyLanguage = oldlang;
  return;
end;

global
procedure CM_ResetCompanyLanguage(string oldlang)
begin
  Integer oldlangmode;

  if (nonblank(oldlang) and CurrentLanguage!=oldlang) then begin
    oldlangmode = SetFromString(619,oldlang);
    if (oldlangmode>-1) then begin
      SetLangMode(oldlangmode,oldlang,0);
    end;
  end;

  return;
end;

updating procedure LinkCredManAndInvoice(record IVVc IVr,record CredManVc CredManr)
begin
  
  CreateRecordLink(IVr,CurrentCompany,CredManr,CurrentCompany);

  return;
end;

function Boolean FindInvLegalNrLine(Date invdate,string serie,var row LegalInvNrBlock tLINrbrw)
begin
  record LegalInvNrBlock LINrb;
  row LegalInvNrBlock LINrbrw;
  Integer i,rwcnt;
  Boolean res;

  BlockLoad(LINrb);
  rwcnt = MatRowCnt(LINrb);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(LINrb,i,LINrbrw);
    if (DateInRange(invdate,LINrbrw.PurchDate,LINrbrw.EndDate) and LINrbrw.Serie==serie) then begin
      CopyRow(LINrb,LINrbrw,tLINrbrw);
      i = rwcnt;
      res = true;
    end;
  end;

  FindInvLegalNrLine = res;
  return;
end;

function string 255 GetCredManOfficialSerNr(record IVVc IVr,record CredManVc CredManr,Integer rectype)
begin
  row CredLegalInvNrBlock LegalInvNrrw;
  row LegalInvNrBlock LINrbrw;
  string 255 serie,res;
  
  if (nonblank(CredManr.OfficialSerNr)) then begin
    GetCredLegalNrLine("CredManVc",CredManr.SerNr,CredManr.startDate,CredManr.Type,CredManr.Classifications,LegalInvNrrw,-1);
    ;
    switch (rectype) begin
      case 0:serie = LegalInvNrrw.FirstInvSerie;
      case 1:serie = LegalInvNrrw.RegularInvSerie;
      case 2:
        if (CredManr.UseCompensationInvoices==1) then begin
          serie = LegalInvNrrw.CompensationInvSerie;
        end else begin
          serie = LegalInvNrrw.OverdueInvSerie;
        end;
    end;
    if (FindInvLegalNrLine(IVr.InvDate,serie,LINrbrw)) then begin
      res = NextLegalSerNr("IVVc",IVr.SerNr,IVr.InvDate,LINrbrw.Serie,LINrbrw.TSerStart,LINrbrw.TSerEnd);
    end;
  end;


  GetCredManOfficialSerNr = res;
  return;
end;

function Integer GetInvoiceType(record CredManVc CredManr,Date invdate)
begin
  Integer res;
  
  if (invdate==CredManr.startDate) then begin
    res = 0;
  end else begin
    res = 1;
  end;

  GetInvoiceType = res;
  return;
end;

global
procedure SetupLoanInvoice2(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Date invdate,Date fromdate,Date todate,Boolean sernrf,Boolean forcecustf,string ivno,Integer invtype,Boolean fullf,string paydeal)
begin
  record LocalMachineBlock LMb;
  string 255 warning,errstr,prepstr,invdatewarn,transdatewarn;
  row IVVc IVrw;
  string 255 oldlang;
  record CMInvoicingBlock CIb;
  record CredManAccVc CMAr;
  string 255 del;
  boolean doforcepaydeal;
  
  doforcepaydeal = true;
  BlockLoad(LMb);
  BlockLoad(CIb);
  if (fullf) then begin
    oldlang = CM_SetCompanyLanguage;
  end;

  RecordNew(IVr);
  IVr.CustCredManNr = CredManr.SerNr;
  IVr.TransDate = invdate;//or current date?
  IVr.InvDate = invdate;//from seting?
  IVr.CustCode = CredManr.CustCode;
  PasteCust2InInv(IVr,LMb,"",false,warning,errstr,prepstr,invdatewarn,transdatewarn);
  if (nonblank(paydeal)) then begin
    IVr.PayDeal = paydeal;
  end else begin
    IVr.PayDeal = CredManr.PayDeal;
  end;
  IVVc_PastePayDeal(IVr,"",LMb.DefReturnLocation);
  IVr.SalesMan = CredManr.SalesMan;
  IVVc_PasteSalesMan(IVr,"");
  IVr.CredFromDate = fromdate;
  IVr.CredToDate = todate; 
  if (fullf) then begin
    if (nonblank(ivno)) then begin
      IVr.OfficialSerNr = ivno;
    end else begin
      IVr.OfficialSerNr = GetCredManOfficialSerNr(IVr,CredManr,invtype);
    end;
  end;
  if (sernrf) then begin
    IVr.SerNr = NextSerNr("IVVc",IVr.InvDate,-1,false,"");
  end;

  IVr.CredFromDate = fromdate;
  IVr.CredToDate = todate;
  if (invdate<CredManr.FirstInvDate and blank(fromdate)) then begin//First invoice language
    IVr.LangCode = CredManr.LangCode2;
    if (nonblank(paydeal)) then begin
      IVr.PayDeal = CredManr.PayDeal;
      doforcepaydeal = false;
    end else begin
      if (nonblank(CIb.FirstInvPayDeal)) then begin
        IVr.PayDeal = CIb.FirstInvPayDeal;
        IVVc_PastePayDeal(IVr,"",LMb.DefReturnLocation);
        doforcepaydeal = false;
      end;
    end;
  end else begin
    IVr.LangCode = CredManr.LangCode;
  end;
   if (FindCredManAcc(CredManr,CMAr)) then begin
     IVr.Objects = AddObjectToObjectList(IVr.Objects,CMAr.Objects);
   end;
   IVr.Objects = AddObjectToObjectList(IVr.Objects,CredManr.Objects);
  //we should always have in the plan first row instalment or interest where we have start and end date
  if (CIb.DetailedInvoice==1) then begin
    ClearRow(IVr,IVrw,1);
    if (nonblank(CredManr.OfficialSerNr)) then begin
      IVrw.Spec = CIb.InvoiceCommentStr & USetStr(200080) & CredManr.OfficialSerNr;
    end else begin
      IVrw.Spec = CIb.InvoiceCommentStr & USetStr(200080) & CredManr.SerNr;
    end;
    MatRowPut(IVr,0,IVrw);
    if (nonblank(fromdate)) then begin
      ClearRow(IVr,IVrw,1);
      del = ":";
      if (nonblank(CIb.PeriodDelimiter)) then begin
        del = CIb.PeriodDelimiter;
      end;

      IVrw.Spec = CIb.InvoiceCommentStr & USetStr(200081) & fromdate & del & todate;
      MatRowPut(IVr,1,IVrw);
    end else begin
      ClearRow(IVr,IVrw,1);
      IVrw.Spec = " ";
      MatRowPut(IVr,1,IVrw);      
    end;
    ClearRow(IVr,IVrw,1);
    IVrw.Spec = " ";
    MatRowPut(IVr,MatRowCnt(IVr),IVrw);
  end;
  if ((nonblank(CredManr.ForcePayDeal)) and (doforcepaydeal) and (blank(paydeal))) then begin
    IVr.PayDeal = CredManr.ForcePayDeal;
    IVVc_PastePayDeal(IVr,"",LMb.DefReturnLocation);
  end;
  CM_ResetCompanyLanguage(oldlang);

  return;
end;

global
procedure SetupLoanInvoice(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Date invdate,Date fromdate,Date todate,Boolean sernrf,Boolean forcecustf,string ivno,Integer invtype,Boolean fullf)
begin
  SetupLoanInvoice2(CredManr,CMb,IVr,invdate,fromdate,todate,sernrf,forcecustf,ivno,invtype,fullf,"");
  return;
end;

global
procedure SetupInvoiceRowAndAdd(record CredManVc CredManr,var record IVVc IVr,string item,string itemname,val quant,val price,val reb,Integer chargetype,Longint factinv)
begin
  row IVVc IVrw;
  string 255 inwarning,warning;
  Integer sernrf,rw;
  record IVVc IV2r;
  val bval;
  record CredManAccVc CMAr;
  row CredManAccVc CMArw;
  Integer i,rwcnt;
  

  
  if (price>0 and nonblank(item)) then begin
    rw = MatRowCnt(IVr);
    ClearRow(IVr,IVrw,1);
    IVrw.ArtCode = item;
    IVrw.Quant = quant;
    IVrw.ChargeType = chargetype;
    IVrw.FactoringInvoice = factinv;
    MatRowPut(IVr,rw,IVrw);
    if (IVVc_PasteArtCode(IVr,rw,inwarning,warning,false,sernrf)) then begin    
      IVDchsum(IVr,rw);
    end;
    MatRowGet(IVr,rw,IVrw);
    IVrw.Price = price;
    if (reb>0) then begin
      IVrw.vRebate = reb;
    end else begin
      IVrw.vRebate = bval;//should it be like that? what about discount matrix?
    end;
    MatRowPut(IVr,rw,IVrw);
    IVVc_PastePrice(IVr,IV2r,rw,warning);
    if (nonblank(itemname)) then begin
      MatRowGet(IVr,rw,IVrw);
      IVrw.Spec = itemname;
      MatRowPut(IVr,rw,IVrw);
    end;

    if (chargetype!=17) then begin
      if (FindCredManAcc(CredManr,CMAr)) then begin
        rwcnt = MatRowCnt(CMAr);
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(CMAr,i,CMArw);
          if (CMArw.ArtCode==IVrw.ArtCode) then begin
            MatRowGet(IVr,rw,IVrw);
            IVrw.PeriodCode = CMArw.PeriodCode;
            MatRowPut(IVr,rw,IVrw);
            i = rwcnt;
          end;
        end;
      end;
    end;
  end;

  return;
end;

global
function Boolean InvoiceHasHiddenLine(record IVVc IVr)
begin
  Integer i,rwcnt;
  row IVVc IVrw;
  Boolean res;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVrw.stp==kInvoiceRowTypeHidden) then begin
      res = true;
      i = rwcnt;
    end;
  end;

  InvoiceHasHiddenLine = res;
  return;
end;

procedure AddOverdueComments(var record IVVc IVr,array string lateformula)
begin
  Integer i,rwcnt;
  Boolean hiddenf;
  row IVVc IVrw,hiddenIVrw;
  
  if (!InvoiceHasHiddenLine(IVr)) then begin
    ClearRow(IVr,hiddenIVrw,kInvoiceRowTypeHidden);
    MatRowPut(IVr,MatRowCnt(IVr),hiddenIVrw);
  end;

  rwcnt = MatRowCnt(IVr);
  for (i=0;i<lateformula.length;i=i+1) begin
    ClearRow(IVr,IVrw,1);
    IVrw.Spec = lateformula[i];
    MatRowPut(IVr,rwcnt,IVrw);
    rwcnt = rwcnt + 1;
  end;

  return;
end;

procedure SetOverdueLangCode(var record IVVc IVr, record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  row IVVc IVrw;
  integer i,rwcnt;
  boolean overflag;
  record CredManSetBlock CMb;
  
  blockload(CMb);
  
  rwcnt = matrowcnt(IVr);
  for(i=0;i<rwcnt;i=i+1)begin
    matrowget(IVr,i,IVrw);
    if(IVrw.ArtCode==CMb.LateFeeItem)then begin
      overflag = true;
    end;
  end;
  
  if(overflag)then begin
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      if(nonblank(CMTr.InvOverdLangCode))then begin
        IVr.LangCode = CMTr.InvOverdLangCode;
      end;
    end;
  end;
return;
end;

global
procedure SetupOverdueLangCode(var record IVVc IVr,record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  Boolean serf;
  record CMInvoicingBlock CIb;

  CMTr.Code = CredManr.Type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if (CredManr.UseCompensationInvoices==1) then begin
      if (nonblank(CMTr.CompensLangCode)) then begin
        IVr.LangCode = CMTr.CompensLangCode;
      end;
    end else begin
      if (nonblank(CMTr.OverdueLangCode)) then begin
        IVr.LangCode = CMTr.OverdueLangCode;
      end;
    end;
  end;
  BlockLoad(CIb);
  if (nonblank(CIb.OverduePayTerm)) then begin
    IVr.PayDeal = CIb.OverduePayTerm;
    IVVc_PastePayDeal2(IVr,"","",serf);
  end;  
  return;
end;

global
procedure SetupBuyoutLangCode(var record IVVc IVr,record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;

  CMTr.Code = CredManr.Type;
  if (ReadFirstMain(CMTr,1,true)) then begin
    if (nonblank(CMTr.BuyOutLangCode)) then begin
      IVr.LangCode = CMTr.BuyOutLangCode;
    end;
  end;

  return;
end;



global
procedure AddLateFees(record CredManVc CredManr,record CredManSetBlock CMb,var record IVVc IVr,Integer latedays,val lateamount,array string lateformula)
begin
  val laterate;
  record CMInvoicingBlock CIb;
  Boolean addf;
  record CredManTypeVc CMTr;
  string 255 item;
  
  if (lateamount>0) then begin
    addf = true;
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      if (CMTr.MinOverdueFee>0 and lateamount<CMTr.MinOverdueFee) then begin
        addf = false;
      end;
    end;
    if (addf) then begin
      BlockLoad(CIb);
      item = CMb.LateRateItem;
      if (CredManr.UseCompensationInvoices==1) then begin
        item = CIb.CompensationItem;
      end;
      //SetupInvoiceRowAndAdd(CredManr,IVr,CMb.LateFeeItem,"",1,0,0,kEventTypeIssueLateFees,-1);
      SetupInvoiceRowAndAdd(CredManr,IVr,item,"",1,lateamount,0,kEventTypeIssueLateFees,-1);
      BlockLoad(CIb);
      if (CIb.AddOverdueDetails==1) then begin
        AddOverdueComments(IVr,lateformula);
      end;
    end;
  end;

  return;
end;

function Integer GetMonthDays(Date td)
begin
  Integer res;

  res = DaysInMonth(GetYear(td),GetMonth(td));

  GetMonthDays = res;
  return;
end;

function Longint GetCredManLateFees(record CredManVc CredManr,Date sd,Date ed)
begin
  Boolean TrHs,testf;
  record CredManChangeVc Changer;
  Longint res;

  res = CredManr.LateFeeDays;

  TrHs = true;
  Changer.CredManNr = CredManr.SerNr;
  while (LoopKey("CredManDate",Changer,1,TrHs)) begin
    if (Changer.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      testf = false;
      if (Changer.OKFlag==1 and Changer.LateFeeDays>-1) then begin
        if (DateInRange(sd,Changer.TransDate,Changer.EndDate)) then begin
          testf = true;
        end;
        if (DateInRange(ed,Changer.TransDate,Changer.EndDate)) then begin
          testf = true;
        end;
        if (testf) then begin
          res = Changer.LateFeeDays;
          TrHs = false;
        end;
      end;
    end;
  end;

  GetCredManLateFees = res;
  return;
end;

procedure GetLatePaymentPlan(record CredManVc CredManr,record CredHistVc CredHistr,Date sd,Date temped,Date overduetd,var array val amounts,var array Integer daycnt,var array string period)
begin
  Date tempsd,tempsd2;
  record CredHistVc CredPayr;//CredPayr - same credhistvc register, just for payments
  Integer i,daydiff,daydiff2,daydiff3;
  Boolean TrHs;
  val paysum;
  Longint latefeedays;
  record CMInvoicingBlock CMIb;
  date ed,df;
  string 100 newperiod;
  record IVVc IVr;
  
  blockload(CMIb);
  
  ed = temped;
  if(CMIb.NewCalcForGrace==1)then begin
    if(ed>=currentdate)then begin
      ed = addday(ed,-1);
    end;
  end;
  paysum = CredHistr.Sum;
  tempsd = sd;//this is the start date when this item should have been paid since
  if (nonblank(overduetd)) then begin
    tempsd = overduetd;
  end;
  if (tempsd<=CredHistr.PayDate) then begin
    tempsd = AddDay(CredHistr.PayDate,1);
  end;
  tempsd2 = tempsd;

  /*
  if (CredManr.LateFeeDays>0) then begin
    tempsd = AddDay(tempsd,CredManr.LateFeeDays);
  end;
  */

  latefeedays = GetCredManLateFees(CredManr,tempsd,tempsd);

  ClearArray(amounts);
  ClearArray(period);
  TrHs = true;
  CredPayr.PreviousNr = CredHistr.SerNr;
  while (LoopKey("PreviousNr",CredPayr,1,TrHs)) begin
    if (CredPayr.PreviousNr!=CredHistr.SerNr) then begin
      TrHs = false;
    end else begin
      if (CredPayr.TransDate>CredHistr.PayDate) then begin
        if (CredPayr.TransDate>tempsd and CredPayr.TransDate<=ed) then begin
          daydiff = DateDiff(CredPayr.TransDate,tempsd)+1;//or DateDiff2 to get daydiff+1 days
          daydiff2 = DateDiff(CredPayr.TransDate,CredHistr.PayDate);//or DateDiff2 to get daydiff+1 days
          
          daydiff3 = daydiff;
          df = CredPayr.TransDate;
          if(CMIb.NewCalcForGrace==1)then begin
            if(addday(CredHistr.PayDate,latefeedays)>=addday(CredPayr.TransDate,-daydiff+1))then begin
                daydiff3 = daydiff2;
                df = CredPayr.TransDate;
            end;
          end;
          if (latefeedays<daydiff2) then begin
            for (i=0;i<daydiff3;i=i+1) begin
              amounts[amounts.length] = paysum;
              daycnt[daycnt.length] = GetMonthDays(AddDay(tempsd,i));
              period[period.length] = addday(df,-daydiff3+1) & " - " & df;
            end;
          end;
        end;
        if (CredPayr.TransDate>ed) then begin//no need to continue for later payments
          TrHs = false;
        end else begin
          if (tempsd<CredPayr.TransDate) then begin
            tempsd = AddDay(CredPayr.TransDate,1);
          end;
        end;
      end;
      if (CredPayr.TransDate<=ed) then begin
        paysum = paysum - CredPayr.Sum;
      end;
    end;
  end;
  
  /*if(CMIb.StartDateForOverdue==1)then begin// not work correct
    IVr.SerNr = CredHistr.RecordNr;
    if(readfirstmain(IVr,1,true))then begin
      if(IVr.PayDate<sd)then begin
        tempsd = sd;
      end;
    end;
  end;*/
  
  if (paysum>0 and tempsd<=ed) then begin
    daydiff = DateDiff(ed,tempsd)+1;
    daydiff2 = DateDiff(ed,CredHistr.PayDate);
    
    daydiff3 = daydiff;
    df = ed;
    if(CMIb.NewCalcForGrace==1)then begin
      if(CredManr.LateFeeDays>daydiff2-daydiff)then begin
        daydiff3 = daydiff2;
        df = ed;
      end;   
    end; 
    
    if (CredManr.LateFeeDays<daydiff2) then begin
      for (i=0;i<daydiff3;i=i+1) begin
        logtext(0,CredHistr.RecordNr & " daydiff3 " & daydiff3 & "   " & addday(df,-daydiff3+1) & " -- " & df);
        amounts[amounts.length] = paysum;
        daycnt[daycnt.length] = GetMonthDays(AddDay(tempsd,i));
        period[period.length] = addday(df,-daydiff3+1) & " -- " & df;
      end;
    end;
  end;
  return;
end;


function string 255 replaceOverdueStr(string InvNo, val Value, string Period, integer Days,string Rate, val RowSum)
begin
  record OverdueCalcTextVc OCTr;
  string 255 tstr,txInvNo,txValue,txPeriod,txDays,txRate,txRowSum;
  
  OCTr.Code = "OCTXT";
  readfirstmain(OCTr,1,true);

  txValue = Value;
  if(Value==0)then begin
    txValue = "0.00";
  end;

  txRowSum = RowSum;
  if(RowSum==0)then begin
    txRowSum = "0.00";
  end;
  
  tstr = LineTextGet2(OCTr,0);
  tstr = StrReplace(tstr,"?InvNo?",InvNo);
  tstr = StrReplace(tstr,"?Value?",txValue);
  tstr = StrReplace(tstr,"?Period?",Period);
  tstr = StrReplace(tstr,"?Days?",Days);
  tstr = StrReplace(tstr,"?Rate?",Rate);
  tstr = StrReplace(tstr,"?RowSum?",txRowSum);
  
  replaceOverdueStr = tstr;
return;
end;


global
procedure CheckOverdueInvoicesForItem(record CredManVc CredManr,record CredManSetBlock CMb,val maxmonths,Date invdate,Date prevtd,var Integer latedays,var val lateamount,string item,Date overduetd,var array string lateformula,Integer ratetype)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  array val amounts;
  array Integer daycnt;
  val latefee;
  Integer i,odays,lastdaycnt;
  val overdueprc,lastamount;
  Date mindate;
  record OverdueCalcTextVc OCTr;
  string 255 tstr,rate,invoicenr,lastperiod;
  val rowsum;
  record IVVc IVr;
  array string 30 periods;
  record CMInvoicingBlock CMIb;
  
  blockload(CMIb);
  
  OCTr.Code = "OCTXT";
  readfirstmain(OCTr,1,true);
  
  if (maxmonths>0) then begin
    mindate = AddMonth(invdate,-maxmonths);
  end;
  
  if(nonblankdate(CMIb.OverdueFrom))then begin
    if(mindate<CMIb.OverdueFrom)then begin
      mindate = CMIb.OverdueFrom;
    end;
  end;
  
  overdueprc = CredManr.OverduePercentage;
  if (CredManr.AnnualRate==1) then begin
    //overdueprc = overdueprc/12; overdues should not be affected by annual
  end;
  TrHs = true;
  CredHistr.ArtCode = item;
  CredHistr.CredManNr = CredManr.SerNr;
  while (LoopKey("ArtCode",CredHistr,2,TrHs)) begin
    if (CredHistr.ArtCode!=item or CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      if (blank(mindate) or CredHistr.TransDate>=mindate) then begin
        //Construct an array of days with amount that is over due starting with the first day of period
        GetLatePaymentPlan(CredManr,CredHistr,prevtd,invdate,overduetd,amounts,daycnt,periods);
        lastamount = 0;
        odays = 0;
        lastperiod = "";
        for (i=0;i<amounts.length;i=i+1) begin
          if (ratetype==0) then begin //as default
            latefee = latefee + (amounts[i]*(overdueprc/100));
          end else begin
            latefee = latefee + (amounts[i]*(overdueprc/100)/lastdaycnt);
          end;
          if ((lastamount!=amounts[i] and lastamount>0) or (ratetype==1 and lastdaycnt!=daycnt[i])) then begin
            if (ratetype==0) then begin //as default
              rowsum = lastamount*(overdueprc/100) * odays;
              rate = ValToString((overdueprc/100),M45Val,"",",",0);
              tstr = odays & " Days " &  " - " & item & " - " & lastamount & " * " & rate & "=" & rowsum;
              if(OCTr.UseNewCalc==1)then begin
                invoicenr = "";
                
                if(CredHistr.RecordType==0)then begin
                  if(CredHistr.RecordNr>-1)then begin
                    IVr.SerNr = CredHistr.RecordNr;
                    if(readfirstmain(IVr,1,true))then begin
                      invoicenr = IVr.OfficialSerNr;
                      if(blank(invoicenr))then begin
                        invoicenr = IVr.SerNr;
                      end;
                    end;
                  end;
                end;
                rowsum = lastamount*(overdueprc/100) * odays;
                tstr = replaceOverdueStr(invoicenr,lastamount,lastperiod,odays,rate,rowsum);
              end;
              lateformula[lateformula.length] = tstr;
            end else begin
              invoicenr = "";
              if(CredHistr.RecordType==0)then begin
                if(CredHistr.RecordNr>-1)then begin
                  IVr.SerNr = CredHistr.RecordNr;
                  if(readfirstmain(IVr,1,true))then begin
                    invoicenr = IVr.OfficialSerNr;
                    if(blank(invoicenr))then begin
                        invoicenr = IVr.SerNr;
                      end;
                  end;
                end;
              end;
              rowsum = lastamount * odays*(overdueprc/100)/lastdaycnt;
              rate = ValToString((overdueprc/100),M45Val,"",",",0);
              tstr = odays & " Days " &  " - " & item & " - " & lastamount & " * " & rate & "/" & lastdaycnt & "=" & rowsum;
              if(OCTr.UseNewCalc==1)then begin
                tstr = replaceOverdueStr(invoicenr,lastamount,lastperiod,odays,rate,rowsum);
              end;
              lateformula[lateformula.length] = tstr;
            end;
            odays = 0;
          end;
          odays = odays + 1;
          lastamount = amounts[i];
          lastdaycnt = daycnt[i];
          lastperiod = periods[i];
        end;
        if (odays>0) then begin
          if (ratetype==0) then begin //as default
            invoicenr = "";
            if(CredHistr.RecordType==0)then begin
              if(CredHistr.RecordNr>-1)then begin
                IVr.SerNr = CredHistr.RecordNr;
                if(readfirstmain(IVr,1,true))then begin
                  invoicenr = IVr.OfficialSerNr;
                  if(blank(invoicenr))then begin
                    invoicenr = IVr.SerNr;
                  end;
                end;
              end;
            end;
            rowsum = (lastamount*(overdueprc/100) * odays);
            rate = ValToString((overdueprc/100),M45Val,"",",",0);
            tstr = odays & " Days " &  " - " & item & " - " & lastamount & " * " & rate & "=" & rowsum;
            if(OCTr.UseNewCalc==1)then begin
              tstr = replaceOverdueStr(invoicenr,lastamount,lastperiod,odays,rate,rowsum);
            end;
            lateformula[lateformula.length] = tstr;
          end else begin
            invoicenr = "";
            if(CredHistr.RecordType==0)then begin
              if(CredHistr.RecordNr>-1)then begin
                IVr.SerNr = CredHistr.RecordNr;
                if(readfirstmain(IVr,1,true))then begin
                  invoicenr = IVr.OfficialSerNr;
                  if(blank(invoicenr))then begin
                    invoicenr = IVr.SerNr;
                  end;
                end;
              end;
            end;
            rowsum = (lastamount * odays*(overdueprc/100)/lastdaycnt);
            rate = ValToString((overdueprc/100),M45Val,"",",",0);
            tstr = odays & " Days " &  " - " & item & " - " & lastamount & " * " & rate & "/" & lastdaycnt & "=" & rowsum;
            if(OCTr.UseNewCalc==1)then begin
              tstr = replaceOverdueStr(invoicenr,lastamount,periods[i],odays,rate,rowsum);
            end;
            lateformula[lateformula.length] = tstr;
          end;
        end;
      end;
    end;
  end;

  lateamount = lateamount + latefee;

  return;
end;

procedure GetInvoiceEndPeriod(Longint ivnr, var date res, var date intres)
begin
  record IVVc IVr;

  IVr.SerNr = ivnr;
  if (ReadFirstMain(IVr,1,true)) then begin
    res = IVr.CredToDate;
    intres = IVr.InvDate;
  end;

  if (blank(res)) then begin
    res = IVr.InvDate;
  end;
  
  //GetInvoiceEndPeriod = res;
  return;
end;

procedure GetLastOverdueInvoiceDate(Longint sernr,string item,var date res,var date intres)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  Date td,td1;

  TrHs = true;
  CredHistr.CredManNr = sernr;
  CredHistr.ChargeType = 9;
  while (LoopKey("CredManChargeType",CredHistr,2,TrHs)) begin
    if (CredHistr.ChargeType!=9 or CredHistr.CredManNr!=sernr) then begin
      TrHs = false;
    end else begin
      GetInvoiceEndPeriod(CredHistr.RecordNr,td,td1);
      if (td>res) then begin
        res = td;
      end;
      if (td1>intres) then begin
        intres = td1;
      end;
    end;
  end;

  if (nonblank(res)) then begin
    res = AddDay(res,1);
  end;
  if (nonblank(intres)) then begin
    intres = AddDay(intres,1);
  end;

  //GetLastOverdueInvoiceDate = res;
  return;
end;

global
function Integer GetRateType(record CredManVc CredManr)
begin
  record CredManTypeVc CMTr;
  record CMInvoicingBLock CIb;
  Integer res;

  res = -1;
  
  if (CredManr.OverdueRateType>0) then begin
    res = CredManr.OverdueRateType - 1;
  end else begin
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      if (CMTr.OverdueRateType>0) then begin
        res = CMTr.OverdueRateType - 1;
      end;
    end;
  end;
  if (res==-1) then begin
    BlockLoad(CIb);
    res = CIb.OverdueRateType;
  end;

  GetRateType = res;
  return;
end;

global
procedure GetCredManOverdueInvoices2(record CredManVc CredManr,record CredManSetBlock CMb,Date invdate,Date prevtd,var Integer latedays,var val lateamount,var val lateprincipal,var val lateinterest,var array string lateformula,Boolean paidf,Boolean ignorelastoverduef,var Date calcsd)
begin
  record CMInvoicingBlock CIb;
  record INVc INr;
  Date overduetd,temp_td,intlastdate;
  record CUVc CUr;
  Integer ratetype;
  vector boolean useditems;
  
  ClearStringArray(lateformula);
  latedays = 0;
  lateamount = 0;
  CUr.Code = CredManr.CustCode;
  if (ReadFirstMain(CUr,1,true)) then begin
    if (CUr.InterestFlag==1) then begin
      BlockLoad(CIb);
      temp_td = prevtd;
      if (!paidf) then begin
        temp_td = AddDay(temp_td,1);
      end;

      if (ignorelastoverduef==false) then begin
        GetLastOverdueInvoiceDate(CredManr.SerNr,CMb.LateFeeItem,overduetd,intlastdate);
      end;
      
      if(CIb.StartDateForOverdue)then begin
        intlastdate = overduetd;
      end;
      
      if (nonblank(overduetd)) then begin
        calcsd = overduetd;
      end else begin
        calcsd = prevtd;
      end;
      //we should go through the history and check for late payments
      if (nonblank(CIb.OverdueItemClass)) then begin
        ratetype = GetRateType(CredManr);
        while (LoopKey("DICode:" & CIb.OverdueItemClass,INr,1,true)) begin
          if(useditems[INr.Code]==false)then begin
            useditems[INr.Code] = true;
            CheckOverdueInvoicesForItem(CredManr,CMb,CIb.OverdueMonths,invdate,prevtd,latedays,lateamount,INr.Code,intlastdate,lateformula,ratetype);
          end;
        end;
      end;
      if (nonblank(CMb.RateItem)) then begin
        INr.Code = CMb.RateItem;
        if (ReadFirstMain(INr,1,true)) then begin
          if(useditems[INr.Code]==false)then begin
            useditems[INr.Code] = true;
            CheckOverdueInvoicesForItem(CredManr,CMb,CIb.OverdueMonths,invdate,prevtd,latedays,lateinterest,INr.Code,intlastdate,lateformula,ratetype);
          end;
        end;
      end;
      if (nonblank(CMb.InstalmentItem)) then begin
        INr.Code = CMb.InstalmentItem;
        if (ReadFirstMain(INr,1,true)) then begin
          if(useditems[INr.Code]==false)then begin
            useditems[INr.Code] = true;
            CheckOverdueInvoicesForItem(CredManr,CMb,CIb.OverdueMonths,invdate,prevtd,latedays,lateprincipal,INr.Code,overduetd,lateformula,ratetype);
          end;
        end;
      end;
    end;
  end;
  return;
end;

global
procedure GetCredManOverdueInvoices(record CredManVc CredManr,record CredManSetBlock CMb,Date invdate,Date prevtd,var Integer latedays,var val lateamount,var array string lateformula,Boolean paidf,Boolean ignorelastoverduef,var Date calcsd)
begin
  val lateprincipal,lateinterest;
  
  GetCredManOverdueInvoices2(CredManr,CMb,invdate,prevtd,latedays,lateamount,lateprincipal,lateinterest,lateformula,paidf,ignorelastoverduef,calcsd);
  return;
end;

global
procedure MergeItemsInInvoice(var record IVVc IVr,record CredManVc CredManr)
begin
  Integer i,rwcnt,chargetype;
  row IVVc IVrw;
  vector val vRows;
  array string 255 arr;
  val quant,reb;
  Longint pos,factinv;
  string 255 index,tstr,item;

  
  rwcnt = MatRowCnt(IVr);
  for (i=rwcnt-1;i>=0;i=i-1) begin
    MatRowGet(IVr,i,IVrw);
    if (nonblank(IVrw.ArtCode)) then begin
      index = IVrw.ArtCode & ":" & IVrw.Quant & ":" & IVrw.vRebate & ":" & IVrw.ChargeType & ":" & IVrw.FactoringInvoice;
      vRows[index] = vRows[index] + IVrw.Price;
      MatRowDelete(IVr,i);
    end;
  end;
  GetVectorTags(vRows,arr);
  for (i=0;i<arr.length;i=i+1) begin
    pos = -1;
    GetNextSubstring(arr[i],pos,":",item);
    GetNextSubstring(arr[i],pos,":",tstr);
    quant = StringToVal(tstr,M4Val);
    GetNextSubstring(arr[i],pos,":",tstr);
    reb = StringToVal(tstr,M4Val);
    GetNextSubstring(arr[i],pos,":",tstr);
    chargetype = StringToInt(tstr);
    GetNextSubstring(arr[i],pos,":",tstr);
    factinv = StringToLongint(tstr);
    SetupInvoiceRowAndAdd(CredManr,IVr,item,"",quant,vRows[arr[i]],reb,chargetype,factinv);
  end;

  return;
end;

function Boolean GetNextInvoicableDate(var Date td,var Date prevtd,Date ed,record CredManVc CredManr)
begin
  Boolean res;
  
  prevtd = td;
  td = AddMonth(td,1);
  td.Day = DaysInMonth(td.Year,td.Month);
  if (td<=ed and td<=CredManr.endDate) begin //deal with all the other invoices
    res = true;
  end;

  GetNextInvoicableDate = res;
  return;
end;

function Boolean PMCodeMatches(record CredManVc CredManr,Longint cupnr)
begin
  Boolean res;
  record IPVc IPr;
  record ARPayHistVc ARPayHistr;

  ARPayHistr.CUPNr = cupnr;
  ARPayHistr.FileName = "IPVc";
  if (ReadFirstKey("MainKey",ARPayHistr,2,true)) then begin
    IPr.SerNr = ARPayHistr.SerNr;
    if (ReadFirstMain(IPr,1,true)) then begin
      if (CredManPMCodeMatches2(IPr.PayMode,CredManr,true)) then begin
        res = true;
      end;
    end else begin
      res = true;
    end;
  end else begin
    res = true;
  end;

  PMCodeMatches = res;
  return;
end;

global
procedure CM_AddPrepayments(var record IVVc IVr,record CredManVc CredManr,record CMInvoicingBlock CIb)
begin
  record ARPayVc ARPayr;
  val remval;
  Boolean TrHs;
  row IVVc IVrw;
  record IVVc IV2r;
  string 255 warning;
  Boolean chsum;
  
  if (CIb.AddPrepayments) then begin
    remval = IVr.Sum4;
    TrHs = true;
    ARPayr.CustCode = IVr.CustCode;
    while (LoopKey("CustCode",ARPayr,1,TrHs) and remval>0) begin
      if (ARPayr.CustCode!=IVr.CustCode) then begin
        TrHs = false;
      end else begin
        if (ARPayr.PayDate<=IVr.TransDate) then begin
          if (PMCodeMatches(CredManr,ARPayr.CUPNr)) then begin
            ClearRow(IVr,IVrw,kInvoiceRowTypePrepayment);
            IVrw.Spec = USetStr(1288);
            IVrw.CUPNr = ARPayr.CUPNr;
            PasteARPayInIV(IVr,IVrw,-1);
            MatRowInsert(IVr,0,IVrw);
            if IVVc_PasteSum(IVr,0,chsum,1) then begin 
              if (chsum) then begin
                IVDchsum(IVr,0);
              end;
            end;  
            remval = remval - IVrw.BasePrice;
          end;
        end;
      end;
    end;
  end;

  return;
end;

global
updating procedure StoreLoanInvoice(var record IVVc IVr,record CredManVc CredManr)
begin
  record IVVc oldIVr;
  
  SetOverdueLangCode(IVr,CredManr);
  
  if (IVr.Sum4>0) then begin
    IVr.SerNr = NextSerNr("IVVc",IVr.InvDate,-1,false,"");
    if (RecordInsert(IVr,true)) then begin
      RecordCopy(oldIVr,IVr);
      IVr.OKFlag = 1;
      LinkCredManAndInvoice(IVr,CredManr);
      if (RecordUpdate(oldIVr,IVr,true)==0) then begin
        CreateInvoicePdfFile(IVr);
      end;
    end;
  end;

  return;
end;

global
procedure CheckAndAddHiddenPrinciple(var record IVVc IVr,record CMInvoicingBlock CIb)
begin
  row IVVc IVrw,hiddenIVrw;
  Integer i,rwcnt;
  Boolean foundf;
  
  if (CIb.HiddenPrinciple==1) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.ChargeType>0 and IVrw.ChargeType!=kEventTypeCalcInstalment) then begin
        foundf = true;
        i = rwcnt;
      end;
    end;
    if (foundf) then begin
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        if (IVrw.ChargeType==kEventTypeCalcInstalment) then begin
          MatRowDelete(IVr,i);
          if (InvoiceHasHiddenLine(IVr)==false) then begin
            ClearRow(IVr,hiddenIVrw,kInvoiceRowTypeHidden);
            MatRowPut(IVr,MatRowCnt(IVr),hiddenIVrw);
          end;
          MatRowPut(IVr,MatRowCnt(IVr),IVrw);
          goto LCheckAndAddHiddenPrinciple;
        end;
      end;
    end;
  end;

LCheckAndAddHiddenPrinciple:;
  return;
end;

function val GetPaidAmountRatio(record CredManVc CredManr,Date td)
begin
  val res;
  record OPrsVc OPrsr;
  Boolean TrHs;
  val paid;
  
  res = 1;

  if (CredManr.VINr>0) then begin
    OPrsr.TransType = kOPrsTransTypePayment;
    OPrsr.TransDate = CredManr.startDate;
    OPrsr.VINr = CredManr.VINr;
    TrHs = true;
    while (LoopKey("VIKey",OPrsr,3,TrHs)) begin
      if (OPrsr.TransDate>td or OPrsr.VINr!=CredManr.VINr or OPrsr.TransType!=kOPrsTransTypePayment) then begin
        TrHs = false;
      end else begin
        paid = paid + FindInvoicePaidAmount_OP(OPrsr.VINr,OPrsr.TransNr);
      end;
    end;
    res = paid/CredManr.InvSum4;
    
  end;

  GetPaidAmountRatio = res;
  return;
end;

global
function Integer GetInterestPaymentType(record CredManVc CredManr)
begin
  record CMInvoicingBlock CIb;
  record CredManTypeVc CMTr;
  Integer res;

  res = CredManr.RealInterestFlag-1;
  if (res==-1) then begin
    CMTr.Code = CredManr.Type;
    if (ReadFirstMain(CMTr,1,true)) then begin
      res = CMTr.RealInterestFlag-1;
    end;
  end;

  if (res==-1) then begin
    BlockLoad(CIb);
    res = CIb.RealInterestFlag;
  end;
  GetInterestPaymentType = res;
  return;
end;

function Boolean CanInvoiceDate(record CredManVc CredManr,Date td,Boolean allf,Boolean startfullf)
begin
  Boolean res;
  
  if (allf) then begin
    res = true;
  end;

  if (!allf and !startfullf) then begin
    if (td<CredManr.FirstInvDate) then begin
      res = true;
    end;
  end;

  CanInvoiceDate = res;
  return;
end;  

updating procedure CreateInvoicesFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date ed,var record IVVc firstIVr,string ivno,Boolean manualf,Boolean allf)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  Date lastd,lastd2;
  record IVVc IVr,oldIVr,oIVr;
  Boolean firstf,startfullf;
  Integer latedays;
  val lateamount;
  record CMInvoicingBlock CIb;
  array string 255 lateformula;
  Date calcsd;
  
  BlockLoad(CIb);
  lastd2 = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (nonblank(CredManPayPlanrw.FromDate)) then begin
      startfullf = true;
    end;
    if (CredManPayPlanrw.PlanType<=4 and CredManPayPlanrw.TransDate<=ed and CanInvoiceDate(CredManr,CredManPayPlanrw.TransDate,allf,startfullf)) then begin
      if (lastd!=CredManPayPlanrw.TransDate) then begin
        //Setup new invoice
        if (nonblank(lastd)) then begin
          //if (IVr.InvDate==CredManr.startDate) then begin
            MergeItemsInInvoice(IVr,CredManr);
          //end;
          if (CredManCanInvoiceOverdues(CredManr)) then begin
            GetCredManOverdueInvoices(CredManr,CMb,lastd,lastd2,latedays,lateamount,lateformula,false,false,calcsd);
            switch (CIb.OverdueIVType) begin
              case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
              case 1: 
                SetupLoanInvoice(CredManr,CMb,oIVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno,2,true);
                SetupOverdueLangCode(IVr,CredManr);
                AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
                StoreLoanInvoice(oIVr,CredManr);
              case 2:
                if (nonblank(CredManr.CancelDate)) then begin
                  SetupLoanInvoice(CredManr,CMb,oIVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno,2,true);
                  SetupOverdueLangCode(IVr,CredManr);
                  AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
                  StoreLoanInvoice(oIVr,CredManr);
                end;
            end;
          end;
          CM_AddPrepayments(IVr,CredManr,CIb);
          if (IVr.SerNr>-1) then begin
            CheckAndAddHiddenPrinciple(IVr,CIb);
            if (manualf) then begin
              IVr.ManualInvoice = 1;
            end;
            StoreLoanInvoice(IVr,CredManr);
            //if (firstf==false) then begin
              RecordCopy(firstIVr,IVr);
            //  firstf = true;
            //end;
          end else begin
            LogText(0,"Failed to store Invoice. No Serial Number. Check Number Series. Not continuing to generate invoices");  
            goto lout;    
          end;
        end;
        lastd2 = AddDay(lastd,1);//to get the start date for penalty calculation.
        lastd = CredManPayPlanrw.TransDate;
        SetupLoanInvoice(CredManr,CMb,IVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno,GetInvoiceType(CredManr,lastd),true);

      end;
/* not needed. this is done when creating the actual plan
      if (CredManPayPlanrw.PlanType==kEventTypeCalcInterest) then begin
        if (CredManr.RealInterestFlag==1) then begin
          CredManPayPlanrw.Sum = CredManPayPlanrw.Sum*GetPaidAmountRatio(CredManr,IVr.InvDate);
        end;
      end;
*/
      SetupInvoiceRowAndAdd(CredManr,IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);

    end;
    if (CredManPayPlanrw.TransDate>ed) then begin
      i = rwcnt;
    end;
  end;
  if (nonblank(lastd)) then begin
    MergeItemsInInvoice(IVr,CredManr);
    if (CredManCanInvoiceOverdues(CredManr)) then begin
      GetCredManOverdueInvoices(CredManr,CMb,lastd,lastd2,latedays,lateamount,lateformula,false,false,calcsd);
      switch (CIb.OverdueIVType) begin
        case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
        case 1: 
          SetupLoanInvoice(CredManr,CMb,oIVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,true,false,ivno,2,true);
          AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
          SetupOverdueLangCode(IVr,CredManr);
          StoreLoanInvoice(oIVr,CredManr);
      end;
    end;
    CM_AddPrepayments(IVr,CredManr,CIb);
    if (IVr.SerNr>-1) then begin
      CheckAndAddHiddenPrinciple(IVr,CIb);
      if (manualf) then begin
        IVr.ManualInvoice = 1;
      end;
      StoreLoanInvoice(IVr,CredManr);
      //if (firstf==false) then begin
        RecordCopy(firstIVr,IVr);
      //end;
    end else begin
      LogText(0,"Failed to store Invoice. No Serial Number. Check Number Series");
    end;
  end;

lout:;
  return;
end;

global
procedure TestCredManInvoicesFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date ed,var array record IVVc aIVr)
begin
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  Date lastd,lastd2;
  record IVVc IVr;
  Boolean firstf;
  Integer latedays;
  val lateamount;
  array string 255 lateformula;
  transaction Boolean gSilenceIVOpenPrepExists;

  gSilenceIVOpenPrepExists = true;
  lastd2 = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.PlanType<=4) then begin// and CredManPayPlanrw.TransDate<=ed
      if (lastd!=CredManPayPlanrw.TransDate) then begin
        //Setup new invoice
        if (nonblank(lastd)) then begin
          aIVr[aIVr.length] = IVr;
        end;
        lastd2 = AddDay(lastd,1);//to get the start date for penalty calculation.
        lastd = CredManPayPlanrw.TransDate;
        SetupLoanInvoice(CredManr,CMb,IVr,lastd,CredManPayPlanrw.FromDate,CredManPayPlanrw.ToDate,false,false,"",-1,false);

      end;
      //skip late fees here?? 
      if (CredManPayPlanrw.PlanType!=9) then begin
        SetupInvoiceRowAndAdd(CredManr,IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);
      end;

    end;
    if (CredManPayPlanrw.TransDate>ed) then begin
      i = rwcnt;
    end;
  end;
  if (nonblank(lastd)) then begin
    aIVr[aIVr.length] = IVr;
  end;
  gSilenceIVOpenPrepExists = false;

  return;
end;

global
procedure GetItemName(string code,var string spec)
begin
  record INVc INr;

  INr.Code = code;
  ReadFirstMain(INr,1,true);
  spec = INr.Name;

  return;
end;

procedure BuildInvoiceBasedOnSchedule(record CredManVc CredManr,row CredManSchedVc CSrw,record CredManSetBlock CMb,record CMApplicationSetBlock ASb,Date lastd,var record IVVc IVr,Boolean updf,Boolean addfeesf)
begin
  Integer latedays;
  val lateamount;
  string 255 spec;
  record CMInvoicingBlock CIb;
  record IVVc oIVr;
  array string 255 lateformula;
  record CredFeesMatrixVc FMr;
  row CredFeesMatrixVc FMrw;
  Integer i,rwcnt;
  Date calcsd;

  BlockLoad(CIb);
  RecordClear(IVr);
  RecordNew(IVr);
  SetupLoanInvoice(CredManr,CMb,IVr,CSrw.InvDate,CSrw.FromDate,CSrw.ToDate,true,false,"",GetInvoiceType(CredManr,CSrw.InvDate),updf);
  if (CSrw.Principle>0) then begin
    GetItemName(CMb.RateItem,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CMb.InstalmentItem,spec,1,CSrw.Principle,blankval,kEventTypeCalcInstalment,-1);
  end;
  if (CSrw.Deposit>0) then begin
    GetItemName(CMb.DepositItem,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CMb.DepositItem,spec,1,CSrw.Deposit,blankval,kEventTypeCalcInstalment,-1);
  end;
  if (CSrw.Interest>0) then begin
    GetItemName(CMb.RateItem,spec);
    if (CredManr.RealInterestFlag==1) then begin
//      CSrw.Interest = CSrw.Interest*GetPaidAmountRatio(CredManr,IVr.InvDate);
    end;
    SetupInvoiceRowAndAdd(CredManr,IVr,CMb.RateItem,spec,1,CSrw.Interest,blankval,kEventTypeCalcInterest,-1);
  end;
  if (CSrw.Fees>0) then begin
    UnpackRowFieldMatrix(CSrw,"FeesMatrix",FMr);
    rwcnt = MatRowCnt(FMr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(FMr,i,FMrw);
      GetItemName(FMrw.ArtCode,spec);
      SetupInvoiceRowAndAdd(CredManr,IVr,FMrw.ArtCode,spec,1,FMrw.Sum,blankval,kEventTypeCalcFees,-1);
    end;
  end;
  if (updf) then begin
    MergeItemsInInvoice(IVr,CredManr);
  end;
  if (addfeesf and CredManCanInvoiceOverdues(CredManr)) then begin
    GetCredManOverdueInvoices(CredManr,CMb,CSrw.InvDate,lastd,latedays,lateamount,lateformula,false,false,calcsd);
    switch (CIb.OverdueIVType) begin
      case 0: AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
      case 1: 
        SetupLoanInvoice(CredManr,CMb,oIVr,CSrw.InvDate,CSrw.FromDate,CSrw.ToDate,true,false,"",2,true);
        SetupOverdueLangCode(IVr,CredManr);
        AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
        if (updf) then begin
          qupdating.StoreLoanInvoice(oIVr,CredManr);
        end;
      case 2:
        if (nonblank(CredManr.CancelDate)) then begin
          SetupLoanInvoice(CredManr,CMb,oIVr,CSrw.InvDate,CSrw.FromDate,CSrw.ToDate,true,false,"",2,true);
          SetupOverdueLangCode(IVr,CredManr);
          AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
          if (updf) then begin
            qupdating.StoreLoanInvoice(oIVr,CredManr);
          end;
        end;
    end;
  end;
  
  if (updf) then begin
    CM_AddPrepayments(IVr,CredManr,CIb);
    CheckAndAddHiddenPrinciple(IVr,CIb);
  end;

  return;
end;

function Integer InvoiceTypeFromSchedule(record CredManVc CredManr,row CredManSchedVc CSrw)
begin
  Integer res;

  res = 1;
  if (CredManr.FirstInvDate>CSrw.InvDate) then begin
    if (CSrw.Deposit==0 and CSrw.Interest==0 and CSrw.Principle==0 and CSrw.Fees!=0) then begin
      res = 0;
    end;
  end;

  InvoiceTypeFromSchedule = res;
  return;
end;

updating function Boolean CreateInvoiceBasedOnSchedule(record CredManVc CredManr,Date ed,var record IVVc firstIVr,Boolean manualf,Boolean allf)
begin
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw,lastCSrw;
  Integer i,rwcnt,rw;
  record IVVc IVr,oldIVr;
  record CredManSetBlock CMb;
  record CMApplicationSetBlock ASb;
  record CMInvoicingBlock CIb;
  Date lastd;
  Boolean firstf;
  Boolean res;
  record CredManTypeVc CMTr;
  val totdays,useddays;
  val ratio;
  Boolean testf;

  Date ted,sd,invdat2;
  Integer latedays;
  val lateamount;
  Boolean addf,startfullf;
  array string 255 lateformula;
  Date calcsd;

  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    res = true;
    BlockLoad(CMb);
    BlockLoad(ASb);
    BlockLoad(CIb);
    lastd = CredManr.FirstInvDate;
    rwcnt = MatRowCnt(CSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CSr,i,CSrw);
      testf = false;
      if (nonblank(CSrw.FromDate)) then begin
        startfullf = true;
      end;
      if (CSrw.InvDate<=ed and CSrw.Invoiced==0 and CanInvoiceDate(CredManr,CSrw.InvDate,allf,startfullf)) then begin
        testf = true;
      end;
      if (nonblank(CredManr.CancelDate) and CSrw.Invoiced==0) then begin
        if (lastCSrw.InvDate<ed and CSrw.InvDate>=ed) then begin
          testf = true;
          useddays = DateDiff(ed,CSrw.FromDate) + 1;
          totdays = DateDiff(CSrw.ToDate,CSrw.FromDate) + 1;
          ratio = useddays/totdays;
          CSrw.Principle = CSrw.Principle*ratio;
          CSrw.Interest = CSrw.Interest*ratio;
          CSrw.ToDate = ed;
          CSrw.InvDate = ed;
        end;
      end;      
      if (testf) then begin
        BuildInvoiceBasedOnSchedule(CredManr,CSrw,CMb,ASb,lastd,IVr,true,true);
        if (IVr.SerNr>-1) then begin
          if (manualf) then begin
            IVr.ManualInvoice = 1;
          end;
          StoreLoanInvoice(IVr,CredManr);
          //if (firstf==false) then begin
            RecordCopy(firstIVr,IVr);
          //  firstf = true;
          //end;
        end;
      end else begin
        if (CSrw.InvDate>ed) then begin
          i = rwcnt;
        end;
      end;
      lastd = AddDay(CSrw.InvDate,1);
      CopyRow(CSr,CSrw,lastCSrw);
    end;
    if (CIb.OverdueIVType==2 and GetDay(CurrentDate)==CIb.OverdueIVDay) then begin
      ted = CurrentDate;
      ted.Day = 1;
      sd = AddMonth(ted,-1);
      ted = AddDay(ted,-1);
      invdat2 = CurrentDate;
      GetCredManOverdueInvoices(CredManr,CMb,ted,sd,latedays,lateamount,lateformula,false,false,calcsd);
      addf = true;
      CMTr.Code = CredManr.Type;
      if (ReadFirstMain(CMTr,1,true)) then begin
        if (CMTr.MinOverdueFee>0 and lateamount<CMTr.MinOverdueFee) then begin
          addf = false;
        end;
      end;
      if (addf) then begin
        SetupLoanInvoice(CredManr,CMb,IVr,invdat2,sd,ted,true,false,"",2,true);
        SetupOverdueLangCode(IVr,CredManr);
        AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
        StoreLoanInvoice(IVr,CredManr);
        //if (firstf==false) then begin
          RecordCopy(firstIVr,IVr);
        //  firstf = true;
        //end;
      end;
    end;
  end;
  CreateInvoiceBasedOnSchedule = res;
  return;
end;

global
procedure TestInvoiceBasedOnSchedule(record CredManVc CredManr,record CredManSchedVc CSr,Date ed,var array record IVVc aIVr)
begin
  row CredManSchedVc CSrw;
  Integer i,rwcnt,rw;
  record IVVc IVr,oldIVr;
  record CredManSetBlock CMb;
  record CMApplicationSetBlock ASb;
  Date lastd;
  Boolean firstf;
  Boolean res;
  
  BlockLoad(CMb);
  BlockLoad(ASb);
  lastd = CredManr.FirstInvDate;
  rwcnt = MatRowCnt(CSr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CSr,i,CSrw);
    if (CSrw.InvDate<=ed and CSrw.Invoiced==0) then begin
      BuildInvoiceBasedOnSchedule(CredManr,CSrw,CMb,ASb,lastd,IVr,false,false);
      aIVr[aIVr.length] = IVr;
    end else begin
      if (CSrw.InvDate>ed) then begin
        i = rwcnt;
      end;
    end;
    lastd = AddDay(CSrw.InvDate,1);
  end;

  return;
end;

global
procedure TestInvoiceBasedOnScheduleRow(record CredManSchedVc CSr,row CredManSchedVc CSrw,var record IVVc IVr)
begin
  record CredManSetBlock CMb;
  record CMApplicationSetBlock ASb;
  Date lastd;
  Boolean firstf;
  Boolean res;
  record CredManVc CredManr;
  transaction Boolean gSilenceIVOpenPrepExists;
  
  BlockLoad(CMb);
  BlockLoad(ASb);
  CredManr.SerNr = CSr.CredManNr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    gSilenceIVOpenPrepExists = true;
    BuildInvoiceBasedOnSchedule(CredManr,CSrw,CMb,ASb,"",IVr,false,false);
    gSilenceIVOpenPrepExists = false;
  end;

  return;
end;


global
updating procedure CreateSingleAgreementInvoice2(record CredManVc CredManr,Date ed,var record IVVc IVr,string ivno,Boolean manualf,Boolean allf)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  string 255 oldlang;

  if (CanCreateSingleAgreementInvoice(CredManr,ed)) then begin
    oldlang = CM_SetCompanyLanguage;
    if (CreateInvoiceBasedOnSchedule(CredManr,ed,IVr,manualf,allf)==false) then begin
      BlockLoad(CMb);
      BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
      CreateInvoicesFromPlan(CredManr,CMb,CredManPayPlanr,ed,IVr,ivno,manualf,allf);
    end;
    CM_ResetCompanyLanguage(oldlang);
  end;

  return;
end;

global
updating procedure CreateSingleAgreementInvoice(record CredManVc CredManr,Date ed,var record IVVc IVr,string ivno,Boolean manualf)
begin

  CreateSingleAgreementInvoice2(CredManr,ed,IVr,ivno,manualf,true);

  return;
end;

function val GetBuyOutFee(record CredManVc CredManr,Date td,val balance)
begin
  val res;
  val rate;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt,cnt;
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record SMVc SMr;
  row SMVc SMrw;

  rate = CredManr.BuyoutFeePrc;
  res = (balance) *(rate/100);
  res = res + CredManr.BuyoutFeeFixed;

  if (CredManr.BuyoutFeeMonths>0) then begin
    CSr.CredManNr = CredManr.SerNr;
    if (ReadFirstMain(CSr,1,true)) then begin
      rwcnt = MatRowCnt(CSr);
      cnt = CredManr.BuyoutFeeMonths;
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CSr,i,CSrw);
        if (CSrw.InvDate>td and cnt>0) then begin
          res = res + CSrw.Interest;
          cnt = cnt - 1;
        end;
        if (cnt<=0) then begin
          i = rwcnt;
        end;
      end;

    end else begin
      BlockLoad(CMb);
      if (BuildCredManInfoMatrixOnSchedule(CredManr,CMb,SMr)==false) then begin
        BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
        BuildCredManInfoMatrix(CredManr,CredManPayPlanr,CMb,SMr);
      end;
      rwcnt = MatRowCnt(SMr);
      cnt = CredManr.BuyoutFeeMonths;
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(SMr,i,SMrw);
        if (SMrw.TransDate>td and cnt>0) then begin
          res = res + SMrw.CredVal;
          cnt = cnt - 1;
        end;
        if (cnt<=0) then begin
          i = rwcnt;
        end;
      end;
    end;
  end;

  GetBuyOutFee = res;
  return;
end;

global
procedure AddBuyOutFee(record CredManVc CredManr,var record IVVc IVr,val balance)
begin
  record CMInvoicingBlock CIb;
  string 255 spec;
  val buyoutfee;
  
  BlockLoad(CIb);
  buyoutfee = GetBuyOutFee(CredManr,IVr.InvDate,balance);
  GetItemName(CIb.BuyOutItem,spec);
  if (nonblank(CIb.BuyOutItem) and buyoutfee>0) then begin
    SetupInvoiceRowAndAdd(CredManr,IVr,CIb.BuyOutItem,spec,1,buyoutfee,blankval,15,-1);
  end;

  return;
end;

global
procedure AddInsuranceCost(record CredManVc CredManr,var record IVVc IVr,record CMInvoicingBlock CIb)
begin
  string 255 spec;
  val buyoutfee;
  
  if (nonblank(CIb.LetterOfDemand) and CredManr.LetterOfDemand>0) then begin
    GetItemName(CIb.LetterOfDemand,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CIb.LetterOfDemand,spec,1,CredManr.LetterOfDemand,blankval,15,-1);
  end;
  if (nonblank(CIb.InsuranceCost) and CredManr.InsuranceCost>0) then begin
    GetItemName(CIb.InsuranceCost,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,CIb.InsuranceCost,spec,1,CredManr.InsuranceCost,blankval,15,-1);
  end;

  return;
end;

global
procedure GetBuyOutData(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,record CredManSetBlock CMb,var Date lastinv,var val balance)
begin
  record CredHistVc CredHistr;
  Boolean foundf;
  Integer i,rwcnt;
  row CredManPayPlanVc CredManPayPlanrw;
  val curbal;
  Boolean stopf;
 
  if (GetInterestPaymentType(CredManr)==2) then begin
    curbal = 0;
  end else begin
    curbal = CredManr.InvSum4;
  end;

  lastinv = CredManr.startDate;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayPlanrw);
    if (CredManPayPlanrw.PlanType<=4) then begin
      stopf = true;
    end else begin
      if (stopf==false or CredManPayPlanrw.PlanType==18) then begin
        CredHistr.SerNr = CredManPayPlanrw.IssuedNr;
        if (ReadFirstMain(CredHistr,1,true)) then begin
          if (CredManPayPlanrw.ArtCode!=CMb.LateFeeItem and CredManPayPlanrw.ArtCode!=CMb.LateRateItem and (CredHistr.RecordType==0 or CredHistr.RecordType==4 or CredHistr.RecordType==5)) then begin
            if (TypeAffectsBalance(CredHistr.ChargeType)) then begin
              curbal = curbal - CredHistr.Sum;
            end;
            if (CredHistr.ChargeType==kEventTypePayout) then begin
              curbal = curbal + CredHistr.Sum;
            end;
            balance = curbal;
            foundf = true;
            if (CredHistr.RecordType==0 and CredHistr.CredToDate>lastinv) then begin
              lastinv = AddDay(CredHistr.CredToDate,1);
            end;
          end;
        end;
      end;
    end;
  end;
  if (!foundf) then begin
    balance = CredManr.InvSum4;
  end;

  return;
end;

procedure CreateBuyOutInvoiceFromPlan(record CredManVc CredManr,record CredManSetBlock CMb,record CredManPayPlanVc CredManPayPlanr,Date td,var record IVVc IVr,BOolean testf,var Date sd,Boolean balancef)
begin
  row CredManPayPlanVc CredManPayPlanrw;
  record CredManPayPlanVc CredManPayPlan2r;
  val balance,tval;
  Date lastinv;
  Integer i,rwcnt;
  Integer latedays;
  val lateamount;
  val cumint,calcbal;
  array string 255 lateformula;
  record CredManVc tCredManr;
  record CMInvoicingBlock CIb;
  Date calcsd;

/*
1. Get the last invoice date and the balance
2. Set up and create an invoice
*/ 
  BlockLoad(CIb);
  GetBuyOutData(CredManr,CredManPayPlanr,CMb,lastinv,balance);

  if (balance>0) then begin
    SetupLoanInvoice2(CredManr,CMb,IVr,td,lastinv,td,true,false,"",1,true,CIb.BuyOutPayDeal);
    AddInstalmentFixed(CredManr,CredManPayPlan2r,CMb,balance,td,cumint,calcbal,lastinv,td);
    RecordCopy(tCredManr,CredManr);
    tCredManr.InvSum4 = balance;
    tCredManr.DepositSum = 0;
    tval = GetAgreementAmount(CredManr);
    AddInterest(tCredManr,CredManPayPlan2r,CMb,kMonthTypeFirst,td,cumint,balance,lastinv,td,-1,true);
    AddPlannedFees(CredManr,CredManPayPlan2r,CMb,kPlannedFeesMonthly,kMonthTypeFirst,td,cumint,tval,lastinv,td,-1,false);
    rwcnt = MatRowCnt(CredManPayPlan2r);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CredManPayPlan2r,i,CredManPayPlanrw);
      SetupInvoiceRowAndAdd(CredManr,IVr,CredManPayPlanrw.ArtCode,CredManPayPlanrw.Spec,1,CredManPayPlanrw.Sum,CredManPayPlanrw.Reb,CredManPayPlanrw.PlanType,CredManPayPlanrw.FactoringInvoice);
    end;
    if (balancef==false) then begin
      AddBuyOutFee(CredManr,IVr,balance);
    end;
    AddInsuranceCost(CredManr,IVr,CIb);
    GetCredManOverdueInvoices(CredManr,CMb,td,lastinv,latedays,lateamount,lateformula,true,false,calcsd);
    if (testf or CIb.OverdueIVType==0) then begin
      AddLateFees(CredManr,CMb,IVr,latedays,lateamount,lateformula);
    end else begin
      sd = calcsd;
    end;
  end;

  return;
end;

global
updating procedure CreateProlongInvoice(record CredManVc CredManr,var record IVVc nIVr)
begin
  record CMInvoicingBlock CIb;
  record CredManSetBlock CMb;
  record IVVc IVr,oldIVr;
  val rate,sum;
  string 255 spec;

  BlockLoad(CIb);
  BlockLoad(CMb);

  SetupLoanInvoice(CredManr,CMb,IVr,CurrentDate,"","",true,false,"",1,true);
  rate = CredManr.StdProlongPrc;
  if (CredManr.AnnualRate==1) then begin
    rate = rate/12;
  end;
  sum = (CredManr.InvSum4 - CredManr.DepositSum) *(rate/100);
  sum = sum + CredManr.StdProlongFee;
  GetItemName(CIb.ProlongItem,spec);
  SetupInvoiceRowAndAdd(CredManr,IVr,CIb.ProlongItem,spec,1,sum,blankval,14,-1);
  CM_AddPrepayments(IVr,CredManr,CIb);

  StoreLoanInvoice(IVr,CredManr);
  if (IVr.SerNr>0) then begin
    RecordCopy(nIVr,IVr);
  end;

  return;
end;


global
updating procedure CreateManualExtraInvoice(record RcVc RepSpec,var record IVVc IVr)
begin
  record CMInvoicingBlock CIb;
  record CredManSetBlock CMb;
  record IVVc oldIVr;
  val rate,sum;
  string 255 spec;
  record CredManVc CredManr;

  CredManr.SerNr = RepSpec.long1;
  if (ReadFirstMain(CredManr,1,true)) then begin
    BlockLoad(CIb);
    BlockLoad(CMb);

    SetupLoanInvoice(CredManr,CMb,IVr,RepSpec.d1,"","",true,false,"",1,true);
    GetItemName(RepSpec.f1,spec);
    SetupInvoiceRowAndAdd(CredManr,IVr,RepSpec.f1,spec,1,RepSpec.vals0,blankval,15,-1);
    CM_AddPrepayments(IVr,CredManr,CIb);

    StoreLoanInvoice(IVr,CredManr);
  end;

  return;
end;

global
updating procedure DoBuyOutAgreement(record CredManVc CredManr,Date td,var record IVVc firstIVr)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record IVVc IVr,oldIVr,oIVr;
  record CMInvoicingBlock CIb;
  Date sd;
  val openamount,lateamount;
  Integer latedays;
  array string 255 lateformula;
  Date calcsd;

  if (CredManr.OKFlag==1 and CredManr.Approved==1) then begin
    BlockLoad(CMb);
    BlockLoad(CIb);
    BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
    CreateBuyOutInvoiceFromPlan(CredManr,CMb,CredManPayPlanr,td,IVr,false,sd,false);

    CM_AddPrepayments(IVr,CredManr,CIb);
    if (IVr.SerNr>-1) then begin
      CheckAndAddHiddenPrinciple(IVr,CIb);
      if (IVr.Sum4>0) then begin
        if (CIb.OverdueIVType>0) then begin
          GetCredManOverdueInvoices(CredManr,CMb,td,sd,latedays,lateamount,lateformula,true,false,calcsd);
          SetupLoanInvoice(CredManr,CMb,oIVr,td,calcsd,td,true,false,"",2,true);
          AddLateFees(CredManr,CMb,oIVr,latedays,lateamount,lateformula);
          SetupOverdueLangCode(oIVr,CredManr);
          StoreLoanInvoice(oIVr,CredManr);
        end;
        SetupBuyoutLangCode(IVr,CredManr);
        StoreLoanInvoice(IVr,CredManr);
        GenerateAgreementSchedule(CredManr,true,true);
        RecordCopy(firstIVr,IVr);
      end else begin
        LogText(0,"Failed to store Invoice. Sum is 0");
      end;
    end else begin
      LogText(0,"Failed to store Invoice. No Serial Number. Check Number Series");
    end;
  end;

  return;
end;

procedure CheckUnpaidInvoices(record CredManVc CredManr,var val dueamount,var val openamount)
begin
  record ARVc ARr;
  record IVVc IVr;
  Boolean TrHs;

  dueamount = 0;
  openamount = 0;
  //didn't add a new index in order to save db size. This won't be so expensive.
  
  TrHs = true;
  IVr.CustCode = CredManr.CustCode;
  while (LoopKey("CustCode",IVr,1,TrHs)) begin
    if (IVr.CustCode!=CredManr.CustCode) then begin
      TrHs = false;
    end else begin
      if (IVr.CustCredManNr==CredManr.SerNr) then begin
        ARr.InvoiceNr = IVr.SerNr;
        if (ReadFirstMain(ARr,1,true)) then begin
          if (ARr.DueDate<CurrentDate) then begin
            dueamount = dueamount + ARr.RVal;
          end;
          openamount = openamount + ARr.RVal;
        end;
      end;
    end;
  end;

  return;
end;

global
function val GetActualBalance(record CredManVc CredManr,record CredManPayPlanVc CredManPayPlanr,Boolean openf)
begin
  val res,curbal;
  row CredManPayPlanVc CredManPayrw;
  Integer rwcnt,i;
  val openamount;

  if (GetInterestPaymentType(CredManr)==2) then begin
    curbal = 0;
  end else begin
    curbal = CredManr.InvSum4;
  end;
  rwcnt = MatRowCnt(CredManPayPlanr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(CredManPayPlanr,i,CredManPayrw);
    if (CredManPayrw.PlanType>=5 and CredManPayrw.PlanType!=9) then begin
      if (TypeAffectsBalance(CredManPayrw.PlanType)) then begin
        curbal = curbal - CredManPayrw.Sum;
      end;
      if (CredManPayrw.PlanType==kEventTypePayout) then begin
        curbal = curbal + CredManPayrw.Sum;
      end;
      if (CredManPayrw.PlanType==kEventTypeIssueInstalment or IsPartialBuyoutType(CredManPayrw.PlanType)) then begin
        openamount = openamount + CredManPayrw.OpenAmount;
      end;
    end;
    if (CredManPayrw.PlanType<5) then begin
      i = rwcnt;
    end;
    /*
    if (CredManPayrw.TransDate>=CurrentDate) then begin
      i = rwcnt;
    end;
    */
  end;

  if (openf) then begin
    curbal = curbal + openamount;
  end;

  GetActualBalance = curbal;
  return;
end;

function val GetPrepaymentValue(record CredManVc CredManr)
begin
  record ARPayVc ARPayr;
  Boolean TrHs;
  val res;

  ARPayr.CustCode = CredManr.CustCode;
  TrHs = true;
  while (LoopKey("CustCode",ARPayr,1,TrHs)) begin
    if (ARPayr.CustCode!=CredManr.CustCode) then begin
      TrHs = false;
    end else begin
      if (PMCodeMatches(CredManr,ARPayr.CUPNr)) then begin
        res = res + ARPayr.RVal;
      end;
    end;
  end;

  GetPrepaymentValue = res;
  return;
end;

function val FindUpdaidCredHistType(Longint ivnr)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  val res;
  
  TrHs = true;
  CredHistr.RecordNr = ivnr;
  CredHistr.RecordType = 0;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordNr!=ivnr or CredHistr.RecordType!=0) then begin
      TrHs = false;
    end else begin
      if (CredHistr.ChargeType==kEventTypeIssueInterest and CredHistr.PaidFlag==0) then begin
        res = res + GetCredHistOpenAmount(CredHistr,kEventTypeIssueInterest);
      end;
    end;
  end;

  FindUpdaidCredHistType = res;
  return;
end;

function val GetInterestAmount(record CredManVc CredManr,Date td)
begin
  val res;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt;
  Integer diff,diff2;
  
  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    rwcnt = MatRowCnt(CSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CSr,i,CSrw);
      if (CSrw.FromDate<=td) then begin
        if (CSrw.Interest>0) then begin
          if (CSrw.Invoiced==1) then begin
            res = res + FindUpdaidCredHistType(CSrw.InvoiceNr);
          end else begin
            if (CSrw.ToDate>td) then begin
              diff = DateDiff(CSrw.ToDate,CSrw.FromDate)+1;
              diff2 = DateDiff(td,CSrw.FromDate)+1;
              res = res + CSrw.Interest*diff2/diff;
            end else begin
              res = res + CSrw.Interest;
            end;
          end;
        end;
      end else begin
        i = rwcnt;
      end;
    end;
  end;

  GetInterestAmount = res;
  return;
end;

function val GetCreditedInterest(record CredManVc CredManr,Date td)
begin
  val res;
  record CredManSchedVc CSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt;
  Integer diff,diff2;

  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    rwcnt = MatRowCnt(CSr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(CSr,i,CSrw);
      if (CSrw.FromDate<=td) then begin
        if (CSrw.ToDate>td) then begin
          if (CSrw.Interest>0) then begin
            if (CSrw.Invoiced==1) then begin
              diff = DateDiff(CSrw.ToDate,CSrw.FromDate)+1;
              diff2 = DateDiff(CSrw.ToDate,td)+1;
              res = res + CSrw.Interest*diff2/diff;
            end;
          end;
        end;
      end else begin
        i = rwcnt;
      end; 
    end;
  end;


  GetCreditedInterest = res;
  return;
end;

//same as GetLateDaysInPeriod except returns amounts incl. of VAT
function Integer GetLateDaysInPeriod2(record CredHistVc CredHistr,Date sd,Date ed,var val dueamount)
begin
  Boolean TrHs;
  record CredHistVc CredPayr;
  val paysum;
  Integer res;
  val vatprc,vatval,vatexclprc,vatinclprc,rowtax;
  record IVVc IVr;
  row IVVc IVrw;
  Integer i,rwcnt;
  string 255 vatcode;

  paysum = CredHistr.Sum;
  IVr.SerNr = CredHistr.RecordNr;
  if (ReadFirstMain(IVr,1,true)) then begin
    rwcnt = MatRowCnt(IVr);
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(IVr,i,IVrw);
      if (IVrw.CredHistNr==CredHistr.SerNr) then begin
        //InvVat(1,1,IVr.NoTAXonVAT,IVr.ExportFlag,IVrw.VATCode,CredHistr.Sum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);
        //paysum = paysum - vatval;
        vatcode = IVrw.VATCode;
        i = rwcnt;
      end;
    end;
  end;

  TrHs = true;
  CredPayr.PreviousNr = CredHistr.SerNr;
  while (LoopKey("PreviousNr",CredPayr,1,TrHs)) begin
    if (CredPayr.PreviousNr!=CredHistr.SerNr) then begin
      TrHs = false;
    end else begin
      if (CredPayr.TransDate<=ed) then begin
        InvVat(1,1,IVr.NoTAXonVAT,IVr.ExportFlag,vatcode,CredPayr.Sum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);
        paysum = paysum - (CredPayr.Sum/* - vatval*/);
      end;
    end;
  end;
  if (paysum<0) then begin
    paysum = 0;
  end;
  if (paysum>0) then begin
    res = DateDiff(ed,CredHistr.PayDate);
    InvVat(1,1,IVr.NoTAXonVAT,IVr.ExportFlag,IVrw.VATCode,paysum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);
    paysum = paysum /*- vatval*/; //need amounts incl. of VAT
  end;
  dueamount = dueamount + paysum;

  GetLateDaysInPeriod2 = res;
  return;
end;

global
procedure GetCredManLateAmounts2(record CredManVc CredManr,Date sd,Date ed,Integer chargetype,var Longint maxlatedays,var val dueamount,var val notdueamount,var Date limitdate)
begin
  string 255 res;
  record CredHistVc CredHistr;
  Boolean TrHs;
  Longint latedays;
  Date tmpdate;

  dueamount = 0;
  maxlatedays = 0;
  TrHs = true;
  CredHistr.CredManNr = CredManr.SerNr;
  CredHistr.ChargeType = chargetype;
  while (LoopKey("CredManChargeType",CredHistr,2,TrHs)) begin
    if (CredHistr.CredManNr!=CredManr.SerNr or CredHistr.ChargeType!=chargetype) then begin
      TrHs = false;
    end else begin
      if (CredHistr.RecordType==0) then begin
        if (CredHistr.PayDate<=ed) then begin
          latedays = GetLateDaysInPeriod2(CredHistr,sd,ed,dueamount);
          /*
          if (dueamount>0 and latedays>=90) then begin
            tmpdate = AddDay(CredHistr.PayDate,90);
            if ((tmpdate<limitdate or blank(limitdate)) and tmpdate<ed) then begin
              limitdate = tmpdate;
            end;
          end;
          */
          maxlatedays = MAXLongint(maxlatedays,latedays);
        end else begin
          if (CredHistr.TransDate<=ed) then begin
            latedays = GetLateDaysInPeriod2(CredHistr,sd,ed,notdueamount);
          end;
        end;
      end;
    end;
  end;
  return;
end;

global
procedure CheckBuyOutAgreement2(record CredManVc CredManr,var record RcVc RepSpec,Boolean balancef)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record CredManSchedVc CSr;
  record IVVc IVr;
  val dueamount,openamount,lateamount,prepayval,buyoutfee;
  Integer latedays;
  Date sd,sd2;
  transaction Boolean gSilenceIVOpenPrepExists;
  array string 255 lateformula;
  Boolean schedf;
  Date calcsd;
  val creditedint;
  Date limitdate;
  Longint principlelatedays,interestlatedays,overdueslatedays;
  val principlelateamount,interestlateamount;
  val t;
  val notlateprinciple,notlateinterest;
  
logtext(0,"CheckBuyOutAgreement start");
//LogText(0,"aa RepSpec.d1=" & RepSpec.d1); //d1 is CurrentDate here. Why?

  gSilenceIVOpenPrepExists = true;
  BlockLoad(CMb);
    BuildCredManPayPlanCust2(CredManr,CredManPayPlanr,CMb,true,false,false);
  //  LogText(0,"2 RepSpec.d1=" & RepSpec.d1);
    CreateBuyOutInvoiceFromPlan(CredManr,CMb,CredManPayPlanr,RepSpec.d1,IVr,true,sd2,balancef);
//  end;
  CheckUnpaidInvoices(CredManr,dueamount,openamount);
  sd = GetLastInvoiceDate(CredManr,RepSpec.d1);
  GetCredManOverdueInvoices2(CredManr,CMb,RepSpec.d1,sd,latedays,lateamount,principlelateamount,interestlateamount,lateformula,false,false,calcsd);
  GetCredManLateAmounts2(CredManr,CredManr.startDate,RepSpec.d1,5,principlelatedays,principlelateamount,notlateprinciple,limitdate);
  GetCredManLateAmounts2(CredManr,CredManr.startDate,RepSpec.d1,6,interestlatedays,interestlateamount,notlateinterest,limitdate);
  //GetCredManLateAmounts(CredManr,RepSpec.sStartDate,RepSpec.sEndDate,9,overdueslatedays,overdueslateamount,limitdate);
  RepSpec.vals3 = GetActualBalance(CredManr,CredManPayPlanr,false);

  prepayval = GetPrepaymentValue(CredManr);
  if (balancef==false) then begin
    buyoutfee = GetBuyOutFee(CredManr,RepSpec.d1,RepSpec.vals3);
  end;
  RepSpec.vals1 = IVr.Sum4;
  RepSpec.vals0 = dueamount;//should this be openamount?
  RepSpec.vals2 = openamount + IVr.Sum4 - prepayval;
  RepSpec.f14 = buyoutfee;
  if (prepayval>0 and RepSpec.vals2<0) then begin
    RepSpec.vals2 = 0;
  end;
  RepSpec.vals4 = dueamount;
  RepSpec.f12 = lateamount;//(RepSpec.vals2-RepSpec.vals3-RepSpec.vals4);
  //BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,false);
  if (RepSpec.flags[1]==1) then begin
    RepSpec.f20 = GetCreditedInterest(CredManr,RepSpec.d1);  
  end;
  t = GetActualBalance(CredManr,CredManPayPlanr,true);
  RepSpec.f13 = t;
  RepSpec.f17 = principlelateamount+interestlateamount;//was openamount;
  RepSpec.f16 = GetInterestAmount(CredManr,RepSpec.d1);
  RepSpec.f10 = principlelateamount;//f20 - the last fxx
  RepSpec.f11 = interestlateamount;
  RepSpec.f15 = t + notlateprinciple; //GetActualBalance(CredManr,CredManPayPlanr,true);PLUS total of all OPEN, but NOT overdue principle
  gSilenceIVOpenPrepExists = false;

logtext(0,"CheckBuyOutAgreement end");

  return;
end;

global
procedure CheckBuyOutAgreement(record CredManVc CredManr,var record RcVc RepSpec)
begin

  CheckBuyOutAgreement2(CredManr,RepSpec,false);
  return;
end;

global
procedure CheckBuyOutAgreementAsync(record CredManVc CredManr,Date td,Integer wn)
begin
  record RcVc RepSpec;

  RepSpec.d1 = CurrentDate;
  CheckBuyOutAgreement(CredManr,RepSpec);
  clientremoteasync.CheckBuyOutAgreementCallBack(RepSpec,wn);

  return;
end;


//very sad that I have to map these now. Adding each new type needs an exception now
function Integer MapChargeTypes(Integer type)
begin
  Integer res;
  
  switch (type) begin
    case 9:  res = type;
    case 10: res = type;
    case 11: res = type;
    case 14: res = type;//prolong fee
    case 15: res = type;//extra fee
    case 16: res = type;//payment made
    case 17: res = type;//sold agreement
    case 18: res = type;//pay out
    case 19: res = type;//partial buyout
    otherwise
      res = type + 4;
  end;

  MapChargeTypes = res;
  return;
end;

global
updating procedure CreateCredHist(Longint recnr,Integer chargetype,string custcode,val sum,Integer rectype,string item,Date duedate,Longint agreementnr,Date invdate,var Longint histnr,Date perfrom,Date perto,Integer mainf,Longint previousnr,val invsum,Longint factinv,val paidval)
begin
  record CredHistVc CredHistr;
  
  histnr = -1;

  RecordNew(CredHistr);
  CredHistr.SerNr = NextSerNr("CredHistVc",CurrentDate,-1,false,"");
  CredHistr.TransDate = invdate;
  CredHistr.RecordNr = recnr;
  CredHistr.ChargeType = MapChargeTypes(chargetype);//from calc type to issued type
  CredHistr.CustCode = custcode;
  CredHistr.RecordType = rectype;
  CredHistr.ArtCode = item;
  CredHistr.PayDate = duedate;
  CredHistr.CredManNr = agreementnr;
  CredHistr.CredFromDate = perfrom;
  CredHistr.CredToDate = perto;
  CredHistr.MainRecord = mainf;
  CredHistr.PreviousNr = previousnr;
  CredHistr.InvSum = invsum;
  CredHistr.FactoringInvoice = factinv;
  if (nonblank(CredHistr.CredFromDate)) then begin
    CredHistr.Comment2 = CredHistr.CredFromDate & ":" & CredHistr.CredToDate;
  end;
  if (paidval>0) then begin
    CredHistr.PaidSum = paidval;
    if (CredHistr.PaidSum==CredHistr.InvSum) then begin
      CredHistr.PaidFlag = 1;
    end;
  end;

  CredHistr.Sum = sum;
  if (RecordInsert(CredHistr,true)) then begin
    histnr = CredHistr.SerNr;
  end;

  return;
end;

global
updating procedure RemoveCredHist(Longint recnr,Integer rectype)
begin
  record CredHistVc CredHistr;
  Boolean TrHs;
  
  TrHs = true;
  CredHistr.RecordNr = recnr;
  CredHistr.RecordType = rectype;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordType!=rectype or CredHistr.RecordNr!=recnr) then begin
      TrHs = false;
    end else begin
      RecordRemove(CredHistr);
      StepBack(CredHistr);
    end;
  end;

  return;
end;

function val CalculateRowSumWithVAT(record IVVc IVr,row IVVc IVrw)
begin
  val res;
  val vatprc,vatval,vatexclprc,vatinclprc,rowtax;

//first version is just row sum. We should include VAT to match with payments
  res = IVrw.Sum;
  InvVat(1,IVr.InclVAT,IVr.NoTAXonVAT,IVr.ExportFlag,IVrw.VATCode,IVrw.Sum,vatprc,vatval,vatexclprc,vatinclprc,rowtax);

  if (IVr.InclVAT==0) then begin
    res = res + vatval;
  end;



  CalculateRowSumWithVAT = res;
  return;
end;

global
updating procedure UpdateCredHistBalance(Longint credmannr,Longint invnr,Integer type)
begin
  record ORVc ORr;
  Integer i,rwcnt;
  record CredHistVc CredHistr,oldCredHistr;
  row ORVc ORrw;
  Boolean TrHs;
  val bal;
  
  GetCredManEventList2(credmannr,ORr);
  rwcnt = MatRowCnt(ORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORr,i,ORrw);
    if (ORrw.GroupOrdRow==invnr and ORrw.RowOrderType==type) then begin
      bal = ORrw.rowGP;
      i = rwcnt;
    end;
  end;
  TrHs = true;
  CredHistr.RecordNr = invnr;
  CredHistr.RecordType = 0;
  while (LoopKey("RecordNr",CredHistr,2,TrHs)) begin
    if (CredHistr.RecordNr!=invnr or CredHistr.RecordType!=type) then begin
      TrHs = false;
    end else begin
      RecordCopy(oldCredHistr,CredHistr);
      CredHistr.Balance = bal;
      RecordUpdate(oldCredHistr,CredHistr,true);
    end;
  end;

  return;
end;
/*
global
updating procedure UpdateCredHistBalancePartialBuyout(Longint credmannr,Longint credhistnr)
begin
  record ORVc ORr;
  Integer i,rwcnt;
  record CredHistVc CredHistr,oldCredHistr;
  row ORVc ORrw;
  Boolean TrHs;
  val bal;
  
  GetCredManEventList2(credmannr,ORr);
  rwcnt = MatRowCnt(ORr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(ORr,i,ORrw);
    if (ORrw.CUServiceHistNr==credhistnr) then begin
      bal = ORrw.rowGP;
      i = rwcnt;
    end;
  end;
  TrHs = true;
  CredHistr.SerNr = credhistnr;
  if (ReadFirstMain(CredHistr,1,true)) begin
    RecordCopy(oldCredHistr,CredHistr);
    CredHistr.Balance = bal;
    RecordUpdate(oldCredHistr,CredHistr,true);
  end;

  return;
end;
*/

updating procedure MakeFakeReceiptHist(record IVVc IVr,row IVVc IVrw)
begin
  Boolean TrHs;
  row IPVc IPrw;
  array val arrCredManr;
  record IPVc IPr;

  IPr.SerNr = IVr.SerNr;
  IPr.TransDate = IVr.InvDate;
  ClearRow(IPr,IPrw,1);
  IPrw.InvoiceNr = IVr.SerNr;
  IPrw.RecVal = IVrw.BasePrice;
  arrCredManr[IVr.CustCredManNr] = IVrw.BasePrice;
  MatRowPut(IPr,0,IPrw);
  FindUnpaidCredHist(IPr,IPrw,arrCredManr,2);

  return;
end;

function Boolean FindMatchingRow(record IVVc credIVr,Longint histnr,string item,var row IVVc tIVrw)
begin
  Integer i,rwcnt;
  row IVVc IVrw;
  Boolean res;
  
  rwcnt = MatRowCnt(credIVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(credIVr,i,IVrw);
    if (IVrw.CredHistNr==histnr) then begin
      res = true;
      MatRowGet(credIVr,i,tIVrw);
      i = rwcnt;
    end;
  end;
  if (res==false) then begin
    for (i=0;i<rwcnt;i=i+1) begin
      MatRowGet(credIVr,i,IVrw);
      if (IVrw.ArtCode==item) then begin
        res = true;
        MatRowGet(credIVr,i,tIVrw);
        i = rwcnt;
      end;
    end;
  end;

  FindMatchingRow = res;
  return;
end;

global
updating procedure UpdateCredHistInvoice(var record IVVc IVr,record IVVc IV2r)
begin
  row IVVc IVrw,tIVrw,prepIVrw;
  Integer i,rwcnt;
  Boolean prepayf;
  Longint histnr;
  Integer firstf;
  record IVVc credIVr;

  firstf = 1;
  if (IVr.InvType==kInvoiceTypeCredit) then begin
    //Currently remove only whole invoice. it's too much work now for checking each row separately
    if (IVr.OKFlag==1 and IV2r.OKFlag!=1) then begin
      if (IVr.CredInv>0) then begin
        credIVr.SerNr = IVr.CredInv;
        if (ReadFirstMain(credIVr,1,true)) then begin
          //RemoveCredHist(IVr.CredInv,kCredHistRecTypeInvoice);
          rwcnt = MatRowCnt(IVr);
          for (i=0;i<rwcnt;i=i+1) begin
            MatRowGet(IVr,i,IVrw);
            if (IVrw.ChargeType>0) then begin
              if (FindMatchingRow(credIVr,IVrw.CredHistNr,IVrw.ArtCode,tIVrw)) then begin
                CreateCredHist(IVr.SerNr,10,IVr.CustCode,CalculateRowSumWithVAT(IVr,IVrw),3,"",IVr.TransDate,IVr.CustCredManNr,IVr.TransDate,histnr,"","",0,tIVrw.CredHistNr,IVrw.Sum,-1,0);

                IVrw.CredHistNr = histnr;
                MatRowPut(IVr,i,IVrw);
                firstf = 0;
              end;
            end;
          end;
        end;
      end;
    end;
    if (IVr.OKFlag==0 and IV2r.OKFlag!=0) then begin
      RemoveCredHist(IVr.SerNr,kCredHistRecTypeCreditNote);
    end;
  end else begin
    if (IVr.OKFlag==0 and IV2r.OKFlag!=0) then begin
      RemoveCredHist(IVr.SerNr,kCredHistRecTypeInvoice);
      RemoveCredHist(IVr.SerNr,kCredHistRecTypePrepayment);
    end;
    
    if (IVr.OKFlag==1 and IV2r.OKFlag!=1) then begin
      rwcnt = MatRowCnt(IVr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(IVr,i,IVrw);
        if (IVrw.ChargeType==0 and nonblank(IVrw.ArtCode) and IVr.CustCredManNr>0) then begin
          IVrw.ChargeType = 15;
        end;
        if (IVrw.ChargeType>0) then begin
          CreateCredHist(IVr.SerNr,IVrw.ChargeType,IVr.CustCode,CalculateRowSumWithVAT(IVr,IVrw),kCredHistRecTypeInvoice,IVrw.ArtCode,IVr.PayDate,IVr.CustCredManNr,IVr.InvDate,histnr,IVr.CredFromDate,IVr.CredToDate,firstf,-1,IVr.Sum4,IVrw.FactoringInvoice,0);
          IVrw.CredHistNr = histnr;
          MatRowPut(IVr,i,IVrw);
          firstf = 0;
        end;
        if (IVrw.stp==kInvoiceRowTypePrepayment) then begin
          if (IVrw.BasePrice>0) then begin
            MatRowGet(IVr,i,prepIVrw);
            prepayf = true;
          end;
        end;
      end;
      if (prepayf) then begin
        for (i=0;i<rwcnt;i=i+1) begin
          MatRowGet(IVr,i,IVrw);
          if (IVrw.stp==kInvoiceRowTypePrepayment and IVrw.BasePrice>0) then begin
            MakeFakeReceiptHist(IVr,IVrw);
          end;
        end;
      end;
    end;
  end;

  UpdateCredHistBalance(IVr.CustCredManNr,IVr.SerNr,0);

  return;
end;

global
updating procedure UpdateCredManScheduleFromInvoice(record IVVc IVr,Boolean setf)
begin
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw;
  Integer rwcnt,i;

  if (IVr.CustCredManNr>0) then begin
    CSr.CredManNr = IVr.CustCredManNr;
    if (ReadFirstMain(CSr,1,true)) then begin
      RecordCopy(oldCSr,CSr);
      rwcnt = MatRowCnt(CSr);
      for (i=0;i<rwcnt;i=i+1) begin
        MatRowGet(CSr,i,CSrw);
        if (CSrw.InvDate==IVr.InvDate and (IVr.CredFromDate==CSrw.FromDate or (nonblank(IVr.CredFromDate) and nonblank(CSrw.FromDate)))) then begin
          if (setf) then begin
            CSrw.Invoiced = 1;
            CSrw.InvoiceNr = IVr.SerNr;
          end else begin
            CSrw.Invoiced = 0;
            CSrw.InvoiceNr = "";
          end;
          MatRowPut(CSr,i,CSrw);
          i = rwcnt;
        end;
      end;
      RecordUpdate(oldCSr,CSr,false);
    end;
  end;

  return;
end; 

procedure AddCredHistToArray(var record ORVc ORr,record CredHistVc prevCredHistr,val balance)
begin
  row ORVc ORrw;
  record IVVc IVr;
  record ARVc ARr;
  record IPVc IPr;
 
  ClearRow(ORr,ORrw,1);
  ORrw.GroupOrdRow = prevCredHistr.RecordNr;
  ORrw.RowOrderType = prevCredHistr.RecordType;
  ORrw.PickingDate = prevCredHistr.PayDate;
  ORrw.PlanShipRowDate = prevCredHistr.TransDate;
  ORrw.InloadingDate = prevCredHistr.CredFromDate;
  ORrw.DespatchRowDate = prevCredHistr.CredToDate;
  ORrw.rowGP = balance;
  ORrw.CUServiceHistNr = prevCredHistr.SerNr;
  if (prevCredHistr.RecordType==kCredHistRecTypeInvoice) then begin
    IVr.SerNr = prevCredHistr.RecordNr;
    if (ReadFirstMain(IVr,1,true)) then begin
      ORrw.Sum = IVr.Sum4;
      ARr.InvoiceNr = IVr.SerNr;
      if (ReadFirstMain(ARr,1,true)) then begin
        ORrw.TAX1Reb = ARr.RVal;
      end;
    end;
  end else begin
    IPr.SerNr = prevCredHistr.RecordNr;
  end;
  MatRowInsert(ORr,0,ORrw);

  return;
end;


global
procedure GetCredManEventList(record CredManVc CredManr,var record ORVc ORr)
begin
  record CredHistVc CredHistr,prevCredHistr;
  Boolean TrHs,firstf;
  val balance;
  Integer int_type;
  
  TrHs = true;
  CredHistr.CredManNr = CredManr.SerNr;
  int_type = GetInterestPaymentType(CredManr);
  if (int_type==2) then begin
    balance = 0;
  end else begin
    balance = CredManr.InvSum4;
  end;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if (CredHistr.CredManNr!=CredManr.SerNr) then begin
      TrHs = false;
    end else begin
      //sortrows
      if (firstf==true and (CredHistr.RecordType!=prevCredHistr.RecordType or CredHistr.RecordNr!=prevCredHistr.RecordNr)) then begin
        AddCredHistToArray(ORr,prevCredHistr,balance);
      end;
      if (CredHistr.RecordType==kCredHistRecTypeInvoice and (CredHistr.ChargeType==kEventTypeIssueInstalment or CredHistr.ChargeType==kEventTypeIssueDeposit or CredHistr.ChargeType==kEventTypePartialBuyout)) then begin
        balance = balance - CredHistr.Sum;
      end;
      if (CredHistr.RecordType==4) then begin//partial buyout
        balance = balance - CredHistr.Sum;
      end;
      if (CredHistr.RecordType==5 and int_type==2) then begin//payment
        balance = balance + CredHistr.Sum;
      end;
      firstf = true;
      RecordCopy(prevCredHistr,CredHistr);
    end;
  end;
  if (prevCredHistr.SerNr>-1) then begin
    AddCredHistToArray(ORr,prevCredHistr,balance);
  end;

  SortRows(ORr,"PlanShipRowDate",true);

  return;
end;

global
procedure GetCredManEventList2(Longint credmannr,var record ORVc ORr)
begin
  record CredManVc CredManr;

  CredManr.SerNr = credmannr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    GetCredManEventList(CredManr,ORr);
  end;  

  return;
end;

function Boolean BuyerPaidInvoice(record CredManVc CredManr,var Longint ivnr)
begin
  record CredHistVc CredHistr;
  Boolean res,TrHs;
  
//in first version we will assume this invoice has only one item therefore we can check record history only
  TrHs = true;
  while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,TrHs)) begin
    if (CredHistr.RecordType==0 and CredHistr.PaidFlag==1) then begin
      res = true;
      ivnr = CredHistr.RecordNr;
      TrHs = false;
    end;
  end;

  BuyerPaidInvoice = res;
  return;
end;

function Boolean GetFactoringDays(record CredManVc CredManr,var date paydate,var Integer factdays)
begin
  record CredHistVc CredHistr;
  Boolean res;

  paydate = "";
  while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,true)) begin
    if (CredHistr.RecordType==1) then begin
      if (CredHistr.TransDate>paydate) then begin
        paydate = CredHistr.TransDate;
      end;
    end;
  end;

  if (nonblank(paydate)) then begin
    factdays = DateDiff(paydate,CredManr.startDate);
    res = true;
  end;

  GetFactoringDays = res;
  return;
end; 

global
updating procedure StoreCredManSchedRecord(record CredManSchedVc CSr)
begin
  record CredManSchedVc oldCSr;

  oldCSr.CredManNr = CSr.CredManNr;
  if (ReadFirstMain(oldCSr,1,true)) then begin
    RecordUpdate(oldCSr,CSr,false);
  end else begin
    RecordInsert(CSr,true);
  end;

  return;
end;

global
procedure GenerateAgreementSchedule(record CredManVc CredManr,Boolean forcef,Boolean fullf)
begin
  record CredManSetBlock CMb;
  record CredManPayPlanVc CredManPayPlanr;
  record SMVc SMr;
  row SMVc SMrw;
  record CredManSchedVc CSr,oldCSr;
  row CredManSchedVc CSrw;
  Integer i,rwcnt,rw;
  Boolean updf,intf;
  record CredFeesMatrixVc FMr;
  val bal;
  transaction Boolean gSilenceIVOpenPrepExists;
  Integer int_type;
  
logtext(0,"GenerateAgreementSchedule1");
  gSilenceIVOpenPrepExists = true;
  CSr.CredManNr = CredManr.SerNr;
  if (ReadFirstMain(CSr,1,true)) then begin
    RecordCopy(oldCSr,CSr);
    rwcnt = MatRowCnt(CSr);
    if (fullf) then begin
      for (i=rwcnt-1;i>=0;i=i-1) begin
        MatRowDelete(CSr,i);
      end;
    end;
    updf = true;
  end else begin
    RecordNew(CSr);
    CSr.CredManNr = CredManr.SerNr;
    CSr.CustCode = CredManr.CustCode;
    CSr.CustName = CredManr.Addr0;
  end;
  if (updf and forcef==false) then begin
    goto lout;
  end;
  CSr.TransDate = CurrentDate;
  CSr.TransTime = CurrentTime;
  BlockLoad(CMb);
  BuildCredManPayPlanCust(CredManr,CredManPayPlanr,CMb,true,true);
  BuildCredManInfoMatrix(CredManr,CredManPayPlanr,CMb,SMr);
  int_type = GetInterestPaymentType(CredManr);
  if (int_type==2) then begin
    bal = 0;
  end else begin
    bal = CredManr.InvSum4;
  end;
  rwcnt = MatRowCnt(SMr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(SMr,i,SMrw);
    if (fullf or (intf==false) or updf==false) then begin
      if (fullf) then begin
        ClearRow(CSr,CSrw,1);
      end else begin
        MatRowGet(CSr,i,CSrw);
      end;
      CSrw.InvDate = SMrw.TransDate;
      CSrw.PayDate = SMrw.DueDate;
      CSrw.Type = SMrw.RowSimStat;
      switch (CSrw.Type) begin
        case 4:
          CSrw.Total = SMrw.CurDebVal;
          CSrw.Invoiced = 1;
          bal = bal - CSrw.Total;
          CSrw.Balance = bal;
        case 5:
          CSrw.Principle = SMrw.DebVal;
          bal = bal + CSrw.Principle;
          CSrw.Invoiced = 1;
          CSrw.Balance = bal;
        otherwise
          CSrw.FromDate = SMrw.Objects;
          CSrw.Principle = SMrw.DebVal - SMrw.ToRateB1;
          CSrw.Deposit = SMrw.ToRateB1;
          bal = bal - CSrw.Principle - CSrw.Deposit;
          CSrw.Balance = bal;
          CSrw.Interest = SMrw.CredVal;
          CSrw.Fees = SMrw.DebVal2;
          UnpackRowFieldMatrix(SMrw,"FeesMatrix",FMr);
          PackRowFieldMatrix(CSrw,"FeesMatrix",FMr);
          CSrw.Total = SMrw.CurDebVal;
          if (fullf) then begin
            CSrw.ToDate = SMrw.Comment;
          end;
          if (nonblank(SMrw.ExtraComment)) then begin
            CSrw.Invoiced = 1;
            CSrw.InvoiceNr = SMrw.ExtraComment;
          end;
      end;
      if (CSrw.Interest>0) then begin
        intf = true;
      end;
      MatRowPut(CSr,rw,CSrw);
      rw = rw + 1;
    end;
  end;
  qupdating.StoreCredManSchedRecord(CSr);

lout:;
logtext(0,"GenerateAgreementSchedule2");
  gSilenceIVOpenPrepExists = false;
  return;
end;

global
procedure CreateCredManSchedTask(string args)
begin
  record CredManVc CredManr;
  
  CredManr.SerNr = StringToLongint(args);
  if (ReadFirstMain(CredManr,1,true)) then begin
    GenerateAgreementSchedule(CredManr,false,true);
  end;

  return;
end;

global
function Boolean AgreementPaidOut(record CredManVc CredManr,var val paidout)
begin
  Boolean res;
  record CredHistVc CredHistr;
  val calcbal;

  paidout = 0;
  while (LoopKey("CredManTransDate:" & CredManr.SerNr,CredHistr,1,true)) begin
    if (CredHistr.RecordType==5) then begin//payment
      paidout = paidout + CredHistr.Sum;
    end;
  end;
  if (CredManr.InvSum4<=paidout) then begin
    res = true;
  end;

  AgreementPaidOut = res;
  return;
end;

global
function Boolean AgreementPaidOut2(record CredManVc CredManr,var val paidout)
begin
  Boolean res;
  record CredHistVc CredHistr;
  val calcbal;
  record VIVc VIr;
  record APVc APr;

  paidout = 0;
  if (GetInterestPaymentType(CredManr)==2) then begin
    AgreementPaidOut(CredManr,paidout);
  end else begin
    APr.SerNr = CredManr.VINr;
    VIr.SerNr = CredManr.VINr;
    ReadFirstmain(APr,1,true)
    if (ReadFirstmain(VIr,1,true)) then begin
      paidout = paidout + (VIr.PayVal-APr.RVal);
    end;
  end;

  AgreementPaidOut2 = res;
  return;
end;

global 
updating procedure CheckCredManFinished(Longint credmannr)
begin
  record CMOrderClassBlock OCb;
  record CredManVc CredManr,oldCredManr;
  record RcVc RepSpec;
  Integer int_type;
  val paidout;

  CredManr.SerNr = credmannr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    RepSpec.d1 = CurrentDate;
    int_type = GetInterestPaymentType(CredManr);
    if (int_type!=2 or AgreementPaidOut(CredManr,paidout)) then begin
      CheckBuyOutAgreement2(CredManr,RepSpec,true);
      if (RepSpec.vals2==0) then begin
        BlockLoad(OCb);
        RecordCopy(oldCredManr,CredManr);
        CredManr.OrderClass = OCb.FinishCredOrderClass;
        CredManr.Status = 7;
        RecordUpdate(oldCredManr,CredManr,true);
      end;
    end;
  end;
  

  return;
end;
global 
updating procedure CheckCredManFinished2(record IPVc IPr)
begin
  row IPVc IPrw;
  Integer i,rwcnt;
  vector Boolean vCMr;
  record IVVc IVr;

  rwcnt = MatRowCnt(IPr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IPr,i,IPrw);
    IVr.SerNr = IPrw.InvoiceNr;
    if (IPrw.InvoiceNr>0 and ReadFirstMain(IVr,1,true)) then begin
      if (IVr.CustCredManNr>0) then begin
        if (vCMr[IVr.CustCredManNr]==false) then begin
          CheckCredManFinished(IVr.CustCredManNr);
          vCMr[IVr.CustCredManNr] = true;
        end;
      end;
    end;
  end;
  

  return;
end;

global
function val GetCredManItemValue(record IVVc IVr,string item,Boolean setzerof)
begin
  Integer i,rwcnt;
  val res;
  row IVVc IVrw;

  if (setzerof) then begin
    res = 0;
  end;
  
  rwcnt = MatRowCnt(IVr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(IVr,i,IVrw);
    if (IVrw.ArtCode==item) then begin
      res = res + IVrw.Sum;
    end;
  end;

  GetCredManItemValue = res;
  return;
end;

global
function string 255 GetReceiptsPayMode(record IVVc IVr)
begin
  Boolean foundf;
  record IPrsVc IPrsr;
  string 255 res;
  record IPVc IPr;
  
  IPrsr.IVNr = IVr.SerNr;
  IPrsr.TransType = kIPrsTransTypeReceipt;
  foundf = true;
  while (LoopKey("IVKey",IPrsr,2,foundf)) begin
    if (IPrsr.IVNr!=IVr.SerNr or IPrsr.TransType!=kIPrsTransTypeReceipt) then begin 
      foundf = false;
    end else begin
      IPr.SerNr = IPrsr.TransNr;
      if (ReadFirstMain(IPr,1,true)) then begin
        res = IPr.PayMode;
        foundf = false;
      end;
    end;
  end;

  GetReceiptsPayMode = res;
  return;
end;

global
updating procedure MakeMoneyRuturnIVVcRemote(record IVVc IVr,var record IPVc IPr)
begin
  row IPVc IPrw;
  Integer rownr;
  val chk;
  Boolean installmentf;
  Longint err;
  record ARVc ARr;
  val sum;
  record IPVc oldIPr;

  sum = IVr.Sum4;
  ARr.InvoiceNr = IVr.SerNr;
  if (ReadFirstMain(ARr,1,true)) then begin
    if (ARr.RVal>=0) then begin
      sum =   IVr.Sum4 - ARr.RVal;
    end;
  end;

  if (sum>0) then begin
    RecordNew(IPr);
    IPr.TransDate = CurrentDate;
    IPr.SerNr = NextSerNr("IPVc",IPr.TransDate,-1,false,"");
    IPr.RegDate = CurrentDate;
    IPr.OKFlag = 0;
    IPr.PayMode = GetReceiptsPayMode(IVr);
    IPPastePayMode(IPr);
    rownr = 0;
    ClearRow(IPr,IPrw,1);
    IPrw.InvoiceNr = IVr.SerNr;
    MatRowPut(IPr,rownr,IPrw);
    PasteInvIn2IPr(IPr,rownr,IPr.TransDate,chk,false,installmentf);
    MatRowGet(IPr,rownr,IPrw);
    IPrw.RecVal = -sum;
    MatRowPut(IPr,rownr,IPrw);
    IPVc_PasteRecVal(IPr,rownr);

    rownr = 1;
    ClearRow(IPr,IPrw,1);
    IPrw.CustCode = IVr.CustCode;
    MatRowPut(IPr,rownr,IPrw);
    IPVc_PasteCustCode(IPr,rownr,err);
    MatRowGet(IPr,rownr,IPrw);
    IPrw.RecVal = sum;
    IPrw.CUPNr = IPr.SerNr;
    MatRowPut(IPr,rownr,IPrw);
    IPVc_PasteRecVal(IPr,rownr);
    
    IPSumup(IPr);
    if (RecordInsert(IPr,true)) then begin
      RecordCopy(oldIPr,IPr);
      IPr.OKFlag = 1;
      RecordUpdate(oldIPr,IPr,true);
    end;
  end;
  return;
end;

global
function boolean CustomerHasAgreement(string cucode,string agreementlist)
begin
  Longint pos2;
  string 255 tmp;
  record CredManVc CredManr;
  boolean testf;
  
  testf = false;
  pos2 = -1;
  while (GetNextSubstring(agreementlist,pos2,",",tmp)) begin
    CredManr.SerNr = StringToLongint(tmp);
    if (ReadFirstMain(CredManr,1,true)) then begin
      if (CredManr.CustCode==cucode) then begin
        testf = true;
        goto LWhile;
      end;
    end;
  end;
  LWhile:;
  CustomerHasAgreement = testf;
  return;
end;

global
function boolean CheckIPCredManNr(longint credmannr,record IPVc IPr)
begin
  record CredHistVc CredHistr;
  boolean res;
  
  res = false;
  CredHistr.RecordNr = IPr.SerNr;
  CredHistr.RecordType = kCredHistRecTypeReceipt;
  if (ReadFirstKey("RecordNr",CredHistr,2,true)) then begin
    if (CredHistr.CredManNr==credmannr) then begin
      res = true;
    end;
  end;
  CheckIPCredManNr = res;
  return;
end;

global
function boolean IsCredManNrInvoice(longint credmannr,longint invoicenr)
begin
  record CredHistVc CredHistr;
  boolean res;
  
  res = false;
  if (invoicenr>-1) then begin
    CredHistr.RecordType = kCredHistRecTypeInvoice;
    CredHistr.RecordNr = invoicenr;
    if (ReadFirstKey("RecordNr",CredHistr,2,true)) then begin
      if (CredHistr.CredManNr==credmannr) then begin
        res = true;
      end;
    end;
    if (res==false) then begin
      CredHistr.RecordType = kCredHistRecTypeCreditNote;
      CredHistr.RecordNr = invoicenr;
      if (ReadFirstKey("RecordNr",CredHistr,2,true)) then begin
        if (CredHistr.CredManNr==credmannr) then begin
          res = true;
        end;
      end;
    end;
  end;
  IsCredManNrInvoice = res;
  return;
end;

global
function val GetCredManBalanceOnDate(longint credmannr,date d)
begin
  val res,t;
  record CredManSetBlock CredManSetb;
  record CredManPayPlanVc CredManPayPlanr;
  row CredManPayPlanVc CredManPayPlanrw;
  record CredManVc CredManr;
  record CredHistVc CredHistr;
  boolean TrHs;
  
 /* does not work for periodic statement?
  BlockLoad(CredManSetb);
  CredManr.SerNr = credmannr;
  if (ReadFirstMain(CredManr,1,true)) then begin
    BuildCredManPayPlanCust2(CredManr,CredManPayPlanr,CredManSetb,true,true,false);  
    res = GetBalanceOnDate(CredManPayPlanr,d);
  end;
  */
  CredHistr.CredManNr = credmannr;
  TrHs = true;
  while (LoopKey("CredManTypeDate",CredHistr,1,TrHs)) begin
    if(CredHistr.CredManNr!=credmannr) then begin
      TrHs = false;
    end;
    if (CredHistr.TransDate>d) then begin
      TrHs = false;
    end;
    if (TrHs) then begin
      if (CredHistr.RecordType==kCredHistRecTypeInvoice) then begin
        t = GetCredHistOpenValueOnDate(CredHistr.SerNr,d);
        res = res + t;
      end;
    end;
  end;
  LogText(0,"GetCredManBalanceOnDate= " & res & " credmannr=" & credmannr & " d=" & d);
  GetCredManBalanceOnDate = res;
  return;
end;

global
function val GetCredManStartBalance(longint credmannr,date d)
begin
  date d1;
  
  d1 = AddDay(d,-1);
  GetCredManStartBalance = GetCredManBalanceOnDate(credmannr,d1);
  return;
end;